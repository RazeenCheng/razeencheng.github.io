<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Mac OS 自动根据 WI-FI 名字改变网络位置</title>
    <url>//post/auto-change-network-location-base-on-name-of-wifi.html</url>
    <content><![CDATA[<p>Mac OS给我们提供了一个Network Location的功能，我们可以在不同的Location下设置不同的DNS/VPN等等。然而每次实际位置变化后，都要我们手动去切换。由于我在公司和家里使用的DNS服务器并不相同，很多时候到公司发现一些公司的内网连接不上了，反复检查 才想起来，哦？位置忘切换了！</p><p>我想，能不能根据地理位置改变这个Location呢？Google一圈发现并没有。但是有人提供了另外一种方式。那就是根据WI-FI的名字，修改该Location。一般WI-FI名字不会经常改变，所以这也是间接实现该需求了。</p><a id="more"></a><p><img data-src="https://st.razeen.cn/img/image/image-20190406043544155.png" alt></p><p>原开源项目在<a href="https://github.com/eprev/locationchanger" target="_blank" rel="noopener">这里</a>。</p><h3 id="安装与设置"><a href="#安装与设置" class="headerlink" title="安装与设置"></a>安装与设置</h3><p>设置很简单。</p><ol><li>安装该脚本。</li></ol><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ curl -L https://github.com/eprev/locationchanger/raw/master/locationchanger.sh | bash</span><br></pre></td></tr></table></figure><p>这会需要你输入密码。自动将<code>locationchanger</code>脚本安装到了<code>/usr/local/bin</code>目录。</p><ol start="2"><li><p>设置。</p><p>如果你的位置名称WIFI名称一致(如Localtion是home, WIFI名字也是home)，不用设置你直接都可以使用了。</p><p>如果你和我一样，位置的名称与WIFI名称并不一致，或者多个WIFI对应于同一个位置，你可以跟着我设置一下。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ mkdir ~/.locations</span><br><span class="line">$ touch ~/.locations/locations.conf</span><br></pre></td></tr></table></figure><p>修改<code>lcoations.conf</code>文件，并保存。如：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">︿(￣︶￣)︿.=home</span><br><span class="line">︿(￣︶￣)︿=home</span><br><span class="line">TrustAsiaEAP=office</span><br></pre></td></tr></table></figure><p>前面是WI-FI名称，后面是位置名称。</p></li><li><p>切换日志会写入<code>~/Library/Logs/LocationChanger.log</code>文件, 如下命令可以查看。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ tail -f ~/Library/Logs/LocationChanger.log</span><br></pre></td></tr></table></figure></li></ol><h3 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h3><p>现在我们切换一下WIFI看下效果。</p><p>当前</p><p><img data-src="https://st.razeen.cn/img/image/image-20190406045533655.png" alt></p><p>切换一下WI-FI。</p><p><img data-src="https://st.razeen.cn/img/image/image-20190406045949910.png" alt></p><p>我连接的是我手机的Wi-Fi，没有为该WI-FI配置位置，就自动切换到了Automatic。</p><p>看看日志：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ tail -f ~/Library/Logs/LocationChanger.log</span><br><span class="line"></span><br><span class="line">[2019-04-06 04:59] Connected to <span class="string">'Razeen.Cheng-iPhone'</span></span><br><span class="line">[2019-04-06 04:59] Will switch the location to <span class="string">'Razeen.Cheng-iPhone'</span></span><br><span class="line">[2019-04-06 04:59] Location <span class="string">'Razeen.Cheng-iPhone'</span> was not found. Will default to <span class="string">'Automatic'</span></span><br><span class="line">[2019-04-06 04:59] Changing the location to <span class="string">'Automatic'</span></span><br><span class="line">CurrentSet updated to 3E129B23-9186-447F-A402-7EDFFDA16C72 (Automatic)</span><br></pre></td></tr></table></figure><p>再切换回来：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[2019-04-06 05:01] Connected to <span class="string">'︿(￣︶￣)︿.'</span></span><br><span class="line">[2019-04-06 05:01] Will switch the location to <span class="string">'home'</span> (configuration file)</span><br><span class="line">[2019-04-06 05:01] Changing the location to <span class="string">'home'</span></span><br><span class="line">CurrentSet updated to 710A1F1F-D207-4CF8-A36E-268FF3EE2C9E (home)</span><br></pre></td></tr></table></figure><p>很方便，再也不用担心忘记切换位置了～</p><h3 id="更多功能"><a href="#更多功能" class="headerlink" title="更多功能"></a>更多功能</h3><p>其实，该脚本的强大之处就是监听了系统的网络切换事件。不仅可以在切换的时候切换NetWork Location, 还可以自动运行一些自定义脚本。设置起来同样简单。</p><p>如，我要切换到<code>office</code>位置的时候，打开<code>Dark Mode</code> , 当我到<code>home</code>或其他位置时关闭<code>Dark Mode</code>。</p><p>只需要我在<code>~/.locations/office</code>添加以下脚本：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env bash</span></span><br><span class="line"><span class="built_in">exec</span> 2&gt;&amp;1</span><br><span class="line"></span><br><span class="line">osascript -e <span class="string">'tell application "System Events" to tell appearance preferences to set dark mode to true'</span></span><br></pre></td></tr></table></figure><p>在<code>~/.locations/home</code> 和 <code>~/.locations/Automatic</code>下添加以下脚本</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env bash</span></span><br><span class="line"><span class="built_in">exec</span> 2&gt;&amp;1</span><br><span class="line"></span><br><span class="line">osascript -e <span class="string">'tell application "System Events" to tell appearance preferences to set dark mode to false'</span></span><br></pre></td></tr></table></figure><p>完整步骤：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ touch ~/.locations/office ~/.locations/home ~/.locations/Automatic</span><br><span class="line"></span><br><span class="line">$ cat &gt; ~/.locations/office &lt;&lt; EOT</span><br><span class="line"><span class="meta">#!/usr/bin/env bash</span></span><br><span class="line"><span class="built_in">exec</span> 2&gt;&amp;1</span><br><span class="line"></span><br><span class="line">osascript -e <span class="string">'tell application "System Events" to tell appearance preferences to set dark mode to true'</span></span><br><span class="line">EOT</span><br><span class="line"></span><br><span class="line">$ cat &gt; ~/.locations/home &lt;&lt; EOT</span><br><span class="line"><span class="meta">#!/usr/bin/env bash</span></span><br><span class="line"><span class="built_in">exec</span> 2&gt;&amp;1</span><br><span class="line"></span><br><span class="line">osascript -e <span class="string">'tell application "System Events" to tell appearance preferences to set dark mode to false'</span></span><br><span class="line">EOT</span><br><span class="line"></span><br><span class="line">$ cat &gt; ~/.locations/Automatic &lt;&lt; EOT</span><br><span class="line"><span class="meta">#!/usr/bin/env bash</span></span><br><span class="line"><span class="built_in">exec</span> 2&gt;&amp;1</span><br><span class="line"></span><br><span class="line">osascript -e <span class="string">'tell application "System Events" to tell appearance preferences to set dark mode to false'</span></span><br><span class="line">EOT</span><br><span class="line"></span><br><span class="line">$ chmod +x Automatic home office</span><br></pre></td></tr></table></figure><p>然后切换Wi-Fi你就能看到效果了～</p><p>最后，感叹一下<code>osascript</code>, 这个苹果自带的命令很厉害，值得多学习一下。</p><ul><li><a href="https://ruimarinho.github.io/post/automating-network-location-switching-on-macos/" target="_blank" rel="noopener">Automating network location switching on macOS</a></li></ul>]]></content>
      <categories>
        <category>默认</category>
        <category>效率提升</category>
      </categories>
      <tags>
        <tag>mac-os</tag>
        <tag>location</tag>
      </tags>
  </entry>
  <entry>
    <title>我又又又把博客迁移了</title>
    <url>//post/blog-migration-hexo-next.html</url>
    <content><![CDATA[<p>好久没有维护博客，看了一下<a href="https://github.com/theme-next/hexo-theme-next" target="_blank" rel="noopener">Next主题</a>的相关功能，最后决定将博客切到了hexo，原博客在<a href="https://blog.netcj.com" target="_blank" rel="noopener">这里</a>。原<a href="https://github.com/eiblog/eiblog" target="_blank" rel="noopener">eiblog</a>有些东西想去更新，一直没有动手，这里立个flag，有空了在eiblog基础上改些东西，大概有：</p><ul><li style="list-style:none"><input type="checkbox">自动更新disqus js(每次js更新了，disqus就加载不了)</li><li style="list-style:none"><input type="checkbox">数据库切换到sqlite3 (用gorm支持多种数据库)</li><li style="list-style:none"><input type="checkbox">侧边栏可以自定义添加页面</li><li style="list-style:none"><input type="checkbox">更容易部署</li></ul><a id="more"></a><p>这次迁移到<code>Hexo</code>, 主要因为<code>Next</code>主题确实做的很完备啊。</p><ul><li style="list-style:none"><input type="checkbox" checked>支持全局搜索</li><li style="list-style:none"><input type="checkbox" checked>支持CDN加速</li><li style="list-style:none"><input type="checkbox" checked>支持懒加载</li><li style="list-style:none"><input type="checkbox" checked>支持toc</li><li style="list-style:none"><input type="checkbox" checked>支持feed</li><li style="list-style:none"><input type="checkbox" checked>支持sitemap</li><li style="list-style:none"><input type="checkbox" checked>一键部署</li></ul><p>该博客的全局配置文件在<a href="https://github.com/razeencheng/blog/blob/master/_config.yml" target="_blank" rel="noopener">这里</a>, 该博客的主题配置在<a href="https://github.com/razeencheng/hexo-theme-next/blob/master/_config.yml" target="_blank" rel="noopener">这里</a>。</p><h3 id="全局搜索"><a href="#全局搜索" class="headerlink" title="全局搜索"></a>全局搜索</h3><p>修改主题内<code>_config.yml</code></p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="string">local_search:true</span></span><br></pre></td></tr></table></figure><p>修改全局配置<code>_config.yml</code></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">search:</span><br><span class="line">  path: search.xml</span><br><span class="line">  field: post</span><br><span class="line">  format: html</span><br><span class="line">  limit: 1000</span><br></pre></td></tr></table></figure><h3 id="CDN全局加速"><a href="#CDN全局加速" class="headerlink" title="CDN全局加速"></a>CDN全局加速</h3><p>CDN能给站点的加载速度提高很多，一些<code>js</code>，<code>css</code>，图片资源都可以放到CDN上。</p><p>修改主题内<code>_config.yml</code>，设置<code>vendors</code>里面的CDN地址。</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">vendors:</span></span><br><span class="line">  <span class="attr">_internal:</span> <span class="string">libs</span></span><br><span class="line">  </span><br><span class="line">  <span class="attr">jquery:</span> <span class="string">https://cdnjs.cloudflare.com/ajax/libs/jquery/2.1.3/jquery.min.js</span></span><br><span class="line">  </span><br><span class="line">  <span class="attr">fancybox_css:</span> <span class="string">https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css</span></span><br><span class="line">  </span><br><span class="line">  <span class="string">...</span></span><br></pre></td></tr></table></figure><p>一般你做到这样就可以了，但我有点不相信这些CDN, 写了个<code>go</code>脚本把这些全部上传到七牛。。。</p><p>然后，我发现，<code>public</code>里面的<code>js</code>文件和图片每次生成都不会发生变化，于是我把这些都全到了七牛。。。</p><p>然后修改一下主题内<code>_config.yml</code>文件，把<code>Assets</code>修改如下：</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">css:</span> <span class="string">css</span></span><br><span class="line"><span class="attr">js:</span> <span class="string">https://st.razeen.cn/img/js</span></span><br><span class="line"><span class="attr">images:</span> <span class="string">https://st.razeen.cn/img/image</span></span><br></pre></td></tr></table></figure><h3 id="图片懒加载"><a href="#图片懒加载" class="headerlink" title="图片懒加载"></a>图片懒加载</h3><p>有些文章图片比较多，图片懒加载能让你需要看到图片的时候再加载图片，节省了很多流量，能提高不少加载速度。</p><p><code>Next</code>主题可以通过插件<code>tag</code>的方式支持懒加载。具体插件文档在<a href="https://theme-next.org/docs/tag-plugins/" target="_blank" rel="noopener">这里</a>。开启改功能我们需要安装<code>hexo-lazyload-image</code>插件, 然后在根目录执行<code>npm install hexo-lazyload-image --save</code>。</p><p>然后修改主题内<code>_config.yml</code>文件：</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Added switch option for separated repo in 6.0.0.</span></span><br><span class="line"><span class="comment"># Dependencies: https://github.com/theme-next/theme-next-jquery-lazyload</span></span><br><span class="line"><span class="attr">lazyload:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>懒加载格式如下：</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 懒加载</span></span><br><span class="line">![](https://st.razeen.cn/img/zhifubao.png)</span><br><span class="line">![](https://st.razeen.cn/img/zhifubao.png )</span><br></pre></td></tr></table></figure><h3 id="支持TOC"><a href="#支持TOC" class="headerlink" title="支持TOC"></a>支持TOC</h3><p>toc是啥？就是目录。</p><p>修改主题内<code>_config.yml</code>即可。</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Table Of Contents in the Sidebar</span></span><br><span class="line"><span class="attr">toc:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># Automatically add list number to toc.</span></span><br><span class="line">  <span class="attr">number:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># If true, all words will placed on next lines if header width longer then sidebar width.</span></span><br><span class="line">  <span class="attr">wrap:</span> <span class="literal">false</span></span><br><span class="line">  <span class="comment"># Maximum heading depth of generated toc. You can set it in one post through `toc_max_depth` var.</span></span><br><span class="line">  <span class="attr">max_depth:</span> <span class="number">6</span></span><br></pre></td></tr></table></figure><h3 id="RSS-Feed"><a href="#RSS-Feed" class="headerlink" title="RSS Feed"></a>RSS Feed</h3><p>支持RSS订阅，这个以前很火的。</p><p>先安装插件<code>hexo-generator-feed</code>。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install hexo-generator-feed --save</span><br></pre></td></tr></table></figure><p>修改博客内插件<code>_config.yml</code>。</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">rss:</span></span><br></pre></td></tr></table></figure><p>这里不设置false就行了，设true会出如下问题。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">path.startsWith is not a <span class="keyword">function</span></span><br></pre></td></tr></table></figure><h3 id="sitemap"><a href="#sitemap" class="headerlink" title="sitemap"></a>sitemap</h3><p>为了方便搜索引擎收录，提高SEO，sitemap肯定需要的。</p><p>安装插件<code>hexo-generator-sitemap</code>,<code>hexo-generator-baidu-sitemap</code>。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install hexo-generator-sitemap --save</span><br><span class="line">$ npm install hexo-generator-baidu-sitemap --save</span><br></pre></td></tr></table></figure><p>修改根目录<code>_config.yml</code>, 添加如下：</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">sitemap:</span></span><br><span class="line">   <span class="attr">path:</span> <span class="string">sitemap.xml</span></span><br><span class="line"><span class="attr">baidusitemap:</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">baidusitemap.xml</span></span><br></pre></td></tr></table></figure><h3 id="robots-txt"><a href="#robots-txt" class="headerlink" title="robots.txt"></a>robots.txt</h3><p>这也是提高SEO的，设置搜索引擎可以抓取哪些，不需要抓取哪些内容。</p><p>在<code>themes/source/next/source</code>目录下添加。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">User-agent: *</span><br><span class="line">Allow: /</span><br><span class="line">Allow: /archives/</span><br><span class="line">Allow: /categories/</span><br><span class="line">Allow: /tags/</span><br><span class="line">Allow: /about/</span><br><span class="line"></span><br><span class="line">Disallow: /vendors/</span><br><span class="line">Disallow: /js/</span><br><span class="line">Disallow: /css/</span><br><span class="line">Disallow: /fonts/</span><br><span class="line">Disallow: /vendors/</span><br><span class="line">Disallow: /fancybox/</span><br><span class="line"></span><br><span class="line">Sitemap: https://razeen.me/sitemap.xml</span><br><span class="line">Sitemap: https://razeen.me/baidusitemap.xml</span><br></pre></td></tr></table></figure><h3 id="一键部署"><a href="#一键部署" class="headerlink" title="一键部署"></a>一键部署</h3><p>关于一键部署更多的内容看<a href="https://razeen.me/post/daily-hexo-auto-refresh.html" target="_blank" rel="noopener">这里</a>。</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><h5 id="自定义css样式"><a href="#自定义css样式" class="headerlink" title="自定义css样式"></a>自定义css样式</h5><p>文章中默认的a链接的样式是黑色的，不太明显，改成蓝色。</p><p>修改<code></code>themes/source/custom.styl`, 添加如下行。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">// Custom styles.</span><br><span class="line"><span class="selector-tag">if</span> <span class="selector-tag">hexo-config</span>("<span class="selector-tag">custom_css</span><span class="selector-class">.post_body_a</span><span class="selector-class">.enable</span>")</span><br><span class="line">  <span class="selector-class">.post-body</span></span><br><span class="line">    <span class="selector-tag">a</span>&#123;</span><br><span class="line">      <span class="attribute">color</span>: <span class="built_in">convert</span>(hexo-config(<span class="string">"custom_css.post_body_a.normal_color"</span>));</span><br><span class="line">      &amp;:hover &#123;</span><br><span class="line">        <span class="selector-tag">color</span>: <span class="selector-tag">convert</span>(<span class="selector-tag">hexo-config</span>("<span class="selector-tag">custom_css</span><span class="selector-class">.post_body_a</span><span class="selector-class">.hover_color</span>"));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>修改<code>themes/_config.yml</code>，增加如下行。</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">custom_css:</span></span><br><span class="line">  <span class="attr">post_body_a:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">normal_color:</span> <span class="string">"#0593d3"</span></span><br><span class="line">    <span class="attr">hover_color:</span> <span class="string">"#0477ab"</span></span><br></pre></td></tr></table></figure><p>完成。</p><p>换个皮肤，希望自己新的一年里多写几篇博客～。</p>]]></content>
      <categories>
        <category>博客折腾日记</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>next</tag>
      </tags>
  </entry>
  <entry>
    <title>书单 - 2018</title>
    <url>//post/books.html</url>
    <content><![CDATA[<p>读万卷书，行万里路。在这里整理整理自己读过，买过没读过以及想读的书。</p><a id="more"></a><p><br></p><ul><li>【一】C程序设计语言</li><li>【未】现代操作系统</li><li>【未】编码</li><li>【未】重构改善既有的代码设计</li></ul><p><br></p><ul><li>【零】Linux Shell 脚本攻略</li><li>【未】Linux私房菜</li></ul><p><br></p><ul><li>【零】JavaScript 忍者秘籍</li></ul><p><br></p><ul><li>【一】Go并发编程实战</li><li>【零】Go语言学习笔记</li><li>【一】Go Web 编程</li></ul><p><br></p><ul><li>【一】Effective Objective-C</li><li>【一】Objective-C 编程之道</li><li>【一】Objective-C 高级编程</li><li>【一】Objective-C 程序设计</li><li>【零】iOS应用逆向工程</li><li>【一】精通iOS开发</li></ul><p><br></p><ul><li>【零】深入浅出密码学</li><li>【零】PKI/CA与数字证书技术大全</li><li>【零】HTTPS权威指南</li></ul><p><br></p><ul><li>【零】PostgreSQL实战</li></ul><p><br></p><ul><li>【未】Python学习手册</li></ul><p><br></p><ul><li>【未】全球通史 从史前史到21世纪（第7版 修订版）（套装上下册）</li><li>【一】狼图腾（修订版）</li><li>【一】三毛全集 （共11册）</li><li>【零】红楼梦 （上下册）</li><li>【未】牛虻 （中英文2册）</li><li>【一】活着</li><li>【一】兄弟</li><li>【一】许三观卖血记</li><li>【一】在细雨中呐喊</li><li>【一】弘一大师</li><li>【未】明朝哪些事儿</li><li>【一】曾国藩</li><li>【一】背包十年</li></ul><p><br></p><ul><li>【零】创业维艰</li><li>【零】一本摄影书（I）</li><li>【零】一本摄影书（II）</li><li>【零】素书</li><li>【零】金字塔原理</li></ul><p><br></p><ul><li>【零】星火英语语法全解</li><li>【零】六级词汇</li><li>【一】算法设计与分析</li><li>【一】Java程序开发</li><li>【一】SAS软件与系统应用教程</li><li>【一】计算机操作系统</li><li>【一】数据结构</li><li>【一】信息论与编码</li><li>【一】计算机系统网络基础</li><li>【一】数据库原理及应用教程</li></ul><p><br></p>]]></content>
      <categories>
        <category>默认</category>
      </categories>
      <tags>
        <tag>books</tag>
      </tags>
  </entry>
  <entry>
    <title>如何用 Go 调用 Windows API</title>
    <url>//post/breaking-all-the-rules-using-go-to-call-windows-api.html</url>
    <content><![CDATA[<p>有时候为了更好的兼容Windows, 或者我们为了获得更高级别功能的访问权限（如配置或创建JobObjects或安全令牌等），我们需要直接去调用Windows的系统API。 很幸运，我们可以利用<code>syscall</code>包与系统直接通信，不用用到<code>CGO</code> 。 然而，也有不方便的地方，如大多数的API，我们需要依赖不安全 <code>(unsafe)</code>的内存管理。</p><p>这篇文章，主要记录了我在平时开发过程中以及网上收集到的一些关于Windows API调用相关的知识，或者开发模式，方便你遇到类似的情况后，能更快入手。</p><a id="more"></a><blockquote><p>注 <sup>1</sup> 本文完整Demo在<a href="https://github.com/razeencheng/demo-go/tree/master/windows_api" target="_blank" rel="noopener">这里</a>。<br>注<sup>2</sup> 文章中并未严格区分过程与函数。</p></blockquote><h3 id="关于syscall-包"><a href="#关于syscall-包" class="headerlink" title="关于syscall 包"></a>关于<code>syscall</code> 包</h3><p>在Go中，<code>syscall</code>包会由于你指定的系统或架构的不同而编译出不同的结果，因为<code>syscall</code>包里需要编译的函数或类型会根据你指定的编译参数不同而不同。在导入<code>syscall</code>时你必须在代码中指定”build tags” 或 用指定的文件后缀来命名你的文件。 Dave Cheney <a href="https://dave.cheney.net/2013/10/12/how-to-use-conditional-compilation-with-the-go-build-tool" target="_blank" rel="noopener">有篇文章</a>深入的介绍了<code>go build</code>机制，可以看一看。简单来说，</p><ul><li>如果你的文件命名结构是这样的，<code>name_{GOOS}_{GOARCH}.go</code> 或者 <code>name_{GOOS}.go</code>, 那么这个文件只有在指定的<code>GOOS</code>+指定的<code>GOARCH</code>上才会编译。如：<code>myfile_windows_amd64.go</code>只会在<code>amd64</code>架构CPU的Windows上才会编译。 而<code>myfile_windows.go</code>会在Windows上编译，就不限制CPU架构了。</li><li>如果你在go代码顶部增加<code>// +build windows,amd64</code> 注释，那么该文件只会在<code>amd64</code>架构CPU的Windows上才会编译。</li></ul><h3 id="关于-unsafe包"><a href="#关于-unsafe包" class="headerlink" title="关于 unsafe包"></a>关于 <code>unsafe</code>包</h3><p>下面是一段<code>Youtube</code>视频(需要代理)。</p><iframe width="560" height="315" src="https://www.youtube.com/embed/PAAkCSZUG1c?start=830" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe><p>视频中 <code>Rob Pike</code>提到：</p><p><em>With the unsafe package there are no guarantees.</em></p><p>是的，<code>Rob Pike</code>不推荐使用<code>unsafe</code>包，因为它<strong>没有任何保障</strong>。</p><p>那么，为什么说使用<code>unsafe</code>包没有任何保障呢？</p><ol><li><p>Go (运行时) 不能保证内置类型（如切片、字符串）在不同的Go版本中内存结构是完全一样的。而且作为支持垃圾回收的语言，开发者并不知道Go内存管理的细节。<code>unsafe</code>包会暴露一些内部实现或实际的内存地址，这可能会让你做一些超出预期的事情，如你不小心改变了某个指针指向的地址。</p></li><li><p>Go (语言层面) 不能保证不同版本之间会有相同的特征或者函数签名，换句话来说，就是在 <a href="https://golang.org/doc/go1compat" target="_blank" rel="noopener">Go 1.x的兼容性承诺</a>中,并不包含<code>unsafe</code>包。</p></li></ol><blockquote><p><strong>Warning:</strong> <em>Avoid <code>unsafe</code> like the plague; if you can help it.</em></p></blockquote><p>这两点都告诉我们，在使用<code>unsafe</code>包的时候，我们需要特别的注意应该怎么去使用。我们必须了解，用<code>unsafe</code>包操作内存时，我们能做什么和不能做什么。而且这也可能会因为不同的Go版本而发生变化，在<code>unsafe</code>的<a href="https://golang.org/pkg/unsafe/" target="_blank" rel="noopener">官方文档</a>中，我们能了解到哪些我们该做，哪些不该做，我们应该密切关注。</p><p><strong>Note:</strong> 从技术上来说，<code>syscall</code>包，也不在 <a href="https://golang.org/doc/go1compat" target="_blank" rel="noopener">Go 1.x的兼容性承诺</a>中，因为它也不能保证系统是否向后兼容。不过，从Go1.4开始, go底层基本稳定，只有在操作系统发生变化才会有可能发生更改。而调用<code>Windows DLL</code>的部分改变的可能性比较小，这点对我们是个好消息。</p><p>在<a href="https://godoc.org/golang.org/x/sys/windows" target="_blank" rel="noopener"><code>x/sys/windows</code></a>包中，包含了Go1.x中使用的所有的Windows API调用，你可以直接拿来使用，但注意以下几点：</p><ol><li>该包不在<a href="https://golang.org/doc/go1compat" target="_blank" rel="noopener">Go 1.x的兼容性承诺</a>中, 不能保证你的代码稳定，如果想保持稳定，可以切到稳定的Git版本中。</li><li>该包的目标也不是暴露所有的Windows API, 而是为Go标准库其他包提供更便携的接口，如<code>os</code>,<code>time</code>和<code>net</code>包。所以你需要的内容，不一定能在该包找到。</li></ol><p>虽然是这样，但是现在我们知道了该用那些包去调用Windows API了，同时我们也要知道这会有一定的风险。</p><h3 id="Windows-API"><a href="#Windows-API" class="headerlink" title="Windows API"></a>Windows API</h3><p>Microsoft 提供了大部分的<a href="https://docs.microsoft.com/en-us/windows/desktop/apiindex/api-index-portal" target="_blank" rel="noopener">Windows API</a>文档。API是通过Windows安装时的<a href="[https://zh.wikipedia.org/wiki/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93](https://zh.wikipedia.org/wiki/动态链接库">DLL(Dynamic Link Library)</a>)发布的。DLL是否可用取决于Windows的版本，但API文档中都会列出API什么时候启用，过时或废弃。</p><h3 id="加载DLL"><a href="#加载DLL" class="headerlink" title="加载DLL"></a>加载DLL</h3><p>要在Go中加载DLL，可以使用<code>syscall.NewLazyDLL</code>或<code>syscall.LoadLibrary</code> 。</p><ul><li><p><code>NewLazyDLL</code>返回一个<code>*LazyDLL</code>，懒加载，只在第一次调用其函数时才加载库;</p></li><li><p><code>LoadLibrary</code>是立即加载DLL库。</p></li></ul><p>其实在<code>golang.org/x/sys/windows</code>还支持<code>windows.NewLazySystemDLL</code>的方式加载。这是一种安全的加载方式，它能确保DLL搜索路径被绑定到了Windows系统目录。</p><h3 id="创建函数"><a href="#创建函数" class="headerlink" title="创建函数"></a>创建函数</h3><p>当我们加载（懒加载）了DLL库过，我们就要使用<code>dll.NewProc(&quot;ProcName&quot;)</code>去引用一些DLL中的函数(过程)。如：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span>（</span><br><span class="line">    kernel32DLL = syscall.NewLazyDLL（“kernel32.dll”）</span><br><span class="line">    procOpenProcess = kernel32DLL.NewProc（“OpenProcess”）</span><br><span class="line">）</span><br></pre></td></tr></table></figure><p>一旦有个这些引用，我们就可以<code>Call</code>这个函数本身的方法，或者使用<code>syscall.Syscall</code>函数及其变体进行API调用。使用的过程中发现<code>Call</code>方法更方便，但<code>syscall.Syscall</code>性能更优。根据函数参数的多数，我们可以使用</p><p><code>syscall.Syscall</code>的变体。</p><ul><li><code>syscall.Syscall</code> ：少于4个参数</li><li><code>syscall.Syscall6</code>：4到6个参数</li><li><code>syscall.Syscall9</code>：7到9个参数</li><li><code>syscall.Syscall12</code>：10到12个参数</li><li><code>syscall.Syscall15</code>：13到15个参数</li></ul><p>目前Go v1.12中，无法调用超过15个参数的函数。虽然我从来没有遇到过，但在<a href="https://github.com/golang/go/issues/28434" target="_blank" rel="noopener">于OpenGL中</a>确实有这种情况。</p><h3 id="API函数签名"><a href="#API函数签名" class="headerlink" title="API函数签名"></a>API函数签名</h3><p>在实际调用DLL函数之前，我们必须要了解一下过程所需要的参数，类型，大小。Microsoft将此描述为Windows API文档的一部分。如<code>CreateJobObjectA</code>的过程签名如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">HANDLE <span class="title">CreateJobObjectA</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  LPSECURITY_ATTRIBUTES lpJobAttributes,</span></span></span><br><span class="line"><span class="function"><span class="params">  LPCSTR                lpName</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><p>也就是说，<code>CreateJobObjectA</code>需要一个指向<code>LPSECURITY_ATTRIBUTES</code>结构的指针，和一个指向C-String的指针（ASCII编码，技术上是<a href="https://en.wikipedia.org/wiki/Windows-1252" target="_blank" rel="noopener">Windows-1252编码</a> ;它与ASCII兼容）。</p><h3 id="C结构与Go结构"><a href="#C结构与Go结构" class="headerlink" title="C结构与Go结构"></a>C结构与Go结构</h3><p>在文档中我们可以搜索到，<code>LPSECURITY_ATTRIBUTES</code>是这么定义的：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">SECURITY_ATTRIBUTES</span> &#123;</span></span><br><span class="line">  DWORD  nLength;</span><br><span class="line">  LPVOID lpSecurityDescriptor;</span><br><span class="line">  BOOL   bInheritHandle;</span><br><span class="line">&#125; SECURITY_ATTRIBUTES, *PSECURITY_ATTRIBUTES, *LPSECURITY_ATTRIBUTES;</span><br></pre></td></tr></table></figure><p>这时，我们就必须构造一个类似的Go结构来替代它。这时我们可以参考<code>syscall</code>中<a href="https://godoc.org/golang.org/x/sys/windows#SecurityAttributes" target="_blank" rel="noopener">SecurityAttributes</a>的定义。</p><p>在Windows API中，我们可以看到，<code>SecurityAttributes</code>是这么定义的：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">SECURITY_ATTRIBUTES</span> &#123;</span></span><br><span class="line">  DWORD  nLength;</span><br><span class="line">  LPVOID lpSecurityDescriptor;</span><br><span class="line">  BOOL   bInheritHandle;</span><br><span class="line">&#125; SECURITY_ATTRIBUTES, *PSECURITY_ATTRIBUTES, *LPSECURITY_ATTRIBUTES;</span><br></pre></td></tr></table></figure><p>而Go中<a href="https://godoc.org/golang.org/x/sys/windows#SecurityAttributes" target="_blank" rel="noopener">SecurityAttributes</a>的定义为：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> SecurityAttributes <span class="keyword">struct</span> &#123;</span><br><span class="line">    Length             <span class="keyword">uint32</span></span><br><span class="line">    SecurityDescriptor <span class="keyword">uintptr</span></span><br><span class="line">    InheritHandle      <span class="keyword">uint32</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由此我们大概知道， <code>DWORD</code>对应Go <code>uint32</code>， <code>LPVOID (* void)</code>对应<code>uintptr</code>，<code>BOOL</code>对应<code>uint32</code>。所以在你不知道用什么类型来表示C中对应的结构时，你可以去看看<code>syscall</code>或<code>go.sys</code>库中找找，或许能有收获。Windows一些参考类型<a href="https://docs.microsoft.com/en-us/windows/desktop/WinProg/windows-data-types" target="_blank" rel="noopener">这里</a>也有描述。</p><p>然而，了解下面这些常见C类型与Go类型的对应关系会非常有用。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> (</span><br><span class="line">	BOOL          <span class="keyword">uint32</span></span><br><span class="line">	BOOLEAN       <span class="keyword">byte</span></span><br><span class="line">	BYTE          <span class="keyword">byte</span></span><br><span class="line">	DWORD         <span class="keyword">uint32</span></span><br><span class="line">	DWORD64       <span class="keyword">uint64</span></span><br><span class="line">	HANDLE        <span class="keyword">uintptr</span></span><br><span class="line">	HLOCAL        <span class="keyword">uintptr</span></span><br><span class="line">	LARGE_INTEGER <span class="keyword">int64</span></span><br><span class="line">	LONG          <span class="keyword">int32</span></span><br><span class="line">	LPVOID        <span class="keyword">uintptr</span></span><br><span class="line">	SIZE_T        <span class="keyword">uintptr</span></span><br><span class="line">	UINT          <span class="keyword">uint32</span></span><br><span class="line">	ULONG_PTR     <span class="keyword">uintptr</span></span><br><span class="line">	ULONGLONG     <span class="keyword">uint64</span></span><br><span class="line">	WORD          <span class="keyword">uint16</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>在Windows中，一些函数使用的字符串有两种类型：一种是ANSI编码的，一种是UTF-16编码的。</p><p>如<code>CreateProcess</code>函数。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">var (</span><br><span class="line">    kernel32DLL = syscall.NewLazyDLL(<span class="string">"kernel32.dll"</span>)</span><br><span class="line">    procCreateProcessA = kernel32DLL.NewProc(<span class="string">"CreateProcessA"</span>)</span><br><span class="line">    procCreateProcessW = kernel32DLL.NewProc(<span class="string">"CreateProcessW"</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>不管是哪一种，我们都不能直接使用Go中的字符串。这就需要我们去做一些兼容。其实这很简单，只要我们在原始字符串后面加上一个零值即可。如下：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"unicode/utf16"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// StringToCharPtr converts a Go string into pointer to a null-terminated cstring.</span></span><br><span class="line"><span class="comment">// This assumes the go string is already ANSI encoded.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">StringToCharPtr</span><span class="params">(str <span class="keyword">string</span>)</span> *<span class="title">uint8</span></span> &#123;</span><br><span class="line">	chars := <span class="built_in">append</span>([]<span class="keyword">byte</span>(str), <span class="number">0</span>) <span class="comment">// null terminated</span></span><br><span class="line">	<span class="keyword">return</span> &amp;chars[<span class="number">0</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// StringToUTF16Ptr converts a Go string into a pointer to a null-terminated UTF-16 wide string.</span></span><br><span class="line"><span class="comment">// This assumes str is of a UTF-8 compatible encoding so that it can be re-encoded as UTF-16.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">StringToUTF16Ptr</span><span class="params">(str <span class="keyword">string</span>)</span> *<span class="title">uint16</span></span> &#123;</span><br><span class="line">	wchars := utf16.Encode([]<span class="keyword">rune</span>(str + <span class="string">"\x00"</span>))	</span><br><span class="line">	<span class="keyword">return</span> &amp;wchars[<span class="number">0</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>StringToUTF16Ptr</code>在标准库<code>syscall</code>中已经有了。</p><h3 id="调用API"><a href="#调用API" class="headerlink" title="调用API"></a>调用API</h3><p>把上面这些知识都用到，我们就可以开始调用一些API了。如我们调用<code>CreateJobObjectW</code>。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	kernel32DLL          = syscall.NewLazyDLL(<span class="string">"kernel32.dll"</span>)</span><br><span class="line">	procCreateJobObjectW = kernel32DLL.NewProc(<span class="string">"CreateJobObjectW"</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// CreateJobObject uses the CreateJobObjectW Windows API Call to create and return a Handle to a new JobObject</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CreateJobObject</span><span class="params">(attr *syscall.SecurityAttributes, name <span class="keyword">string</span>)</span> <span class="params">(syscall.Handle, error)</span></span> &#123;</span><br><span class="line">	r1, _, err := procCreateJobObjectW.Call(</span><br><span class="line">		<span class="keyword">uintptr</span>(unsafe.Pointer(attr)),</span><br><span class="line">		<span class="keyword">uintptr</span>(unsafe.Pointer(syscall.StringToUTF16Ptr(name))),</span><br><span class="line">	)</span><br><span class="line">	<span class="keyword">if</span> err != syscall.Errno(<span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> syscall.Handle(r1), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不管调用哪个API，<code>Call</code>的模式都是一样的。</p><p>而且<code>syscall.Syscall</code>函数始终返回<code>r1,r2 uintptr,err error</code>， 就最近的实践(windows_amd64)来看，基本可以确定:</p><ul><li><p>r1 始终返回 <code>syscall</code>的值；</p></li><li><p>r2 暂且使用；</p></li><li><p>err 返回调用Windows API<code>GetLastError</code>的结果，这是<code>syscall</code>自动调用的。</p></li></ul><p>而你传入<code>Call</code>中的值必须全部是<code>uintptr</code>，不管你原来的类型是什么。但，Go的指针很特别。</p><p>由于Go支持垃圾回收，标准的Go指针不是直接指向了物理内存中的一个地址。Go在运行时可以轻松的修改Go指针指向的物理内存地址，如增加堆栈时。当我们把一个Go指针通过<code>unsafe.Pointer</code>转换成<code>uintptr</code>时，对Go运行时来说，该指针变成了一个未被Go运行时追踪对一个数字而已。即使在下一个指令内，我们也无法确定这个数字指向的是否是它原来指向的那块有效的内存！</p><p>正因为如此，我们必须在Syscalls调用时，将指针指向确定的内存。使用<code>uintptr(unsafe.Pointer(&amp;x))</code>构造一个参数，告诉编译器，在Syscall期间不能修改x的内存空间。这样，C函数就能正常的去处理该指针了，直到Syscall返回为止。</p><p>在<a href="https://golang.org/pkg/unsafe/#Pointer" target="_blank" rel="noopener">godoc for unsafe.Pointer中</a>中写明了四种<code>unsafe.Pointers</code>的操作方式原则。这里用到</p><blockquote><p>(4) Conversion of a Pointer to a uintptr when calling syscall.Syscall.</p></blockquote><h3 id="获取原始数据"><a href="#获取原始数据" class="headerlink" title="获取原始数据"></a>获取原始数据</h3><p>有时，Syscall会自动为你填充C结构的内存块，如果你要使用就必须将其转化为可用的类型。</p><p>许多API的一般调用模式如下：</p><ol><li><p>通过空缓冲区调用一次API，指定一个获取缓冲区长度的变量，获取缓冲区的实际大小；</p></li><li><p>API返回<code>ERROR_INSUFFICIENT_LENGTH</code>错误，同时将长度值更新为实际需要的长度；</p></li><li><p>指定一个实际长度的扩展缓冲区，重新调用；</p></li><li><p>调用成功。</p></li></ol><p>如，我们需要调用<code>GetExtendedTcpTable</code>函数。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">IPHLPAPI_DLL_LINKAGE DWORD <span class="title">GetExtendedTcpTable</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  PVOID           pTcpTable,</span></span></span><br><span class="line"><span class="function"><span class="params">  PDWORD          pdwSize,</span></span></span><br><span class="line"><span class="function"><span class="params">  BOOL            bOrder,</span></span></span><br><span class="line"><span class="function"><span class="params">  ULONG           ulAf,</span></span></span><br><span class="line"><span class="function"><span class="params">  TCP_TABLE_CLASS TableClass,</span></span></span><br><span class="line"><span class="function"><span class="params">  ULONG           Reserved</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><p><code>GetExtendedTcpTable</code>返回的数据为<code>pTcpTable</code> 和 <code>pdwSize</code> ， 思路如下:</p><ol><li>我们第一次将<code>pTcpTable</code>直接指一个0值，使用<code>dwSize</code>来获取<code>pTcpTable</code>的实际长度；</li><li>这时，会返回错误<code>ERROR_INSUFFICIENT_BUFFER</code>, 同时<code>dwSize</code>的值被设置成了<code>pTcpTable</code>的实际大小；</li><li>指定一个<code>dwSize</code>大小的<code>[]byte</code>接收数据；</li><li>成功。</li></ol><p>部分代码如下：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">  iphlpapiDLL             = syscall.NewLazyDLL(<span class="string">"iphlpapi.dll"</span>)</span><br><span class="line">	procGetExtendedTcpTable = iphlpapiDLL.NewProc(<span class="string">"GetExtendedTcpTable"</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// GetExtendedTcpTable function retrieves a table that contains a list of TCP endpoints available to the application.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetExtendedTcpTable</span><span class="params">(order, ulAf, tableClass <span class="keyword">uint32</span>)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> dwSize <span class="keyword">uint32</span></span><br><span class="line">	ret, _, err := procGetExtendedTcpTable.Call(</span><br><span class="line">		<span class="number">0</span>,                                <span class="comment">// PVOID</span></span><br><span class="line">		<span class="keyword">uintptr</span>(unsafe.Pointer(&amp;dwSize)), <span class="comment">// PDWORD</span></span><br><span class="line">		<span class="keyword">uintptr</span>(order),                   <span class="comment">// BOOL</span></span><br><span class="line">		<span class="keyword">uintptr</span>(ulAf),                    <span class="comment">// ULONG</span></span><br><span class="line">		<span class="keyword">uintptr</span>(tableClass),              <span class="comment">// TCP_TABLE_CLASS</span></span><br><span class="line">		<span class="number">0</span>,                                <span class="comment">// ULONG</span></span><br><span class="line">	)</span><br><span class="line">	<span class="keyword">if</span> ret == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, errors.Wrapf(err, <span class="string">"get extended tcp table size failed code %x"</span>, ret)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> syscall.Errno(ret) == syscall.ERROR_INSUFFICIENT_BUFFER &#123;</span><br><span class="line">		buffer := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="keyword">int</span>(dwSize))</span><br><span class="line"></span><br><span class="line">		ret, _, err := procGetExtendedTcpTable.Call(</span><br><span class="line">			<span class="keyword">uintptr</span>(unsafe.Pointer(&amp;buffer[<span class="number">0</span>])),</span><br><span class="line">			<span class="keyword">uintptr</span>(unsafe.Pointer(&amp;dwSize)),</span><br><span class="line">			<span class="keyword">uintptr</span>(order),</span><br><span class="line">			<span class="keyword">uintptr</span>(ulAf),</span><br><span class="line">			<span class="keyword">uintptr</span>(tableClass),</span><br><span class="line">			<span class="keyword">uintptr</span>(<span class="keyword">uint32</span>(<span class="number">0</span>)),</span><br><span class="line">		)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> ret != <span class="number">0</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, errors.Wrapf(err, <span class="string">"get extended tcp table failed code %x"</span>, ret)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> buffer, <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span>, errors.Wrapf(err, <span class="string">"get extended tcp table size failed code %x"</span>, ret)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你看过<a href="https://docs.microsoft.com/en-us/windows/desktop/api/iphlpapi/nf-iphlpapi-getextendedtcptable" target="_blank" rel="noopener">上面函数的API</a>，你应该会知道输入参数<code>ulAf</code>和<code>TableClass</code>的值 决定了输出的buffer具体的内容。</p><p>如果我们输入的是<code>AF_INET + TCP_TABLE_OWNER_PID_ALL</code> 那么我们得到的数据的实际结构应该是<a href="https://docs.microsoft.com/en-us/windows/desktop/api/tcpmib/ns-tcpmib-_mib_tcptable_owner_pid" target="_blank" rel="noopener"><code>MIB_TCPTABLE_OWNER_PID</code></a>，其结构如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">MIB_TCPTABLE_OWNER_PID</span> &#123;</span></span><br><span class="line">  DWORD                dwNumEntries;</span><br><span class="line">  MIB_TCPROW_OWNER_PID table[ANY_SIZE];</span><br><span class="line">&#125; MIB_TCPTABLE_OWNER_PID, *PMIB_TCPTABLE_OWNER_PID;</span><br></pre></td></tr></table></figure><p>这里第一个参数<code>dwNumEntries</code>指明有<code>MIB_TCPROW_OWNER_PID</code> table的数量。</p><p>而第二个参数则是一个变长的数组。。。 那么我们该怎么用Go去表示呢？</p><h3 id="处理变长数据"><a href="#处理变长数据" class="headerlink" title="处理变长数据"></a>处理变长数据</h3><p>其实我们可以利用数组来创建一个兼容该结构的Go结构，这要得益于Go中数组的内存布局为连续的内存区域。</p><p>我们定义的对应结构如下：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> MIB_TCPTABLE_OWNER_PID <span class="keyword">struct</span> &#123;</span><br><span class="line">	dwNumEntries <span class="keyword">uint32</span></span><br><span class="line">	table        [<span class="number">1</span>]MIB_TCPROW_OWNER_PID</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MIB_TCPROW_OWNER_PID <span class="keyword">struct</span> &#123;</span><br><span class="line">	dwState      <span class="keyword">uint32</span></span><br><span class="line">	dwLocalAddr  [<span class="number">4</span>]<span class="keyword">byte</span></span><br><span class="line">	dwLocalPort  <span class="keyword">uint32</span></span><br><span class="line">	dwRemoteAddr [<span class="number">4</span>]<span class="keyword">byte</span></span><br><span class="line">	dwRemotePort <span class="keyword">uint32</span></span><br><span class="line">	dwOwningPid  <span class="keyword">uint32</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你会说，怎么<code>table</code>的长度只为1，这里先存个疑问。</p><p>现在我们首先要知道<code>dwNumEntries</code>的大小，我们才能确定table的数量。于是利用<code>unsafe.Pointer</code>将buffer内的数据转换为Go结构。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">pTable := (*MIB_TCPTABLE_OWNER_PID)(unsafe.Pointer(&amp;buffer[<span class="number">0</span>]))</span><br></pre></td></tr></table></figure><p>这里，我们将一个指针指向缓冲区的第一个字节的内存地址，然后利用<code>unsafe.Pointer</code>我们可以将该指针转换为任意类型的指针。其实这个操作是非常危险的，如果你不知道为什么要转换的话。这里我们能转化是因为我们遵循<code>unsafe.Pointer</code><a href="https://golang.org/pkg/unsafe/" target="_blank" rel="noopener">文档中的第一条</a>：</p><blockquote><p>(1) Conversion of a <em>T1 to Pointer to </em>T2.</p><p>Provided that T2 is no larger than T1 and that the two share an equivalent memory layout, this conversion allows reinterpreting data of one type as data of another type.</p></blockquote><p>也就是说，要把*T1转换为*T2，那么T2的长度必须比T1的长，而且T1,T2的内存布局必须相同。</p><p>那么，刚刚我们把table 的类型指定为<code>[1]MIB_TCPROW_OWNER_PID</code>, 长度为1显然不是正确的大小。但这没关系，因为<code>[1]MIB_TCPROW_OWNER_PID</code>的长度肯定是小于实际<code>[1+N]MIB_TCPROW_OWNER_PID</code>的长度的。而且他们的内存布局是一样的。</p><p>由于此时，我们已经知道了<code>dwNumEntries</code>的大小，我们可以使用<code>unsafe.Pointer</code>的另一规则来遍历获取数组。</p><blockquote><p>(3) Conversion of a Pointer to a uintptr and back, with arithmetic.</p></blockquote><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">rows := <span class="built_in">make</span>([]MIB_TCPROW_OWNER_PID, <span class="keyword">int</span>(pTable.dwNumEntries))</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="keyword">int</span>(pTable.dwNumEntries); i++ &#123;</span><br><span class="line">	rows[i] = *(*MIB_TCPROW_OWNER_PID)(unsafe.Pointer(</span><br><span class="line">		<span class="keyword">uintptr</span>(unsafe.Pointer(&amp;pTable.table[<span class="number">0</span>])) +</span><br><span class="line">			<span class="keyword">uintptr</span>(i)*unsafe.Sizeof(pTable.table[<span class="number">0</span>])))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里，我们利用<code>规则 (3)</code>迭代已知长度的数组，因为我们知道第一个元素的位置，每个元素的大小，元素的个数，以及结构在内存中的布局是连续的。</p><p>这里还有一个更简单的方法，能让我们直接获取table的数据:</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">rows2 := ((*[<span class="number">1</span> &lt;&lt; <span class="number">30</span>]MIB_TCPROW_OWNER_PID)(unsafe.Pointer(&amp;pTable.table[<span class="number">0</span>]))[:<span class="keyword">int</span>(pTable.dwNumEntries):<span class="keyword">int</span>(pTable.dwNumEntries)])</span><br></pre></td></tr></table></figure><p>这种做法一开始就将这个指针转换成一个非常大的数组指针，然后使用正确的长度取获取实际的内容。好处是不用创建其他切片，复制数据；缺点就是我们需要分配一个足够大的内存去接收，这个大小各平台会有一些差异。</p><p>你可以在这里体验一下<a href="https://play.golang.org/p/1XN1bLer-se" target="_blank" rel="noopener">Go Playground</a>。</p><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>现在你应该知道了调用Windows API的一些基本步骤与方法，如果遇到问题可以留言，我们一起解决～</p><ul><li>原文<a href="https://medium.com/jettech/breaking-all-the-rules-using-go-to-call-windows-api-2cbfd8c79724" target="_blank" rel="noopener">Breaking all the rules: Using Go to call Windows API</a> 有所改动。</li></ul>]]></content>
      <categories>
        <category>Go学习笔记</category>
      </categories>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>美食篇 | DIY戚风蛋糕（烤箱做蛋糕）</title>
    <url>//post/cate-diy-cake.html</url>
    <content><![CDATA[<p>很多人认为程序员是一群死宅，技术狂的群体。其实这种看法是很不全面的。今天就给你展示一下，一个程序员做蛋糕的点滴~</p><a id="more"></a><p>我们先看一眼最后的成果~</p><p><img data-src="https://st.razeen.cn/img/diy/cate/cake/IMG_5206.JPG" alt></p><p>嗯嘛~ Sorry,弄错了，下面这个才是~</p><p><img data-src="https://st.razeen.cn/img/diy/cate/cake/IMG_5197.JPG" alt></p><p>总之，很好吃。废话不多说，看过程。</p><h3 id="准备工具"><a href="#准备工具" class="headerlink" title="准备工具"></a>准备工具</h3><p>如图所示，我们需要准备：</p><ul><li>盆两个(大一点的用来打蛋白，小点的打蛋黄以及后面搅拌蛋黄糊）</li><li>分蛋器(分离蛋白蛋黄，没有可以用个空矿泉水瓶直接吸蛋黄~)</li><li>面粉筛(筛除面粉里的颗粒)</li><li>电子称</li><li>量杯</li><li>活底蛋糕磨具（我买的是8寸的）</li><li>电动打蛋器以及手动打蛋器</li><li>橡皮刮刀（拌面糊的时候用）</li></ul><p><img data-src="https://st.razeen.cn/img/diy/cate/cake/IMG_5071.JPG" alt></p><h3 id="准备用料"><a href="#准备用料" class="headerlink" title="准备用料"></a>准备用料</h3><table><thead><tr><th>食材</th><th>用量</th></tr></thead><tbody><tr><td>鸡蛋</td><td>5个</td></tr><tr><td>低筋面粉</td><td>90克</td></tr><tr><td>细砂糖</td><td>80克</td></tr><tr><td>纯牛奶</td><td>50ml</td></tr><tr><td>色拉油</td><td>50ml</td></tr></tbody></table><h3 id="第一步，蛋清蛋黄分离"><a href="#第一步，蛋清蛋黄分离" class="headerlink" title="第一步，蛋清蛋黄分离"></a>第一步，蛋清蛋黄分离</h3><p>第一步，把鸡蛋蛋清蛋黄分离了，分别在两个盆中。如下图，是不是很漂亮~</p><p><strong>蛋清分离</strong></p><p><img data-src="https://st.razeen.cn/img/diy/cate/cake/IMG_5121.JPG" alt></p><p><strong>蛋清</strong></p><p><img data-src="https://st.razeen.cn/img/diy/cate/cake/IMG_5131.JPG" alt></p><p><em>注意：</em> 装蛋清的盘子要是无水无油的，不要混入蛋黄，不然打不发。</p><p><strong>蛋黄</strong></p><p><img data-src="https://st.razeen.cn/img/diy/cate/cake/IMG_5129.JPG" alt></p><h3 id="第二部，制作蛋白霜"><a href="#第二部，制作蛋白霜" class="headerlink" title="第二部，制作蛋白霜"></a>第二部，制作蛋白霜</h3><p>1.利用电动打蛋器将蛋清打至粗泡状态。</p><p><img data-src="https://st.razeen.cn/img/diy/cate/cake/IMG_5138.JPG" alt></p><p>2.蛋白里加入1/3的细砂糖（共50克砂糖），转中高速打至细腻的泡沫，再加入1/3的细砂糖，转高速继续打至可呈现纹路的状态。</p><p><strong>50g细砂糖</strong></p><p><img data-src="https://st.razeen.cn/img/diy/cate/cake/IMG_5133.JPG" alt></p><p><strong>有纹路的蛋清</strong></p><p><img data-src="https://st.razeen.cn/img/diy/cate/cake/IMG_5143.JPG" alt></p><p>3.最后把剩下的糖都加入，继续打至干性发泡的状态，即是当提起打蛋器的时候，蛋白能拉出一个短小直立的尖角。</p><p><strong>尖角</strong></p><p><img data-src="https://st.razeen.cn/img/diy/cate/cake/IMG_5157.JPG" alt></p><p><em>注意：</em>蛋白必须打发到干性状态（打发蛋白的时候加入一两滴白醋或者柠檬汁，可以帮助蛋白更容易打发而且更稳定）</p><h3 id="第三步，制作蛋黄糊"><a href="#第三步，制作蛋黄糊" class="headerlink" title="第三步，制作蛋黄糊"></a>第三步，制作蛋黄糊</h3><p>1.在装蛋黄的盆里放30克细砂糖，用手动打蛋器打匀至蛋黄颜色变浅。</p><p><strong>倒糖过程</strong></p><p><img data-src="https://st.razeen.cn/img/diy/cate/cake/IMG_5152.JPG" alt></p><p><strong>蛋黄颜色变浅</strong></p><p><img data-src="https://st.razeen.cn/img/diy/cate/cake/IMG_5162.JPG" alt></p><p>2.再边搅拌边加入50ml色拉油（可用玉米油代替），再边搅拌边加入50ml牛奶</p><p><strong>牛奶，色拉油</strong></p><p><img data-src="https://st.razeen.cn/img/diy/cate/cake/IMG_5160.JPG" alt></p><p>3.最后筛入90克低筋面粉，慢慢地搅匀至光滑细腻无颗粒</p><p><strong>92.5g面粉</strong></p><p><img data-src="https://st.razeen.cn/img/diy/cate/cake/IMG_5163.JPG" alt></p><p><strong>刚刚筛入面粉过后</strong></p><p><img data-src="https://st.razeen.cn/img/diy/cate/cake/IMG_5165.JPG" alt></p><p><strong>搅拌至光滑细腻无颗粒</strong></p><p><img data-src="https://st.razeen.cn/img/diy/cate/cake/IMG_5168.JPG" alt></p><h3 id="第四步，混合"><a href="#第四步，混合" class="headerlink" title="第四步，混合"></a>第四步，混合</h3><p>1.取1/3蛋白霜入蛋黄糊盘中，用橡皮刮刀翻拌均匀；再取1/3的蛋白霜入蛋黄糊盘中，用橡皮刮刀翻拌均匀。</p><p><strong>蛋清与蛋黄的再次会面</strong></p><p><img data-src="https://st.razeen.cn/img/diy/cate/cake/IMG_5170.JPG" alt></p><p><em>注意：</em> 混合面糊的时候，应该用从下往上翻拌的手法混合面糊，不要大力搅拌，避免消泡。</p><p>2.最后把蛋黄糊盘中的面糊全部倒入剩下的蛋白霜盘中，完全翻拌均匀至光滑细腻无颗粒。</p><p><strong>他们已经不纯粹</strong></p><p><img data-src="https://st.razeen.cn/img/diy/cate/cake/IMG_5172.JPG" alt></p><p><em>注意：</em> 混合的时候不要一次性加入所有蛋白，这样不容易混合均匀，也容易让蛋白消泡。</p><h3 id="第五步，入模开烤"><a href="#第五步，入模开烤" class="headerlink" title="第五步，入模开烤"></a>第五步，入模开烤</h3><p>1.把面糊倒入8寸的圆形蛋糕模中，在桌面上轻轻嗑几下，把蛋糕糊里面的大气泡震出来。</p><p><img data-src="https://st.razeen.cn/img/diy/cate/cake/IMG_5174.JPG" alt></p><p>2.烤箱预热10分钟，把蛋糕放入预热好的烤箱的中层，上下火，170度，40分钟。</p><p><strong>初入火炉的蛋糕</strong></p><p><img data-src="https://st.razeen.cn/img/diy/cate/cake/IMG_5184.JPG" alt></p><p><em>注意：</em> 烤戚风蛋糕必须使用粘模，绝对不能使用不粘模或是在模具上涂抹油，因为这样蛋糕很难爬升，倒扣时也会整个掉出来缩在一起的。而且戚风的面糊含水量很大，因此需要低温长时间烘烤。</p><p><strong>开始发福的蛋糕</strong></p><p><img data-src="https://st.razeen.cn/img/diy/cate/cake/IMG_5186.JPG" alt></p><p><strong>正在努力爬升</strong></p><p><img data-src="https://st.razeen.cn/img/diy/cate/cake/IMG_5188.JPG" alt></p><p><strong>等待出炉</strong></p><p><img data-src="https://st.razeen.cn/img/diy/cate/cake/IMG_5189.JPG" alt></p><h3 id="大功告成"><a href="#大功告成" class="headerlink" title="大功告成"></a>大功告成</h3><p>蛋糕烤好了就立即带上隔热手套把它取出来，放在桌子上嗑几下，然后倒扣在烤架上，等蛋糕完全冷却后就可以脱模了（可借助道具脱模）</p><p><img data-src="https://st.razeen.cn/img/diy/cate/cake/IMG_5191.JPG" alt></p><p><em>注意：</em> 烤好的蛋糕要立即倒扣，并要完全晾凉才可以脱模，要不然会容易塌。</p><p><strong>最后成品图</strong></p><p><img data-src="https://st.razeen.cn/img/diy/cate/cake/IMG_5196.JPG" alt></p><h3 id="片尾"><a href="#片尾" class="headerlink" title="片尾"></a>片尾</h3><p>嗯嘛嘛~ 看着这一堆要洗的还是比较头疼的~</p><p><img data-src="https://st.razeen.cn/img/diy/cate/cake/IMG_5198.JPG" alt><br><img data-src="https://st.razeen.cn/img/diy/cate/cake/IMG_5199.JPG" alt><br><img data-src="https://st.razeen.cn/img/diy/cate/cake/IMG_5200.JPG" alt></p><p>​ ——2018年04月05日，晚。</p>]]></content>
      <categories>
        <category>美食</category>
      </categories>
      <tags>
        <tag>美食</tag>
        <tag>戚风蛋糕</tag>
      </tags>
  </entry>
  <entry>
    <title>修复远程登陆 Centos 时，出现 UTF-8 Warning</title>
    <url>//post/centos-utf-8-warning.html</url>
    <content><![CDATA[<p>远程登陆Centos时，出现”UTF-8” Warning</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">WARNING: setlocale: LC_CTYPE: cannot change locale (UTF-8): No such file or directory</span><br></pre></td></tr></table></figure><h3 id="修复"><a href="#修复" class="headerlink" title="修复"></a>修复</h3><p>修改 <code>/ect/environment</code> 文件，添加以下行：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> LANG=en_US.utf-8</span><br><span class="line">LC_ALL=en_US.utf-8</span><br></pre></td></tr></table></figure><p>下次SSH不再出现该错误。</p>]]></content>
      <categories>
        <category>Linux 点滴</category>
      </categories>
      <tags>
        <tag>centos</tag>
      </tags>
  </entry>
  <entry>
    <title>关于 Docker 清理</title>
    <url>//post/clean-your-docker.html</url>
    <content><![CDATA[<p>在Docker的日常使用中，我们或许偶尔遇到下面这些情况：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker-compose ps</span><br><span class="line">[27142] INTERNAL ERROR: cannot create temporary directory!</span><br><span class="line"></span><br><span class="line">$ df -h</span><br><span class="line">Filesystem      Size  Used Avail Use% Mounted on</span><br><span class="line">devtmpfs        489M  132K  488M   1% /dev</span><br><span class="line">tmpfs           497M     0  497M   0% /dev/shm</span><br><span class="line">/dev/xvda1      7.8G  7.7G     0 100% /</span><br></pre></td></tr></table></figure><a id="more"></a><p>这时候，我们大概明白了，大概是Docker把磁盘占满了。这时就需要我们去做一些清理了，这篇博客主要总结如下一些有效的Docker清理操作。</p><ul><li>找到dockers数据与进程；</li><li>删除未使用的镜像，容器，卷和网络；</li><li>重置docker</li><li>限制日志大小</li><li>其他相关操作</li></ul><blockquote><p>在了解这些之前，我相信你已经对下面的一些词汇已经有一定的了解。</p><ul><li>image: 一个只读模版，可以用来创建container。如，一个包含ubuntu系统的镜像。</li><li>container: 从镜像创建的运行实例。可以用docker命令去控制这些container。</li><li>volume: docker数据持久化。</li><li>dangling: 未使用的image。</li><li>network: 连接docker容器服务。</li></ul></blockquote><h3 id="查看Docker的磁盘使用情况"><a href="#查看Docker的磁盘使用情况" class="headerlink" title="查看Docker的磁盘使用情况"></a>查看Docker的磁盘使用情况</h3><p>使用<code>docker system df</code>即可查看：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker system df</span><br><span class="line">TYPE              TOTAL    ACTIVE      SIZE               RECLAIMABLE</span><br><span class="line">Images            13       7           6.4 GB              7.2 MB (88%)</span><br><span class="line">Containers        8        0           42.85 MB            42.85 MB (100%)</span><br><span class="line">Local Volumes     5        5           3.541 GB            0 B (0%)</span><br></pre></td></tr></table></figure><p>如上，镜像占了<code>6.4GB</code>, 容器占了<code>42.85 MB</code>, 数据卷占了<code>3.541 GB</code>。 了解基本占用后，我们就可以用下面介绍的命令进行针对性的清理了。</p><h3 id="找到Dockers数据与进程"><a href="#找到Dockers数据与进程" class="headerlink" title="找到Dockers数据与进程"></a>找到Dockers数据与进程</h3><p>要清理docker,就要知道docker数据在哪，具体有哪些docker进程。</p><ol><li><code>docker images</code> 列出docker镜像；</li><li><code>docker ps</code> 列出docker容器；</li><li><code>docker volume ls</code> 列出docker数据卷；</li><li><code>docker network ls</code> 列出docker网络；</li><li><code>docker info</code> 列出容器镜像的数量以及一些docker 安装等系统信息。</li></ol><h3 id="清除未使用的数据与进程"><a href="#清除未使用的数据与进程" class="headerlink" title="清除未使用的数据与进程"></a>清除未使用的数据与进程</h3><p>docker提供了一些快捷的命令去清除未使用的容器，网络和镜像：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker system prune</span><br><span class="line">WARNING! This will remove:</span><br><span class="line">        - all stopped containers</span><br><span class="line">        - all networks not used by at least one container</span><br><span class="line">        - all dangling images</span><br><span class="line">        - all dangling build cache</span><br><span class="line">Are you sure you want to <span class="built_in">continue</span>? [y/N]</span><br></pre></td></tr></table></figure><blockquote><p>默认是没有清除数据卷的功能，由于数据比较重要，防止意外删除一些数据。可以通过<code>--volumes</code>指定。</p></blockquote><p>同时，我们还可以将<code>—all</code>清除未使用的images。使用<code>--force</code>免确认。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker system prune --all --volumes</span><br><span class="line">WARNING! This will remove:</span><br><span class="line">        - all stopped containers</span><br><span class="line">        - all networks not used by at least one container</span><br><span class="line">        - all volumes not used by at least one container</span><br><span class="line">        - all images without at least one container associated to them</span><br><span class="line">        - all build cache</span><br><span class="line">Are you sure you want to <span class="built_in">continue</span>? [y/N]</span><br></pre></td></tr></table></figure><p>当然，我们也可以单独清除。</p><ul><li><code>docker container prune</code> 清除停止的容器；</li><li><code>docker volume prune</code> 清除未使用的数据卷；</li><li><code>docker image prune</code> 清除未使用的镜像；</li></ul><h3 id="清除所有数据重置docker"><a href="#清除所有数据重置docker" class="headerlink" title="清除所有数据重置docker"></a>清除所有数据重置docker</h3><p>上面的命令不会影响运行中的容器以及关联的镜像，数据卷和网络。如果你需要全部清理就需要将所有容器都停止下来。</p><p>使用<code>docker container stop [CONTAINERS...]</code>能停止正在运行的容器。同时我们可以通过下面命令获取正在运行的容器ID。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker container ls -aq</span><br></pre></td></tr></table></figure><ul><li><code>ls</code> 列出所有容器；</li><li><code>--all / -a</code>列出所有容器（包含未运行的）；</li><li><code>--quiet / -q</code> 只显示容器ID；</li></ul><p>于是我们可以使用下面命令停止所有容器：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker container stop $(docker container ls -a -q)</span><br></pre></td></tr></table></figure><p>结合清除的命令，完整的清除所有的容器命令如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker container stop $(docker container ls -a -q) &amp;&amp; docker system prune -a -f --volumes</span><br></pre></td></tr></table></figure><p>同理，我们可以想到：</p><ul><li>清除容器 <code>docker container rm $(docker container ls -a -q)</code> / <code>docker rm $(docker ps -a -q)</code>;</li><li>清除镜像 <code>docker image rm $(docker images ls -a -q)</code>;</li><li>清除数据卷 <code>docker volume rm $(docker volume ls -q)</code>;</li><li>清除网络 <code>docker network rm $(docker network ls -q)</code>;</li></ul><h3 id="限制容器日志大小"><a href="#限制容器日志大小" class="headerlink" title="限制容器日志大小"></a>限制容器日志大小</h3><p>很多时候，我们发现我们都是被日志文件撑爆的，解决问题的源头就是限制容器日志大小，方法有三：</p><ul><li><p>修改<code>daemon.json</code>配置；</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"log-opts"</span>: &#123;</span><br><span class="line">        <span class="attr">"max-size"</span> : <span class="string">"521m"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>修改<code>docker-compose</code>；</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">ubuntu:</span></span><br><span class="line">  <span class="attr">image:</span> <span class="string">ubuntu</span></span><br><span class="line">  <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">  <span class="attr">logging:</span></span><br><span class="line">    <span class="attr">driver:</span> <span class="string">"json-file"</span></span><br><span class="line">    <span class="attr">options:</span></span><br><span class="line">      <span class="attr">max-size:</span> <span class="string">"1g"</span></span><br></pre></td></tr></table></figure></li><li><p>通过参数；</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker run -d --<span class="built_in">log</span>-opt max-size=1g ubuntu</span><br></pre></td></tr></table></figure></li></ul><h3 id="其他常见的有关清理命令"><a href="#其他常见的有关清理命令" class="headerlink" title="其他常见的有关清理命令"></a>其他常见的有关清理命令</h3><ul><li><p>清除指定日志文件；</p><p>如果你要删除指定容器的日志，只有几步即可。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 获取指定的容器ID， 可通过docker ps 查看 如：2ed640d8fcd1 </span></span><br><span class="line"><span class="comment"># 获取该容器的日志地址</span></span><br><span class="line">$ docker inspect 2ed640d8fcd1  --format <span class="string">'&#123;&#123;.LogPath&#125;&#125;'</span></span><br><span class="line">/mnt/data/docker/containers/2ed640d8fcd1bd464a23be78513d23be1807c8ad6a95116da5cb9118a6b2380a/2ed640d8fcd1bd464a23be78513d23be1807c8ad6a95116da5cb9118a6b2380a-json.log</span><br></pre></td></tr></table></figure><p>知道了日志地址，你就可以删除或清空该日志了，不过注意权限哦～</p></li><li><p>杀死所有正在运行的容器；</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker <span class="built_in">kill</span> $(docker ps -a -q)</span><br></pre></td></tr></table></figure></li><li><p>删除所有已经停止的容器；</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker rm $(docker ps -a -q)</span><br></pre></td></tr></table></figure></li><li><p>删除未打标签的镜像；</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker rmi $(docker images -q -f dangling=<span class="literal">true</span>)</span><br></pre></td></tr></table></figure></li><li><p>批量删除指定镜像/容器等；</p><p>我们可以通过<code>--format</code>指出docker命令的输出形式，通过<code>grep</code>去筛选，然后删除。 如：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 删除带有指定 hub.docker.com 仓库的镜像</span></span><br><span class="line">$ docker rmi $(docker images --format <span class="string">'&#123;&#123;.Repository&#125;&#125;'</span> | grep <span class="string">'hub.docker.com'</span>)</span><br><span class="line"><span class="comment"># 杀掉带有ubuntu 镜像名字的容器</span></span><br><span class="line">$ docker <span class="built_in">kill</span> $(docker ps -a --format <span class="string">'&#123;&#123;.Images&#125;&#125;'</span> | grep <span class="string">'ubuntu'</span>)</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      <categories>
        <category>开发实战总结</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>规范 git commit message 与自动化版本控制</title>
    <url>//post/conventional-commits-and-standard-version.html</url>
    <content><![CDATA[<p>git commit message是你对你所编码内容的总结概括。规范、详细的git commit message不仅能体现你的内容概括能力，还能为你自己和团队，或项目带来巨大的好处，这也是我所推崇的。但很多小伙伴不愿意花时间在这里，经常会写出<code>优化了一些功能</code>、<code>修复了一些BUG</code>等等模糊不清的commit message，完全没有意识到这么写会带来一些严重的问题：</p><ul><li>管理者/其他项目参与者无法快速获取有用信息，判定修改内容，只有花大量时间阅读源码；</li><li>事后无法快速定位以前遇到的类似问题；</li><li>无法自动化版本控制，只有每次重新阅读代码，手动写一些详细的描述，用来发布新版或提交测试。</li></ul><p>规范、详细的git commit message不仅能解决这些问题，还能带来更多的好处。</p><a id="more"></a><ul><li><p>提供详细的历史信息，方便快速浏览，不用花大量时间阅读源码；</p></li><li><p>提供高效的团队合作，参与者能从提交信息中看到项目的进度；</p></li><li><p>可以快读定位问题，如果现在出现一个BUG，可以从BUG的类型，通过提交信息快读定位可能是哪次修改带来的；</p></li><li><p>可以直接从commit中总结周报，日报，项目报告；</p></li><li><p>可以直接从commit生成CHANGELOG;</p></li><li><p>影响团队其他成员，培养大家养成良好的习惯。</p></li></ul><p>下面我们推荐一个git commit message书写规范，以及如何通过commit message自动完成版本控制，生成CHANGELOG。</p><h3 id="规范"><a href="#规范" class="headerlink" title="规范"></a>规范</h3><p>我们严格遵循<a href="https://www.conventionalcommits.org/en/v1.0.0-beta.4/" target="_blank" rel="noopener"><code>Conventional Commits</code></a> 的约定，详细内容可以点击链接查看，下面我们简单总结一下。</p><p>commit messge格式如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;type&gt;[optional scope]: &lt;description&gt;</span><br><span class="line"></span><br><span class="line">[optional body]</span><br><span class="line"></span><br><span class="line">[optional footer]</span><br></pre></td></tr></table></figure><p>我们先举几个例子，再详细解析这个格式，如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">feat(xxx): 新增了xxx功能，实现了xxx </span><br><span class="line">BREAKING CHANGE: 我们需要切换到V2了</span><br><span class="line">fix(comment): 修复多用户评论时，顺序错乱问题</span><br><span class="line">feat(comment): 新增用户评论功能</span><br><span class="line">chore(comment): 新增了评论部分的swagger文档</span><br><span class="line">docs(readme): 创建README.md文件</span><br></pre></td></tr></table></figure><p>是不是不用我解释就懂了，对的就这么简单：</p><ul><li><code>&lt;type&gt;</code> : 是指本次提交的类型，一般有<code>feat</code>,<code>fix</code>,<code>chore</code>,<code>docs</code>,<code>style</code>,<code>refactor</code>,<code>perf</code>,<code>test</code>等，这里我推荐使用<code>feat</code>,<code>fix</code>,<code>chore</code>,<code>docs</code>四个，也就先说明这几个，更多的看<a href="https://github.com/angular/angular/blob/22b96b9/CONTRIBUTING.md#-commit-message-guidelines" target="_blank" rel="noopener">这里</a>。<ul><li><code>feat</code>: 说明本次提交的是一个新的feature;</li><li><code>fix</code>: 修复了一个bug;</li><li><code>chore</code>: 一些没有构成feature, 但又不是其他类型的提交；</li><li><code>docs</code>: 只是修改了文档相关的内容。</li></ul></li><li><code>[optional scope]</code>: 从单词的意思我们不难看出, 这里可以选填一个范围，也就是说，我们可以通过该关键词说明本次提交影响的范围（或许是一个模块，某一个功能，某一个业务等）。</li><li><code>&lt;description&gt;</code> : 这里就是我们需要详细的描述本次提交内容的部分了。</li><li><code>[optional body]</code> ,<code>[optional footer]</code> 如果还有需要补充或者详细展开的部分，我们可以在这两个部分说明。</li></ul><h3 id="自动化版本控制"><a href="#自动化版本控制" class="headerlink" title="自动化版本控制"></a>自动化版本控制</h3><p>有了规划化的提交后，我们就可以利用<a href="https://github.com/conventional-changelog/standard-version" target="_blank" rel="noopener"><code>standard-version</code></a>实现自动化版本控制与CHANGELOG自动生成了。</p><p>首先，我们全局安装一下<code>standard-version</code>。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install -g standard-version</span><br></pre></td></tr></table></figure><p>安装完成，可以查看一下版本，推荐一个团队最好使同一个大版本，避免一些奇怪的问题。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">standard-version --version</span><br></pre></td></tr></table></figure><p>当然，你也可以直接安装指定版本。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install -g standard-version@7.1.0</span><br></pre></td></tr></table></figure><p>有了规范的提交与<code>standard-version</code> 后，我们就可以愉快的进行版本控制和自动生成CHANGELOG了，只需要每次提交之后，在你的项目下面运行：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">standard-version</span><br></pre></td></tr></table></figure><p>即可。</p><p>我们很容易想到，<code>standard-version</code>可能会将git commit message, 自动整理生成CHANGELOG。 但版本升级怎么做到，规则是怎么样的呢？</p><p>这就取决于上面的git commit message中的<code>type</code>了。</p><ul><li>其中 <code>fix</code>对应于语义版本<code>patch</code>, 白话一点就是升级<code>0.0.1</code>个版本；</li><li><code>feat</code>对应于与<code>minor</code>，也就是升级<code>0.1.0</code>个版本；</li></ul><p>那么怎么实现从<code>1.0.0</code>到<code>2.0.0</code>呢，也就是改变<code>major</code>版本呢？</p><ul><li><p>其实只要在任何类型commit message后面的<code>[optional body]</code>或<code>[optional footer]</code>部分，以<strong>BREAKING CHANGE: </strong>开头，写一些版本升级的内容即可，如：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">feat(xxx): 新增了xxx功能，实现了xxx </span><br><span class="line">BREAKING CHANGE: xxxxxx</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>这里我们补充点<a href="https://semver.org/#summary" target="_blank" rel="noopener">语义版本控制</a>的内容。</p><p>通常我们看到的版本是这样的：<code>1.1.1</code> 、<code>1.0.0-beta.11</code> 或者 <code>1.0.0-rc</code> ，其实这种写法就是遵循语义化版本规范的，详细内容可以点上面链接查看，我们主要说明一下核心语法，即：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; &lt;version core&gt; ::= &lt;major&gt; &quot;.&quot; &lt;minor&gt; &quot;.&quot; &lt;patch&gt;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>也就是版本 <code>1.2.3</code>，主版本号为1，次要版本为2，补丁号为3.</p></blockquote><p>到这里你应该对规范化的git commit message有所了解，以及知道通过<code>standard-version</code>控制版本与自动生成CHANGELOG了。希望能对你有所帮助，养成良好的习惯，从而提高生产效率。</p>]]></content>
      <categories>
        <category>开发实战总结</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>standard-version</tag>
      </tags>
  </entry>
  <entry>
    <title>Go学习笔记(二) | 我对 recover 的一点误解</title>
    <url>//post/daily-go-recover.html</url>
    <content><![CDATA[<p>在golang的官方介绍中是这么介绍<strong>Recover</strong>函数的。</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Recover is a built-in function that regains control of a panicking goroutine. Recover is only useful inside deferred functions. During normal execution, a call to recover will return nil and have no other effect. If the current goroutine is panicking, a call to recover will capture the value given to panic and resume normal execution.</span><br></pre></td></tr></table></figure><p>也就是说当一个协程发生panic时，recover函数会捕捉到panic同时恢复正常的顺序。</p><p>像如下这样的代码：</p><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"log"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">2</span>; i &gt; <span class="number">0</span>; i-- &#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">			<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">				err := <span class="built_in">recover</span>()</span><br><span class="line">				<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">					log.Println(err)</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;()</span><br><span class="line">			<span class="keyword">for</span> val := <span class="keyword">range</span> ch &#123;</span><br><span class="line">				fmt.Println(<span class="string">"----&gt;"</span>, val, <span class="string">"Go"</span>, i)</span><br><span class="line">				<span class="keyword">if</span> val%<span class="number">2</span> == <span class="number">1</span> &amp;&amp; i == <span class="number">1</span> &#123;</span><br><span class="line">					<span class="built_in">panic</span>(<span class="string">"BOOM BOOM"</span>)</span><br><span class="line">				&#125;</span><br><span class="line">				time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;(i)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> i <span class="keyword">int</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		ch &lt;- i</span><br><span class="line">		time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">		fmt.Println(i, <span class="string">"&lt;---"</span>)</span><br><span class="line">		i++</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们向通道中写入，两个协成在接收，同时设计一个协程在一定的时候panic。那么在panic后，再recover，那在该协程的管道还能接收么？</p><p>过去，我一直以为，recover函数会重新恢复，该协程会类似重启一般==。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ go run recover.go</span><br><span class="line">----&gt; 0 Go 2</span><br><span class="line">0 &lt;---</span><br><span class="line">----&gt; 1 Go 1</span><br><span class="line">2018/01/21 21:52:54 BOOM BOOM</span><br><span class="line">1 &lt;---</span><br><span class="line">----&gt; 2 Go 2</span><br><span class="line">2 &lt;---</span><br><span class="line">3 &lt;---</span><br><span class="line">----&gt; 3 Go 2</span><br><span class="line">4 &lt;---</span><br><span class="line">----&gt; 4 Go 2</span><br><span class="line">5 &lt;---</span><br><span class="line">6 &lt;---</span><br><span class="line">----&gt; 5 Go 2</span><br><span class="line">7 &lt;---</span><br><span class="line">8 &lt;---</span><br><span class="line">----&gt; 6 Go 2</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>但从执行的结果看：</p><p>​ 只有一个协程在工作，另外一个还是挂了。这时，我才意识到，recover函数并没有恢复原有的协程。只是当该协程panic后会执行defer。而在defer中，recover函数将panic拦截下来了，不会向外面抛出，从而导致其他协程的执行并不受到影响。但，已经panic的协程还是挂了。</p>]]></content>
      <categories>
        <category>Go学习笔记</category>
        <category>Go基础</category>
      </categories>
      <tags>
        <tag>golang</tag>
        <tag>recover</tag>
      </tags>
  </entry>
  <entry>
    <title>云服务器搭建 hexo 博客，git hooks自动更新</title>
    <url>//post/daily-hexo-auto-refresh.html</url>
    <content><![CDATA[<p>因为自己喜欢瞎拍一些东西，希望弄个博客记录记录，原以为就在eiblog的基础上添加相册栏目，自定义一些东西，但自己的前端知识几乎为0，行动起来，需要点时间。看到hexo上有很多适合的主题，决定用hexo搭建一个，通过git hooks就可线下推送，线上自动拉取部署。</p><a id="more"></a><p>其原理是：通过本地渲染静态文件，将文件推送到GitHub仓库，在服务器上再通过git-hooks同步网站根目录。这样就完成了线下一次操作，线上自动更新的步骤。</p><p>废话不多说，看操作。</p><h3 id="配置云服务器"><a href="#配置云服务器" class="headerlink" title="配置云服务器"></a>配置云服务器</h3><p>在配置云服务器前，你得首先本地搭建好你的hexo博客，并可以通过<code>hexo d</code>部署到GitHub。</p><p>其步骤很多博客都有详细的描叙，不做累述。</p><h4 id="安装nginx"><a href="#安装nginx" class="headerlink" title="安装nginx"></a>安装nginx</h4><p>在<a href="https://imququ.com/search.html?s=nginx" target="_blank" rel="noopener">屈屈的博客</a>中很多关于Nginx的按照，配置，你可以看看。</p><p>在安装完成后你可以在配置中单独指定一个配置，或直接修改原配置指向你准备存放静态文件的文件夹。我用的前者。在nginx.conf文件添加指定配置文件路径，</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">include            /data/hexo/nginx/cong.d/*.conf;</span><br></pre></td></tr></table></figure><p>在<code>/data/hexo/nginx/cong.d/</code> 下添加配置文件<code>blog.conf</code></p><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>                       <span class="number">443</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">server_name</span>                  razeencheng.com;</span><br><span class="line">    <span class="attribute">server_tokens</span>                <span class="literal">off</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">access_log</span>                   /data/hexo/nginx/logdata/nginx.log;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># ip 黑名单</span></span><br><span class="line">    <span class="attribute">include</span>                      /data/hexo/nginx/ip.blacklist;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">ssl_ct</span>                       <span class="literal">on</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 中间证书 + 根证书</span></span><br><span class="line">    <span class="attribute">ssl_trusted_certificate</span>      /data/hexo/nginx/ssl/ca.pem;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">ssl_certificate</span>              /data/hexo/nginx/ssl/cert.pem;</span><br><span class="line">    <span class="attribute">ssl_certificate_key</span>          /data/hexo/nginx/ssl/cert.key;</span><br><span class="line">    <span class="attribute">ssl_ct_static_scts</span>           /data/hexo/nginx/ssl/scts/ecc/;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">ssl_dhparam</span>                  /data/hexo/nginx/ssl/dhparams.pem;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">ssl_ciphers</span>                  EECDH+CHACHA20:EECDH+CHACHA20-draft:EECDH+ECDSA+AES128:EECDH+aRSA+AES128:RSA+AES128:EECDH+ECDSA+AES256:EECDH+aRSA+AES256:RSA+AES256:EECDH+ECDSA+3DES:EECDH+aRSA+3DES:RSA+3DES:!MD5;</span><br><span class="line">    <span class="attribute">ssl_prefer_server_ciphers</span>    <span class="literal">on</span>;</span><br><span class="line">    <span class="attribute">ssl_protocols</span>                TLSv1 TLSv1.<span class="number">1</span> TLSv1.<span class="number">2</span>;</span><br><span class="line">    <span class="attribute">ssl_session_cache</span>            shared:SSL:<span class="number">50m</span>;</span><br><span class="line">    <span class="attribute">ssl_session_timeout</span>          <span class="number">1d</span>;</span><br><span class="line">    <span class="attribute">ssl_session_tickets</span>          <span class="literal">on</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># ssl stapling</span></span><br><span class="line">    <span class="attribute">ssl_stapling</span>                 <span class="literal">on</span>;</span><br><span class="line">    <span class="attribute">ssl_stapling_verify</span>          <span class="literal">on</span>;</span><br><span class="line">    <span class="attribute">resolver</span>                     <span class="number">114.114.114.114</span> <span class="number">8.8.8.8</span> valid=<span class="number">300s</span>;</span><br><span class="line">    <span class="attribute">resolver_timeout</span>             <span class="number">10s</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">if</span> (<span class="variable">$request_method</span> !<span class="regexp">~ ^(GET|HEAD|POST|OPTIONS)$</span> ) &#123;</span><br><span class="line">        <span class="attribute">return</span>                   <span class="number">444</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">location</span> / &#123;</span><br><span class="line">        <span class="attribute">root</span> /www/blog;</span><br><span class="line">        <span class="attribute">index</span> index.html;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从配置文件也可看出，我将网站的根目录放在<code>/data/hexo/nginx/html</code>文件夹。</p><h4 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装git</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">## root 用户</span></span><br><span class="line">yum install git -y</span><br><span class="line"></span><br><span class="line"><span class="comment">## 非root用户</span></span><br><span class="line">sudo yum install git -y</span><br></pre></td></tr></table></figure><h4 id="配置git-hook"><a href="#配置git-hook" class="headerlink" title="配置git hook"></a>配置<code>git hook</code></h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 博客public存放地址</span></span><br><span class="line">mkdir /www/blog </span><br><span class="line"><span class="comment"># 新建git仓库地址，初始化一个空仓库</span></span><br><span class="line">mkdir /hexo.git</span><br><span class="line"><span class="built_in">cd</span> /hexo.git</span><br><span class="line">git init --bare</span><br></pre></td></tr></table></figure><p>如果你是非<code>root</code>用户，需要加<code>sudo</code>,并改变文件夹权限。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo mkdir /www/blog </span><br><span class="line">sudo mkdir /hexo.git</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这里的ec2-user 是服务器的用户名，可以使用 whoami 命令查看</span></span><br><span class="line">sudo chown -R ec2-user /www</span><br><span class="line">sudo chown -R ec2-user /hexo.git</span><br></pre></td></tr></table></figure><p>配置<code>git hook</code>。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> hooks</span><br><span class="line">touch post-receive</span><br><span class="line">vi post-receive</span><br></pre></td></tr></table></figure><p>添加以下内容。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh </span></span><br><span class="line">WWW=/www/blog    	<span class="comment"># 表示实际文件被存放的位置</span></span><br><span class="line">GIT_REPO=/hexo.git  <span class="comment"># 表示仓库所在的位置</span></span><br><span class="line">git --work-tree=<span class="variable">$&#123;WWW&#125;</span> --git-dir=<span class="variable">$&#123;GIT_REPO&#125;</span> checkout -f</span><br></pre></td></tr></table></figure><p>这样将git仓库与文件隔离，互不影响。</p><p>最后赋予文件可执行权限。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chmod +x post-receive</span><br></pre></td></tr></table></figure><p>到这服务器就配置好了。</p><h3 id="本地配置"><a href="#本地配置" class="headerlink" title="本地配置"></a>本地配置</h3><p>修改<code>_config.yml</code>的<code>deploy</code>内容，例如：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repository:</span> <span class="string">user@your_site_ip:/hexo.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure><p>如果你的ssh设置了免密登陆（<a href="https://razeen.me/post/ssh-tips.html" target="_blank" rel="noopener">点这里看怎么设置免密登陆</a>）你就可以这么写：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: blog:/hexo.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><p>我的<code>.ssh/config</code>这么配置的。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Host blog</span><br><span class="line">    HostName 120.78.181.210</span><br><span class="line">    User root</span><br><span class="line">    IdentityFile ~/.ssh/blog.pem</span><br><span class="line">    #Port 22</span><br></pre></td></tr></table></figure><p>以后正常的<code>hexo d</code>既可以一键部署。</p><p>之后，可以看看<a href="https://razeen.me" target="_blank" rel="noopener">我的效果</a>~</p>]]></content>
      <categories>
        <category>博客折腾日记</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>git-hook</tag>
      </tags>
  </entry>
  <entry>
    <title>Go学习笔记(一) | postgres与golang点点滴滴</title>
    <url>//post/daily-pg-tips.html</url>
    <content><![CDATA[<p>在golang中使用数据库主要依赖<code>database/sql</code>库以及pg的驱动库。而目前我们常用的pg的驱动库是 <code>github.com/lib/pq</code>。这里我想说的不是如何去使用它们，毕竟人家文档已经很详细了，这里主要总结了一下自己日常使用中学到的一些技巧。</p><a id="more"></a><h3 id="相同标记重复使用"><a href="#相同标记重复使用" class="headerlink" title="相同标记重复使用"></a>相同标记重复使用</h3><p><code>database/sql</code>库没有规定查询字符串中参数标记的任何特定格式，pq使用了postgres - native序号，像下面例子一样，相同的标记可以被重复使用，用于相同的参数:</p><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// $2 使用了两次 都标记的值是64</span></span><br><span class="line">rows, err := db.Query(<span class="string">`SELECT name FROM users WHERE favorite_fruit = $1</span></span><br><span class="line"><span class="string">	OR age BETWEEN $2 AND $2 + 3`</span>, <span class="string">"orange"</span>, <span class="number">64</span>)</span><br></pre></td></tr></table></figure><h3 id="操作时返回ID"><a href="#操作时返回ID" class="headerlink" title="操作时返回ID"></a>操作时返回ID</h3><p>pq不支持<code>database/sql</code>的<code>LastInsertId()</code>方法，所以当你需要插入(更新or删除)数据后获取自增长的id值时，你可以利用pg的<code>RETURNING</code>语法：</p><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> userid <span class="keyword">int</span></span><br><span class="line">err := db.QueryRow(<span class="string">`INSERT INTO users(name, favorite_fruit, age)</span></span><br><span class="line"><span class="string">	VALUES('beatrice', 'starfruit', 93) RETURNING id`</span>).Scan(&amp;userid)</span><br></pre></td></tr></table></figure><h3 id="插入时存在更新"><a href="#插入时存在更新" class="headerlink" title="插入时存在更新"></a>插入时存在更新</h3><p>在数据看操作时，很多时候时候会存在唯一冲突，主键冲突等等，而我们又是需要在冲突时更新数据或者其他操作，这时我们可以这样：</p><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 其中name是唯一的，当name冲突时，更新其他字段</span></span><br><span class="line">err := db.Exec(<span class="string">`INSERT INTO users(name,favorite_fruit,age)</span></span><br><span class="line"><span class="string">    VALUES($1, $2, $3) </span></span><br><span class="line"><span class="string">    ON CONFLICT (name) DO UPDATE </span></span><br><span class="line"><span class="string">        SET favorite_fruit=$2,</span></span><br><span class="line"><span class="string">            age=$3`</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当然，有时候你有条件更新</span></span><br><span class="line">err := db.Exec(<span class="string">`INSERT INTO users(name,favorite_fruit,age)</span></span><br><span class="line"><span class="string">    VALUES($1, $2, $3) </span></span><br><span class="line"><span class="string">    ON CONFLICT (name) DO UPDATE </span></span><br><span class="line"><span class="string">        SET favorite_fruit=$2 </span></span><br><span class="line"><span class="string">        WHERE age &gt; $4`</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 你也可以什么都不做</span></span><br><span class="line">err := db.Exec(<span class="string">`INSERT INTO users(name,favorite_fruit,age)</span></span><br><span class="line"><span class="string">    VALUES($1, $2, $3) </span></span><br><span class="line"><span class="string">    ON CONFLICT (name) DO NOTHING`</span>)</span><br></pre></td></tr></table></figure><h3 id="只有单行数据简化代码"><a href="#只有单行数据简化代码" class="headerlink" title="只有单行数据简化代码"></a>只有单行数据简化代码</h3><p>这个其实上面就用到了，就是<code>queryRow</code>。当你确定只取一行数据的时候你可以使用该函数。但是需要注意的是：当你查询的数据为空的时候，他会返回<code>sql.ErrNoRaw</code>错误。</p><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> count <span class="keyword">int</span></span><br><span class="line">err := db.QueryRow(<span class="string">`SELECT count(*) FROM users`</span>).Scan(&amp;count)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> err == sql.ErrNoRaw &#123;</span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="结果集中空值处理"><a href="#结果集中空值处理" class="headerlink" title="结果集中空值处理"></a>结果集中空值处理</h3><p>在查询的时候，有时候难以保证字段一定有值，如果为空，在<code>scan</code>的时候就会报错，为了解决这种情况，我们可以使用下面这些来代替可能为空的字段。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--- 字符串       sql.NullString</span></span><br><span class="line"><span class="comment">--- bool        sql.NullBool</span></span><br><span class="line"><span class="comment">--- int         sql.NullInt64</span></span><br><span class="line"><span class="comment">--- float       sql.NullFloat64 </span></span><br><span class="line"><span class="comment">--- timestamp   pq.NullTime</span></span><br></pre></td></tr></table></figure><p>这里前面4个go驱动带的，后面是pq库带的。如果你还需要其他类型的，你可以自定义，只要实现<code>Scanner</code>接口就OK了。</p><h3 id="查询时需要嵌入数组"><a href="#查询时需要嵌入数组" class="headerlink" title="查询时需要嵌入数组"></a>查询时需要嵌入数组</h3><p>在使用pg语句的时候我们常用到<code>WHERE xxx IN (&#39;XXX&#39;,&#39;XXX&#39;...)</code>这样的<code>IN</code>数组操作，在go中也有对应的操作。</p><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 查找数组中对应id的所有人名</span></span><br><span class="line">ids := []<span class="keyword">int64</span>&#123;<span class="number">12</span>,<span class="number">16</span>,<span class="number">33</span>,<span class="number">55</span>&#125;</span><br><span class="line">rows,err := db.Query(<span class="string">`SELECT name FROM users WHERE id=ANY($1),pq.Int64Array(ids))</span></span><br><span class="line"><span class="string">...</span></span><br></pre></td></tr></table></figure><blockquote><p>当然其他类型对应的数组驱动也有</p><p>pq.BoolArray</p><p>pq.ByteaArray</p><p>pq.StringArray</p><p>pq.Float64Array</p></blockquote><h3 id="结果集中数组处理"><a href="#结果集中数组处理" class="headerlink" title="结果集中数组处理"></a>结果集中数组处理</h3><p>同上，用到上面pq中的数组</p><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ids := pq.Int64Array&#123;&#125;</span><br><span class="line">err := db.QueryRow(<span class="string">`SELECT array_agg(id) FROM users WHERE "age" &gt; $1`</span>,<span class="number">18</span>).Scan(&amp;ids)</span><br><span class="line">...</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Go学习笔记</category>
        <category>Go基础</category>
      </categories>
      <tags>
        <tag>golang</tag>
        <tag>postgres</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 goose 让数据库迁移更加轻松</title>
    <url>//post/db-tool-goose.html</url>
    <content><![CDATA[<p>在开发到发布的过程中，数据库的迁移是一件较为繁琐的事，而goose的出现，让数据库的迁移变得很轻松。</p><p>我们只需要简单的一句<code>goose up</code> 就能将数据库重新部署，一句<code>goose down</code> 就能将原有的数据库清除，是不是感觉很easy！</p><a id="more"></a><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">go get bitbucket.org/liamstask/goose/cmd/goose</span><br></pre></td></tr></table></figure><p>安装完成后可以运行<code>goose</code> 查看是否安装成功。</p><p>如果提示 <code>command not found: goose</code> 你可以查看一下你的<code>$GOPATH/bin</code> 下有没有goose的binary文件，如果有那么安装成功了，只是PATH中没把这个路径添加进去。</p><p>设置<code>~/.bash_profile</code> 将<code>GOPATH/bin</code> 加入PATH即可，类似如下。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> GOPATH=/Users/razeen/go   </span><br><span class="line"><span class="built_in">export</span> GOBIN=/Users/razeen/go/bin</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:<span class="variable">$GOBIN</span></span><br></pre></td></tr></table></figure><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>在安装完成后，你就可以在你的项目中配置goose了。</p><p>1.首先，在你的项目下需要一个<code>db</code>的文件夹，并且在文件夹的下面有一个数据库配置文件<code>dbconf.yml</code>(当然，该文件夹 也可以用<code>-path</code>来指定,只要该文件夹下有数据库配置文件<code>dbconf.yml即可</code>)。</p><p>2.配置<code>dbconf.yml</code>的内容。 一个简单的<code>dbconf.yml</code>文件的格式如下所示：</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">development:</span></span><br><span class="line">    <span class="attr">driver:</span> <span class="string">postgres</span></span><br><span class="line">    <span class="attr">open:</span> <span class="string">user=liam</span> <span class="string">dbname=tester</span> <span class="string">sslmode=disable</span></span><br></pre></td></tr></table></figure><p>这里的<code>driver</code>和<code>open</code>是直接通过go的<code>database/sql</code> 库去与数据库交互。<code>driver</code>即数据库驱动，常见的驱动(sqlite,mysql,postgres)<code>database/sql</code>都支持,其他驱动稍后也有介绍。<br><code>open</code>即数据库连接参数，常见的数据库操作实例如下：</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># sqlite 配置</span></span><br><span class="line"><span class="attr">driver :</span> <span class="string">sqlite</span></span><br><span class="line"><span class="attr">open :</span> <span class="string">./my_test_sqlite.sdb</span>  <span class="comment"># sqlite数据库路径</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># postgres 配置</span></span><br><span class="line"><span class="attr">driver :</span> <span class="string">postgres</span></span><br><span class="line"><span class="attr">open :</span> <span class="string">user=postgres</span> <span class="string">password=123456</span> <span class="string">dbname=test</span> <span class="string">sslmode=disable</span> </span><br><span class="line"></span><br><span class="line"><span class="comment"># mysql 配置</span></span><br><span class="line"><span class="attr">driver :</span> <span class="string">mysql</span></span><br><span class="line"><span class="attr">open :</span> <span class="string">user:password@tcp(localhost:3306)/dbname?charset=utf8</span></span><br></pre></td></tr></table></figure><p>而这里<code>development</code> 是你可用自己可以指定的一个环境名字。假如你在开发的时候和正式发布的时候数据库的环境并不相同，你就可以很轻松的用这个关键来分开部署。</p><p>实例如下，在开发过程中使用<code>development</code>标识，在生产环境中用<code>production</code>标识,两种情况的数据库环境不相同：</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">development:</span></span><br><span class="line">    <span class="attr">driver:</span> <span class="string">postgres</span></span><br><span class="line">    <span class="attr">open:</span> <span class="string">user=postgres</span>  <span class="string">dbname=test</span> <span class="string">sslmode=disable</span> </span><br><span class="line"><span class="attr">production:</span></span><br><span class="line">    <span class="attr">driver:</span> <span class="string">postgres</span></span><br><span class="line">    <span class="attr">open:</span>  <span class="string">user=myusername</span> <span class="string">password=112233</span> <span class="string">dbname=mytest</span> <span class="string">sslmode=disable</span></span><br></pre></td></tr></table></figure><p>上面例子很明显的看到，两个环境下的数据库连接是不同的。在具体的使用时我们就可以用<code>-env</code>来制定具体的环境。有关其使用，后面有介绍。</p><h4 id="其他驱动"><a href="#其他驱动" class="headerlink" title="其他驱动"></a>其他驱动</h4><p>除了常见的sqlite,mysql,postgres三个驱动外，goose还可以使用一些支持<code>database/sql</code>的驱动。这时就需要一个<code>import path</code> 和<code>known dialect</code>了，如下所示：</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">customdriver:</span></span><br><span class="line">    <span class="attr">driver:</span> <span class="string">custom</span></span><br><span class="line">    <span class="attr">open:</span> <span class="string">custom</span> <span class="string">open</span> <span class="string">string</span></span><br><span class="line">    <span class="attr">import:</span> <span class="string">github.com/custom/driver</span></span><br><span class="line">    <span class="attr">dialect:</span> <span class="string">mysql</span></span><br></pre></td></tr></table></figure><p><em>注</em> 因为在SQL中编写的迁移由goose二进制直接执行，所以只有编译到goose中的驱动程序才可以用于这些迁移。</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>在完成文件夹的创建以及数据库配置文件的参数设置后，就可已使用goose迁移你的数据库了。</p><h4 id="Create"><a href="#Create" class="headerlink" title="Create"></a>Create</h4><p>创建一个迁移语句，你可以选择使用<code>go</code>或者<code>sql</code>来创建。 例如，我需要创建一个基础的数据库脚本。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用golang迁移</span></span><br><span class="line">goose create basic_go </span><br><span class="line"><span class="comment"># 创建成功, 输出</span></span><br><span class="line">goose: created goose/db/migrations/20161130232822_basic_go.go</span><br><span class="line"><span class="comment"># 或者使用 sql脚本</span></span><br><span class="line">goose create basic_sql sql</span><br><span class="line"><span class="comment"># 创建成功, 输出</span></span><br><span class="line">goose: created goose/db/migrations/20161130232902_basic_sql.sql</span><br></pre></td></tr></table></figure><p><em>注</em> 执行goose 相关命令的目录与<code>db</code>目录应该同一层。</p><p>我们可以查看文件。创建的go脚本如下：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"database/sql"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Up is executed when this migration is applied</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Up_20161129103859</span><span class="params">(txn *sql.Tx)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Down is executed when this migration is rolled back</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Down_20161129103859</span><span class="params">(txn *sql.Tx)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建的sql脚本如下：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- +goose Up</span></span><br><span class="line"><span class="comment">-- SQL in section 'Up' is executed when this migration is applied</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- +goose Down</span></span><br><span class="line"><span class="comment">-- SQL section 'Down' is executed when this migration is rolled back</span></span><br></pre></td></tr></table></figure><p>数据库迁移语句就可以写在Up与Down有关区域内。</p><p>在其中写上需要的数据库迁移的操作。如下：</p><ul><li><p>File:goose/db/migrations/20161130232822_basic_go.go</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="string">package</span> <span class="string">main</span></span><br><span class="line"></span><br><span class="line"><span class="string">import</span> <span class="string">(</span></span><br><span class="line">	<span class="string">"database/sql"</span></span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line"><span class="string">)</span></span><br><span class="line"></span><br><span class="line"><span class="string">//</span> <span class="string">Up</span> <span class="string">is</span> <span class="string">executed</span> <span class="string">when</span> <span class="string">this</span> <span class="string">migration</span> <span class="string">is</span> <span class="string">applied</span></span><br><span class="line"><span class="string">func</span> <span class="string">Up_20161130232822(txn</span> <span class="string">*sql.Tx)</span> <span class="string">&#123;</span></span><br><span class="line">	<span class="string">fmt.Println("Up</span> <span class="string">Out</span> <span class="string">...")</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="string">//</span> <span class="string">Down</span> <span class="string">is</span> <span class="string">executed</span> <span class="string">when</span> <span class="string">this</span> <span class="string">migration</span> <span class="string">is</span> <span class="string">rolled</span> <span class="string">back</span></span><br><span class="line"><span class="string">func</span> <span class="string">Down_20161130232822(txn</span> <span class="string">*sql.Tx)</span> <span class="string">&#123;</span></span><br><span class="line">	<span class="string">fmt.Println("Down</span> <span class="string">Out</span> <span class="string">...")</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>File: goose/db/migrations/20161130232902_basic_sql.sql</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">-- +goose Up</span></span><br><span class="line"><span class="comment">-- SQL in section 'Up' is executed when this migration is applied</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> <span class="keyword">test</span> (</span><br><span class="line">	<span class="keyword">id</span> <span class="built_in">serial</span>,</span><br><span class="line">	con <span class="built_in">text</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- +goose Down</span></span><br><span class="line"><span class="comment">-- SQL section 'Down' is executed when this migration is rolled back</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">test</span>;</span><br></pre></td></tr></table></figure></li></ul><p><em>注</em> sql语句以分号结束，不然可能无法识别。</p><h4 id="Up"><a href="#Up" class="headerlink" title="Up"></a>Up</h4><p>执行<code>goose up</code>就是执行脚本Up区域的内容，所有可用的迁移脚本都将被执行。</p><p>在上面的例子中，执行<code>goose up</code>得到结果：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">goose: migrating db environment <span class="string">'development'</span>, current version: 0, target: 20161130232902</span><br><span class="line">Up Out ...</span><br><span class="line">OK    20161130232822_basic_go.go</span><br><span class="line">OK    20161130232902_basic_sql.sql</span><br></pre></td></tr></table></figure><p>到数据库查看，表格已经创建好了。当然，上面说的指定环境，此时就可以指定了，如果不指定默认就是<code>development</code>,在真正产的时候，我们可以如下使用：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">goose -env production up</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">goose: migrating db environment <span class="string">'production'</span>, current version: 0, target: 20161130232902</span><br><span class="line">Up Out ...</span><br><span class="line">OK    20161130232822_basic_go.go</span><br><span class="line">OK    20161130232902_basic_sql.sql</span><br></pre></td></tr></table></figure><p>在实际生产的时候，我们也可以指定执行某一个脚本，如下所示：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 再创建一个脚本</span></span><br><span class="line">goose create add_cloumn sql</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">goose: created /Users/trustasia/dev/go/src/demo_mi/goose/db/migrations/20161130235504_add_cloumn.sql</span><br><span class="line"></span><br><span class="line"><span class="comment"># 写上迁移语句</span></span><br><span class="line">-- +goose Up</span><br><span class="line">-- SQL <span class="keyword">in</span> section <span class="string">'Up'</span> is executed when this migration is applied</span><br><span class="line">ALTER TABLE <span class="built_in">test</span> ADD  new_con text;</span><br><span class="line"></span><br><span class="line">-- +goose Down</span><br><span class="line">-- SQL section <span class="string">'Down'</span> is executed when this migration is rolled back</span><br><span class="line">ALTER TABLE <span class="built_in">test</span> DROP COLUMN new_con;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定脚本迁移</span></span><br><span class="line">goose goose up add_cloumn</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">goose: migrating db environment <span class="string">'development'</span>, current version: 20161130232902, target: 20161130235504</span><br><span class="line">OK    20161130235504_add_cloumn.sql</span><br></pre></td></tr></table></figure><h4 id="Down"><a href="#Down" class="headerlink" title="Down"></a>Down</h4><p>执行<code>goose down</code> 向前回滚一个版本。</p><p>在上面的例子中，我们回滚。<br></p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">goose down</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">goose: migrating db environment <span class="string">'development'</span>, current version: 20161130235504, target: 20161130232902</span><br><span class="line">OK    20161130235504_add_cloumn.sql</span><br></pre></td></tr></table></figure><p></p><p>我们也可以指定环境，或指定脚本来回滚。<br></p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 指定生产环境回滚</span></span><br><span class="line">goose  -env production down</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">goose: migrating db environment <span class="string">'production'</span>, current version: 20161130232902, target: 20161130232822</span><br><span class="line">OK    20161130232902_basic_sql.sql</span><br><span class="line"></span><br><span class="line"><span class="comment"># 制定版本回滚</span></span><br><span class="line">goose down basic_sql  </span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">goose: migrating db environment <span class="string">'development'</span>, current version: 20161130232902, target: 20161130232822</span><br><span class="line">OK    20161130232902_basic_sql.sql</span><br></pre></td></tr></table></figure><p></p><h4 id="redo"><a href="#redo" class="headerlink" title="redo"></a>redo</h4><p>向上回滚一个版本，然后重新执行一次上次的操作。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">goose redo</span><br><span class="line"></span><br><span class="line">goose: migrating db environment <span class="string">'development'</span>, current version: 20161130232822, target: 0</span><br><span class="line">Down Out ...</span><br><span class="line">OK    20161130232822_basic_go.go</span><br><span class="line">goose: migrating db environment <span class="string">'development'</span>, current version: 0, target: 20161130232822</span><br><span class="line">Up Out ...</span><br><span class="line">OK    20161130232822_basic_go.go</span><br></pre></td></tr></table></figure><h4 id="status"><a href="#status" class="headerlink" title="status"></a>status</h4><p>查看当前所有的迁移执行状态。</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="string">goose</span> <span class="string">status</span></span><br><span class="line"><span class="attr">goose:</span> <span class="string">status</span> <span class="string">for</span> <span class="string">environment</span> <span class="string">'development'</span></span><br><span class="line">    <span class="string">Applied</span> <span class="string">At</span>                  <span class="string">Migration</span></span><br><span class="line">    <span class="string">=======================================</span></span><br><span class="line">    <span class="string">Thu</span> <span class="string">Dec</span>  <span class="number">1</span> <span class="number">09</span><span class="string">:25:17</span> <span class="number">2016</span> <span class="string">--</span> <span class="string">20161130232822_basic_go.go</span></span><br><span class="line">    <span class="string">Pending</span>                  <span class="string">--</span> <span class="string">20161130232902_basic_sql.sql</span></span><br><span class="line">    <span class="string">Pending</span>                  <span class="string">--</span> <span class="string">20161130235504_add_cloumn.sql</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看production环境下的</span></span><br><span class="line"><span class="string">goose</span> <span class="string">-env</span> <span class="string">production</span> <span class="string">status</span></span><br><span class="line"><span class="attr">goose:</span> <span class="string">status</span> <span class="string">for</span> <span class="string">environment</span> <span class="string">'production'</span></span><br><span class="line">    <span class="string">Applied</span> <span class="string">At</span>                  <span class="string">Migration</span></span><br><span class="line">    <span class="string">=======================================</span></span><br><span class="line">    <span class="string">Wed</span> <span class="string">Nov</span> <span class="number">30</span> <span class="number">23</span><span class="string">:51:00</span> <span class="number">2016</span> <span class="string">--</span> <span class="string">20161130232822_basic_go.go</span></span><br><span class="line">    <span class="string">Pending</span>                  <span class="string">--</span> <span class="string">20161130232902_basic_sql.sql</span></span><br><span class="line">    <span class="string">Pending</span>                  <span class="string">--</span> <span class="string">20161130235504_add_cloumn.sql</span></span><br></pre></td></tr></table></figure><h4 id="dbversion"><a href="#dbversion" class="headerlink" title="dbversion"></a>dbversion</h4><p>查看当前数据库版本。</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="string">goose</span> <span class="string">dbversion</span></span><br><span class="line"><span class="attr">goose:</span> <span class="string">dbversion</span> <span class="number">20161130232822</span></span><br></pre></td></tr></table></figure><h3 id="总结与注意事项"><a href="#总结与注意事项" class="headerlink" title="总结与注意事项"></a>总结与注意事项</h3><ul><li><ol><li>up,down区域脚本对应<code>goose up</code>,<code>goose down</code>;</li></ol></li><li><ol start="2"><li>可用<code>-env</code>指定数据库环境，<code>-path</code>指定包含数据库信息的路径;</li></ol></li><li><ol start="3"><li>数据库语句以分号介绍，不可缺少;</li></ol></li><li><ol start="4"><li>复杂的函数语句写在<code>-- +goose StatementBegin</code>与<code>-- +goose StatementEnd</code>之间，例下面的如创建函数。</li></ol></li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- +goose Up</span></span><br><span class="line"><span class="comment">-- +goose StatementBegin</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> <span class="keyword">REPLACE</span> <span class="keyword">FUNCTION</span> histories_partition_creation( <span class="built_in">DATE</span>, <span class="built_in">DATE</span> )</span><br><span class="line"><span class="keyword">returns</span> <span class="built_in">void</span> <span class="keyword">AS</span> $$</span><br><span class="line"><span class="keyword">DECLARE</span></span><br><span class="line">  create_query <span class="built_in">text</span>;</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">  <span class="keyword">FOR</span> create_query <span class="keyword">IN</span> <span class="keyword">SELECT</span></span><br><span class="line">      <span class="string">'CREATE TABLE IF NOT EXISTS histories_'</span></span><br><span class="line">      || TO_CHAR( d, <span class="string">'YYYY_MM'</span> )</span><br><span class="line">      || <span class="string">' ( CHECK( created_at &gt;= timestamp '''</span></span><br><span class="line">      || TO_CHAR( d, <span class="string">'YYYY-MM-DD 00:00:00'</span> )</span><br><span class="line">      || <span class="string">''' AND created_at &lt; timestamp '''</span></span><br><span class="line">      || TO_CHAR( d + <span class="built_in">INTERVAL</span> <span class="string">'1 month'</span>, <span class="string">'YYYY-MM-DD 00:00:00'</span> )</span><br><span class="line">      || <span class="string">''' ) ) inherits ( histories );'</span></span><br><span class="line">    <span class="keyword">FROM</span> generate_series( $<span class="number">1</span>, $<span class="number">2</span>, <span class="string">'1 month'</span> ) <span class="keyword">AS</span> d</span><br><span class="line">  <span class="keyword">LOOP</span></span><br><span class="line">    <span class="keyword">EXECUTE</span> create_query;</span><br><span class="line">  <span class="keyword">END</span> <span class="keyword">LOOP</span>;  <span class="comment">-- LOOP END</span></span><br><span class="line"><span class="keyword">END</span>;         <span class="comment">-- FUNCTION END</span></span><br><span class="line">$$</span><br><span class="line">language plpgsql;</span><br><span class="line"><span class="comment">-- +goose StatementEnd</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>开发实战总结</category>
      </categories>
      <tags>
        <tag>goose</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>TLS 1.3 详解 (RFC 8446解读)</title>
    <url>//post/detail-of-tls13.html</url>
    <content><![CDATA[<p>10 Aug 2018 by <a href="https://blog.cloudflare.com/author/nick-sullivan/" target="_blank" rel="noopener">Nick Sullivan</a>.</p><p>在过去的五年中，IETF（Internet Engineering Task Force，定义互联网协议的标准机构）一直致力于标准化其最重要的安全协议之一，TLS协议的最新版本。TLS用于保护Web（远不止Web），提供加密并确保每个HTTPS网站和API的真实性。</p><a id="more"></a><p>就在2018年8月10号，TLS协议的最新版本，TLS 1.3（<a href="https://www.rfc-editor.org/rfc/pdfrfc/rfc8446.txt.pdf" target="_blank" rel="noopener">RFC 8446</a>）发布了。这是TLS协议的第一次重大改革，带来了重大的安全性和性能改进。本文深入探讨了TLS 1.3的重要变化及其对互联网安全未来的影响。</p><h3 id="TLS协议的进化"><a href="#TLS协议的进化" class="headerlink" title="TLS协议的进化"></a>TLS协议的进化</h3><p>Cloudflare提供安全性的一个主要方式是支持网站和API等Web服务启用HTTPS。使用HTTPS（“S”代表安全），浏览器和服务器之间的消息通过加密和已经过身份验证的通道传输。网站通过HTTPS替代HTTP访问，能让用户确信自己访问的内容是网站所提供的原本内容， 并且确信通信是安全的，不会被窃听。互联网发展到今天，在线隐私问题变得更加重要，而这也是如今一个很大的问题。</p><p>HTTPS的能保证安全主要依赖的是TLS协议。TLS协议源于九十年代中期，Netscape开发的SSL的协议。到20世纪90年代末，Netscape将SSL交给IETF，IETF将其重命名为TLS，并从此成为该协议的管理者。许多人仍将Web加密称为SSL，即使绝大多数服务已切换到且仅支持TLS。SSL这个术语仍然受到人们的欢迎，Cloudflare的<a href="https://blog.cloudflare.com/keyless-ssl-the-nitty-gritty-technical-details/" target="_blank" rel="noopener">Keyless SSL</a>和<a href="https://blog.cloudflare.com/introducing-universal-ssl/" target="_blank" rel="noopener">Universal SSL</a>等产品也仍然使用这重说法。</p><p><img data-src="https://st.razeen.cn/img/image/tls13/tls13-image5.png" alt></p><p>在IETF中，协议称为RFC。TLS 1.0是RFC 2246，TLS 1.1是RFC 4346，TLS 1.2是RFC 5246.今天，TLS 1.3发布为RFC 8446. RFC通常按顺序发布，保留46作为RFC编号的一部分是一个很好的传承。</p><h3 id="TLS-1-2已经成为过去"><a href="#TLS-1-2已经成为过去" class="headerlink" title="TLS 1.2已经成为过去"></a>TLS 1.2已经成为过去</h3><p><img data-src="https://st.razeen.cn/img/image/tls13/tls13-image11.jpg" alt></p><p>*<em><a href="https://memegenerator.net/Mc-Hammer-Pants" target="_blank" rel="noopener">与Ham</a>一样，<a href="https://memegenerator.net/Mc-Hammer-Pants" target="_blank" rel="noopener">MC Hammer</a>在90年代很受欢迎</em></p><p>在过去几年中，TLS已经出现了相当多的问题。首先，实现TLS的代码存在问题，包括<a href="https://blog.cloudflare.com/answering-the-critical-question-can-you-get-private-ssl-keys-using-heartbleed/" target="_blank" rel="noopener">Heartbleed</a>，<a href="https://www.imperialviolet.org/2014/09/26/pkcs1.html" target="_blank" rel="noopener">BERserk</a>，<a href="https://gotofail.com/" target="_blank" rel="noopener">goto fail</a> 等等。这些问题还不是协议的基础问题，其主要是由于缺乏测试。像<a href="https://github.com/RUB-NDS/TLS-Attacker" target="_blank" rel="noopener">TLS Attacker</a>和<a href="https://security.googleblog.com/2016/12/project-wycheproof.html" target="_blank" rel="noopener">Project Wycheproof</a>这样的工具有助于提高TLS实施的稳健性，但TLS面临的更具挑战性的问题与协议本身有关。</p><p>TLS由工程师使用数学家的工具设计。SSL时代的许多早期设计决策都是使用最原始的方法，当时人们对如何设计健壮的安全协议不完全理解。也就是说，这不是协议设计者（Paul Kocher，Phil Karlton，Alan Freier，Tim Dierks，Christopher Allen等人）的错，因为整个行业都还在在学习如何正确地做到这一点。在设计TLS时，关于安全认证协议设计的正式论文还需要几年才发布（如Hugo Krawczyk的标志性<a href="http://webee.technion.ac.il/~hugo/sigma-pdf.pdf" target="_blank" rel="noopener">SIGMA</a>论文）。TLS是90年代的加密方式：它当时意味着很好，看起来很酷，但是现代密码学已经发展的更加强壮了。</p><p>许多设计缺陷是使用<a href="https://en.wikipedia.org/wiki/Formal_verification" target="_blank" rel="noopener">形式验证(Formal Verification)</a>发现的。学者们试图证明TLS的某些安全属性，但却找到了反例，这些反例被转化为真正的漏洞。这些弱点包括纯理论漏洞（<a href="https://access.redhat.com/articles/2112261" target="_blank" rel="noopener">SLOTH</a>和<a href="https://eprint.iacr.org/2018/298.pdf" target="_blank" rel="noopener">CurveSwap</a>），高资源攻击者漏洞（<a href="https://weakdh.org/imperfect-forward-secrecy-ccs15.pdf" target="_blank" rel="noopener">WeakDH</a>，<a href="https://blog.cloudflare.com/logjam-the-latest-tls-vulnerability-explained/" target="_blank" rel="noopener">LogJam</a>，<a href="https://censys.io/blog/freak" target="_blank" rel="noopener">FREAK</a>，<a href="https://nakedsecurity.sophos.com/2016/08/25/anatomy-of-a-cryptographic-collision-the-sweet32-attack/" target="_blank" rel="noopener">SWEET32</a>），实用和危险漏洞（<a href="https://en.wikipedia.org/wiki/POODLE" target="_blank" rel="noopener">POODLE</a>，<a href="https://robotattack.org/" target="_blank" rel="noopener">ROBOT</a>）。</p><h3 id="TLS-1-2很慢"><a href="#TLS-1-2很慢" class="headerlink" title="TLS 1.2很慢"></a>TLS 1.2很慢</h3><p>互联网上，加密一直很重要。但从历史上看，只有登陆信息与信用卡信息被加密，使大多数其他数据暴露。在过去几年中，一直存在一个主要趋势，全面启用HTTPS。所有流量都经过HTTPS后，能使我们免受窃听者和<a href="https://blog.cloudflare.com/an-introduction-to-javascript-based-ddos/" target="_blank" rel="noopener">注入攻击</a>的影响，但连接的速度却相对较慢。</p><p>要使浏览器和Web服务器就密钥达成一致，他们需要交换加密数据。自TLS于1999年标准化以来，在TLS中握手过程中的数据交换基本保持不变。握手需要在发送加密数据之前在浏览器和服务器之间再进行两次往返（或者在会话恢复先前连接时进行一次往返）。与单独的HTTP相比，HTTPS的TLS握手的额外成本导致潜在的问题。这种额外的延迟会对以性能为中心的应用产生负面影响。</p><h3 id="定义TLS-1-3"><a href="#定义TLS-1-3" class="headerlink" title="定义TLS 1.3"></a>定义TLS 1.3</h3><p>IETF对TLS 1.2的过时设计和两次往返开销不满意，开始着手定义新版本的TLS。2013年8月，Eric Rescorla为新协议制定了一份功能愿望清单：<a href="https://www.ietf.org/proceedings/87/slides/slides-87-tls-5.pdf" target="_blank" rel="noopener">https</a>：<br><a href="https://www.ietf.org/proceedings/87/slides/slides-87-tls-5.pdf" target="_blank" rel="noopener">//www.ietf.org/proceedings/87/slides/slides-87-tls-5.pdf</a></p><p>经过<a href="https://www.ietf.org/mail-archive/web/tls/current/msg20938.html" target="_blank" rel="noopener">一番辩论后</a>，决定将这个新版本的TLS称为TLS 1.3。推动TLS 1.3设计的主要问题与五年前提出的主要问题大致相同：</p><ul><li>减少握手延迟</li><li>加密更多的握手消息</li><li>提高跨协议攻击的难度</li><li>删除旧功能</li></ul><p>该规范由志愿者通过开放的设计过程设计，经过四年的勤奋工作和激烈的讨论，TLS 1.3现在处于最终形式：RFC 8446。随着协议的推广使用，新协议将使互联网更快，更多安全。</p><p>在这篇博文中，我将重点介绍TLS 1.3与以前版本相比的两个主要优势：安全性和性能。</p><h3 id="一些修复"><a href="#一些修复" class="headerlink" title="一些修复"></a>一些修复</h3><p><img data-src="https://st.razeen.cn/img/image/tls13/tls13-image10.jpg" alt></p><p>在过去的二十年中，我们已经学到了很多关于如何编写一个安全加密协议的相关知识。从POODLE到Lucky13到SLOTH到LogJam等一系列巧妙命名攻击表明，即使是TLS 1.2也包含了早期加密设计的一些陈旧观点。TLS 1.3的设计目标之一是通过消除潜在危险的设计元素来纠正以前的错误。</p><h4 id="修复密钥交换"><a href="#修复密钥交换" class="headerlink" title="修复密钥交换"></a>修复密钥交换</h4><p>TLS是所谓的“混合”密码系统。这意味着它同时使用对称密钥加密（加密和解密密钥相同）和公钥加密（加密和解密密钥不同）。混合方案是现互联网上使用的主要加密形式，如<a href="https://en.wikipedia.org/wiki/Secure_Shell" target="_blank" rel="noopener">SSH</a>，<a href="https://en.wikipedia.org/wiki/IPsec" target="_blank" rel="noopener">IPsec</a>，<a href="https://en.wikipedia.org/wiki/Signal_Protocol" target="_blank" rel="noopener">Signal</a>，<a href="https://www.wireguard.com/" target="_blank" rel="noopener">WireGuard</a>等其他协议。在混合密码系统中，公钥密码技术用于在双方之间建立共享密钥，共享密钥用于创建加密交换数据的对称密钥。</p><p>实际上，公钥加密是缓慢而且代价较高的（每个操作需要几微秒到几毫秒），对称密钥加密快速且代价小（每个操作都是纳秒级别）。混合加密方案允许您通过仅执行一次公钥加密，以极少的开销发送大量加密数据。TLS 1.3中的大部分工作都是关于改进握手部分，其中公钥用于建立对称密钥。</p><h4 id="RSA密钥交换"><a href="#RSA密钥交换" class="headerlink" title="RSA密钥交换"></a>RSA密钥交换</h4><p>TLS中公钥是用来建立共享秘密的。使用公钥加密有两种主要方法。其中一种简单的方法是使用公钥加密：一方用另一方的公钥加密共享密钥并发送它。然后另一方使用其私钥解密共享秘密。最后他们生成相同的加密密钥。这种技术于1977年由Rivest，Shamir和Adelman发现，称为RSA密钥交换。在RSA密钥交换中，共享密钥由客户端生成，然后客户端利用服务器的公钥（从证书中提取）将共享密钥加密并将其发送到服务器。</p><p><img data-src="https://st.razeen.cn/img/image/tls13/tls13-image4.png" alt></p><p>TLS中提供的另一种密钥交换形式是基于另一种形式的公钥密码技术，由Diffie和Hellman于1976年发明，即所谓的Diffie-Hellman密钥交换。在Diffie-Hellman中，客户端和服务器都从创建DH参数对开始。然后，他们将其DH参数的公共部分发送给另一方。当双方都收到对方方的公共参数时，它们将它与自己的私钥组合在一起，最终计算出同一个值：前主密钥。然后，服务器使用数字签名来确保交换未被篡改。如果客户端和服务器都为每次密钥交换选择一个新的DH参数，则该密钥交换称为“Ephemeral”（DHE）。</p><p><img data-src="https://st.razeen.cn/img/image/tls13/tls13-image3.png" alt></p><p>两种模式都会使客户端和服务器具有共享密钥，但RSA模式有一个严重的缺点：它不是<a href="https://blog.cloudflare.com/staying-on-top-of-tls-attacks/" target="_blank" rel="noopener">前向保密的</a>。这意味着如果有人记录加密的对话，然后获得了服务器的RSA私钥，他们就可以解密对话。这甚至适用于记录对话，在之后的一段时间内获取私钥的情况。如果一个国家政府正在记录这些加密内容，然后使用<a href="https://en.wikipedia.org/wiki/Heartbleed" target="_blank" rel="noopener">Heartbleed</a>这样的漏洞来窃取用户私钥，这将是一个非常现实而且非常恐怖的事情。</p><p>RSA密钥交换在一段时间内一直存在问题，其原因不仅仅是因为它支持前向保密。而是因为想要正确的实现RSA密钥交换也是不容易的。1998年，Daniel Bleichenbacher在SSL中使用RSA加密时发现了一个漏洞并创建了所谓的“百万消息攻击”， 它允许攻击者通过发送数百万条消息或一些特定的消息给服务器，根据服务器响应的不同错误码计算加密密钥， 进而解密消息。多年来，这种攻击得到了改进，在某些情况下只需要数千次就可破解，这使得在笔记本电脑上都可以破解。最近发现，许多大型网站（包括facebook.com）在2017年也受到Bleichenbacher变种漏洞的影响，即<a href="https://robotattack.org/" target="_blank" rel="noopener">ROBOT攻击</a>。</p><p>为了降低非前向加密连接和Bleichenbacher漏洞所带来的风险，RSA加密已从TLS 1.3中删除，将Diffie-Hellman Ephemeral作为唯一的密钥交换机制。在下面的性能部分中我们将讨论删除RSA密钥交换带来的其他优势。</p><h4 id="以Diffie-Hellman命名的加密手段"><a href="#以Diffie-Hellman命名的加密手段" class="headerlink" title="以Diffie-Hellman命名的加密手段"></a>以Diffie-Hellman命名的加密手段</h4><p>在加密方面，提供太多选项反而会导致选择错误。在选择DH参数时，这个原理最为明显。在以前版本的TLS中，DH参数的选择取决于参与者。这导致在一些算法实现中参数选择不正确，导致最后部署易受攻击。于是TLS 1.3取消了这一选择。</p><p>DH是一个功能强大的工具，但并非所有DH参数都可以“安全”使用。DH的安全性取决于称为数学中<a href="https://en.wikipedia.org/wiki/Discrete_logarithm" target="_blank" rel="noopener">离散对数问题</a>的难度。如果可以解决一组参数的离散对数问题，就可以提取私钥并破坏协议的安全性。一般来说，使用的数字越大，解决离散对数问题就越困难。因此，如果您选择较小的DH参数，就有可能遭受攻击。</p><p>2015年的LogJam和WeakDH攻击表明，许多TLS服务器可能被欺骗使用较小的DH的参数，允许攻击者破坏协议并解密对话。</p><p>DH参数还需要具有某些其他数学属性。2016年，Antonio Sanso <a href="http://arstechnica.com/security/2016/01/high-severity-bug-in-openssl-allows-attackers-to-decrypt-https-traffic/" target="_blank" rel="noopener">在OpenSSL中发现了一个漏洞</a>，该漏洞正是由于选择的参数缺乏正确的数学属性导致的。</p><p>TLS 1.3采用固定路由，将DH参数限制为已知安全的参数。但仍然保留了个选择，如果只允许一个选择，一旦以后发现这些参数不安全的，更新TLS将变得很困难。</p><h3 id="修复密码"><a href="#修复密码" class="headerlink" title="修复密码"></a>修复密码</h3><p>混合加密方案的另外一部分是数据加密。数据加密主要通过一个对称算法以及双方协商出的会话密钥来完成的。下面我将告诉你，即时有很多算法可以完成数据的加密，但很多是不正确的。</p><h4 id="CBC模式密码"><a href="#CBC模式密码" class="headerlink" title="CBC模式密码"></a>CBC模式密码</h4><p>在上一节中，我们将TLS描述为混合加密方案，具有公钥和对称密钥两部分。公钥部分并不是多年来造成麻烦的唯一部分。对称加密部分也存在安全问题。在任何安全通信方案中，您都需要保证数据加密和数据的完整性（以确保人们不会修改，添加或删除对话内容）。对称密钥加密数据可用于提供数据的加密和数据的完整性，但在TLS 1.2及更早版本中，这两个部分以错误的方式组合，导致安全漏洞。</p><p>执行对称加密和解密的算法称为对称密码。对称密码通常有两种主要形式：分组密码和流密码。</p><p>流密码采用固定大小的密钥并使用它来创建任意长度的伪随机数据流，称为密钥流。要使用流密码进行加密，需要将密钥流的每个位与消息的相应位进行异或。要解密，需要使用密钥流对加密消息进行异或。纯流密码示例如RC4和ChaCha20。流密码很受欢迎，因为它们易于实现且计算速度快。</p><p>分组密码与流密码不同，因为它只加密固定大小的消息。如果要加密比块大小更短或更长的消息，则必须执行一些额外操作。对于较短的消息，必须在消息的末尾添加一些额外的数据。对于较长的消息，可以将消息拆分为密码可以加密的块，然后使用分组密码模式将各个部分以某种方式组合在一起。或者，可以通过使用块密码加密计数器序列将快密码装换成流密码。这称为“计数器模式”。使用分组密码加密任意长度数据的一种流行模式称为密码块链接（CBC）模式。</p><p><img data-src="https://st.razeen.cn/img/image/tls13/tls13-image9.png" alt></p><p><img data-src="https://st.razeen.cn/img/image/tls13/tls13-image7.png" alt></p><p>为了防止人们篡改数据，加密是不够的，还需要保护数据的完整性。对于CBC模式密码，这是使用消息验证代码（MAC）来完成的。密码强度高的MAC具有以下特性：除非你知道密钥，否则找到与输入匹配的MAC值几乎是不可能的。有两种方法可以组合MAC和CBC模式密码。先加密，然后MAC密文，或者首先MAC明文，然后加密整个文件。在TLS中，他们选择后者，MAC-then-Encrypt，结果证明是错误的选择。</p><p>你可以理解为这个选择导致了<a href="https://www.youtube.com/watch?v=-_8-2pDFvmg" target="_blank" rel="noopener">BEAST漏洞</a>，以及一系列填充oracle漏洞，例如<a href="http://www.isg.rhul.ac.uk/tls/Lucky13.html" target="_blank" rel="noopener">Lucky 13</a>和<a href="https://eprint.iacr.org/2015/1129" target="_blank" rel="noopener">Lucky Microseconds</a>。阅读我<a href="https://blog.cloudflare.com/padding-oracles-and-the-decline-of-cbc-mode-ciphersuites/" target="_blank" rel="noopener">之前关于这个主题的帖子</a>，这里有全面的解释。CBC模式与填充之间的相互影响也是导致SSLv3或一些TLS中广泛流传的<a href="https://blog.cloudflare.com/sslv3-support-disabled-by-default-due-to-vulnerability/" target="_blank" rel="noopener">POODLE漏洞</a>的原因。</p><p>RC4是Ron Rivest（RSA的“R”）设计的经典流密码，自TLS早期就获得广泛支持。在2013年，它被发现具有<a href="http://www.isg.rhul.ac.uk/tls/" target="_blank" rel="noopener">可衡量的偏差</a>，攻击者可以利用它来解密消息。</p><p><img data-src="https://st.razeen.cn/img/image/tls13/tls13-image2.png" alt="AEAD模式"></p><p><em>AEAD模式</em></p><p>在TLS 1.3中，已删除所有有威胁的密码和密码模式。您不能再使用CBC模式密码或不安全的流密码，如RC4。TLS 1.3中允许的唯一类型的对称加密是一种称为<a href="https://blog.cloudflare.com/it-takes-two-to-chacha-poly/" target="_blank" rel="noopener">AEAD（带有附加数据的经过身份验证的加密）</a>的新结构，它将数据加密以及数据的完整性无缝结合。</p><h3 id="修复数字签名"><a href="#修复数字签名" class="headerlink" title="修复数字签名"></a>修复数字签名</h3><p>TLS的另一个重要作用是身份验证。在每个连接中，服务器使用具有公钥的数字证书向客户端验证自身。在RSA加密模式中，服务器通过解密预主密钥以及会话中MAC值的验证来证明其对私钥的所有权。在DH模式中，服务器使用数字签名证明私钥的所有权。如果你到目前为止一直关注这篇博文，应该很容易猜到这是有问题的。</p><h4 id="PKCS＃1v1-5"><a href="#PKCS＃1v1-5" class="headerlink" title="PKCS＃1v1.5"></a>PKCS＃1v1.5</h4><p>Daniel Bleichenbacher致力于识别TLS中RSA的问题。2006年，他设计了针对TLS中使用的RSA签名的pen-and-paper攻击。后来发现包括NSS和OpenSSL在内的主要TLS实现<a href="https://www.ietf.org/mail-archive/web/openpgp/current/msg00999.html" target="_blank" rel="noopener">容易受到这种攻击</a>。这些漏洞也与是否正确实现填充有关。前面的这些情况中，RSA签名所用的都是PKCS#1 v1.5填充。在TLS 1.3中，删除了对PKCS#1 v1.5的支持，应用了更新的设计<a href="https://en.wikipedia.org/wiki/Probabilistic_signature_scheme" target="_blank" rel="noopener">RSA-PSS</a>。</p><h4 id="签名整个握手记录"><a href="#签名整个握手记录" class="headerlink" title="签名整个握手记录"></a>签名整个握手记录</h4><p>我们之前描述过服务器如何使用数字签名来证明密钥交换没有被篡改。在TLS 1.2及更早版本中，服务器的签名仅涵盖部分握手。握手的其他部分，特别是用于协商使用哪个对称密码的部分，不由私钥签名，而使用的是对称MAC来确保握手未被篡改。这种疏忽导致了许多备受瞩目的漏洞（FREAK，LogJam等）。在TLS 1.3中，阻止了这样的做法，因为服务器签名了整个握手记录。</p><p><img data-src="https://st.razeen.cn/img/image/tls13/tls13-image1.png" alt></p><p>FREAK，LogJam和CurveSwap漏洞利用了两件事：</p><ol><li>许多浏览器和服务器仍然支持20世纪90年代出现的弱密码（称为导出密码）；</li><li>用于协商使用哪种密码的握手部分未经数字签名。</li></ol><p>中间人攻击者可以通过让客户端选择服务器端支持的弱密码（或支持的组或支持的曲线）进行密钥交换。然后他们破解了该密钥，完成两条finish messages，让双方都认为他们已经同意通信。</p><p><img data-src="https://st.razeen.cn/img/image/tls13/tls13-image13.png" alt></p><p>这些攻击被称为降级攻击，它们允许攻击者强制两个参与者使用双方支持的最弱密码，即使支持更安全的密码也是如此。在这种攻击方式中，劫持者处于握手的中间，并将从客户端发送给的服务器支持的密码列表更改为仅包含弱导出密码。然后，服务器选择一个弱密码，攻击者通过暴力攻击计算出密钥，允许攻击者在握手时伪造MAC。在TLS 1.3中，这种类型的降级攻击是不可能的，因为服务器现在签名了整个握手，包括密码协商部分。</p><p><img data-src="https://st.razeen.cn/img/image/tls13/tls13-image14.png" alt></p><h3 id="通过简化改善生活"><a href="#通过简化改善生活" class="headerlink" title="通过简化改善生活"></a>通过简化改善生活</h3><p>随着除去了上面这些不安全的因素， TLS 1.3 是一个更加优雅和安全的协议。这种改变允许简化协议，使其更容易理解，更快。</p><h4 id="没有更多的外卖菜单"><a href="#没有更多的外卖菜单" class="headerlink" title="没有更多的外卖菜单"></a>没有更多的外卖菜单</h4><p>在以前版本的TLS中，主要的协商机制是密码组。密码套件几乎涵盖了可以就连接进行协商的所有内容：</p><ul><li>支持的证书类型</li><li>用于导出键的哈希函数（例如，SHA1，SHA256，…）</li><li>MAC功能（例如，HMAC与SHA1，SHA256，…）</li><li>密钥交换算法（例如，RSA，ECDHE，……）</li><li>密码（例如，AES，RC4，……）</li><li>密码模式，如果适用（例如，CBC）</li></ul><p>先前版本的TLS中的密码套已经发展成为巨大的字母组。常用密码套件的示例是：DHE-RC4-MD5或ECDHE-ECDSA-AES-GCM-SHA256。每个密码套件由一个名为Internet Assigned Numbers Authority（IANA）的组织维护的表中的代码点表示。每次引入新密码时，都需要将一组新的组合添加到列表中。这导致代码点的组合爆炸，代表这些参数的每个有效选择。它变得有点乱。</p><p><img data-src="https://st.razeen.cn/img/image/tls13/tls13-image8.png" alt></p><p><img data-src="https://st.razeen.cn/img/image/tls13/tls13-image16.png" alt></p><p>TLS 1.3删除了许多这些遗留功能，允许在三个正交协商之间进行彻底拆分：</p><ul><li>密码+ HKDF哈希</li><li>密钥交换</li><li>签名算法</li></ul><p><img data-src="https://st.razeen.cn/img/image/tls13/tls13-image6-.png" alt></p><p>这种简化的密码套件协商和从根本上减少的一系列协商参开辟了一种新的可能性。这种可能性使得TLS 1.3握手延迟从两次往返降至仅一次往返，从而提供性能提升，确保TLS 1.3受欢迎并广泛采用。</p><h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3><p>在TLS1.2中，初次建立连接时，需要两次往返才能开始发送数据。这与服务器和客户端在地理位置上彼此是否靠近没有特别明显关系，但是它在移动网络上却有很大的差异，其中延迟可以高达200ms，这对于人类来说是显而易见的。</p><h3 id="1-RTT模型"><a href="#1-RTT模型" class="headerlink" title="1-RTT模型"></a>1-RTT模型</h3><p>TLS 1.3现在具有更简单的密码协商模型和简化的密钥协商选项（没有RSA，没有用户定义的DH参数）。这意味着每个连接都将使用基于DH的密钥协议，并且服务器支持的参数很容易猜到（ECDHE使用X25519或P-256）正因为这种有限的选择，客户端可以很容易的选择在第一条消息中就发送DH密钥共享参数，而不是等到服务器确认它支持哪些密钥共享。这样，服务器可以获得共享密钥并减少一次往返，提前发送加密数据。例如，Chrome实现的TLS 1.3会在第一条消息中向服务器发送X25519密钥共享。</p><p><img data-src="https://st.razeen.cn/img/image/tls13/tls13-image3-.png" alt></p><p><img data-src="https://st.razeen.cn/img/image/tls13/tls13-image15.png" alt></p><p>在极少数情况下，服务器不支持客户端发送的密钥共享之一，服务器可以发送HelloRetryRequest消息，让客户端知道它支持哪些密钥共享算法。由于列表已被削减太多，预计这种情况不常发生。</p><h3 id="0-RTT恢复"><a href="#0-RTT恢复" class="headerlink" title="0-RTT恢复"></a>0-RTT恢复</h3><p>受[QUIC协议的启发，协议得到进一步的优化。它允许客户端将第一条消息中的数据加密后发送到服务器，而且与未加密的HTTP相比，不会产生额外的延迟成本。这是一个重大的改进，一旦TLS 1.3被广泛部署，加密的网络肯定比以前更加快捷。</p><p>在TLS 1.2中，有两种方法可以恢复连接，<a href="https://blog.cloudflare.com/tls-session-resumption-full-speed-and-secure/" target="_blank" rel="noopener">会话ID和会话票据</a>。在TLS 1.3中，将这些模式组合起来，形成了预共享密钥（PSK）恢复的新模式。该想法来源于，在建立会话之后，客户端和服务器可以导出称为“恢复主密钥”的共享秘密。该共享秘密可以使用id（会话ID样式）存储在服务器上，也可以通过服务器的密钥（会话票据样式）加密。此会话票据将发送到客户端并在恢复连接时发回。</p><p>对于恢复的连接，双方共享恢复主密钥，因此除了提供前向保密之外，不需要密钥交换。下次客户端连接到服务器时，它可以从上一个会话中获取密码并使用它来加密应用程序数据以及会话票证发送到服务器。</p><h3 id="可重复性"><a href="#可重复性" class="headerlink" title="可重复性"></a>可重复性</h3><p>0-RTT中没有数据交互。它由客户端发送，并由服务器使用，没有任何交互。这对性能很有帮助，但为此也需要付出代价：可重复性。如果攻击者捕获发送到服务器的0-RTT数据包，他们可以重播它，并且服务器有可能认为它是有效。这会产生一些有意思的负面影响。</p><p><img data-src="https://st.razeen.cn/img/image/tls13/tls13-image12.png" alt></p><p>危险重放数据的一个演示就是更改服务器数据的状态。如果将增加计数器，执行数据库事务或执行任何具有永久效果的操作放入0-RTT数据中是有风险的。</p><p>作为客户端，您可以尝试通过仅将“安全”请求放入0-RTT数据来防止这种情况。这里的“安全”表示请求不会更改服务器状态。在HTTP中，不同的方法应该具有不同的语义。HTTP GET请求应该是安全的，因此浏览器通常通过在0-RTT中只发送GET请求来保护HTTPS服务器免受重放攻击。由于大多数页面加载以GET“/”开头，因此页面加载时间更快。</p><p>当在0-RTT中发送的数据用于状态改变请求时，就会发生问题。为帮助防止这种问题，TLS 1.3还包括会话票据中的时间戳。如果这种情况发生太大分歧，客户要么接近光速，要么重放数据。在任何一种情况下，服务器都应该谨慎拒绝0-RTT数据。</p><p>有关0-RTT的更多详细信息以及TLS 1.3中会话恢复的改进，请查看<a href="https://blog.cloudflare.com/introducing-0-rtt/" target="_blank" rel="noopener">此前的博客文章</a>。</p><h3 id="可部署性"><a href="#可部署性" class="headerlink" title="可部署性"></a>可部署性</h3><p>TLS 1.3与TLS 1.2及更早版本完全不同，但为了广泛部署，它必须向后兼容现有软件。TLS 1.3从草案到最终发布花了这么长时间的原因之一是，一些现有的软件（即中间键）与新的更改并没有很好地协调。即使在线上对TLS 1.3协议进行一些微小更改（例如消除冗余的ChangeCipherSpec消息，将版本从0x0303提升到0x0304）都会导致某些人的连接问题。</p><p>尽管未来的灵活性已经内置到TLS规范中，但是一些实现对如何处理未来的TLS版本做出了错误的假设。造成这种变化的现象称为<em>骨化</em>，我在前一篇文章中更全面地探讨了<a href="https://blog.cloudflare.com/why-tls-1-3-isnt-in-browsers-yet/" target="_blank" rel="noopener">TLS 1.3尚未部署的原因</a>。为了适应这些变化，TLS 1.3被修改为看起来很像TLS 1.2会话恢复（至少在线路上）。这导致了虽然增加了更多功能但不太美观。这是您在线升级最广泛部署的协议之一所付出的代价。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>TLS 1.3是一种现代安全协议，使用<a href="http://tls13tamarin.github.io/TLS13Tamarin/" target="_blank" rel="noopener">正式</a> <a href="https://eprint.iacr.org/2016/081" target="_blank" rel="noopener">分析</a>等现代工具构建，保持其向后兼容性。它已经过广泛测试，并在使用现实部署数据时进行了迭代。它是一种更清晰，更快速，更安全的协议。<a href="https://blog.cloudflare.com/you-get-tls-1-3-you-get-tls-1-3-everyone-gets-tls-1-3/" target="_blank" rel="noopener">所有Cloudflare客户</a>默认启用TLS 1.3 。</p><p>发布TLS 1.3是一项巨大的成就。这是最近最好的一个示例，如何使用已部署长达20年的遗留代码并动态更改它，从而为每个人提供更好的互联网。TLS 1.3在过去三年中一直在争论和分析，现在已准备好迎接黄金时段。欢迎，RFC 8446。</p><ul><li><a href="https://blog.cloudflare.com/rfc-8446-aka-tls-1-3/" target="_blank" rel="noopener">原文</a></li></ul>]]></content>
      <categories>
        <category>PKI/CA与数字证书</category>
        <category>HTTPS</category>
      </categories>
      <tags>
        <tag>加密</tag>
        <tag>tls1.3</tag>
        <tag>https</tag>
      </tags>
  </entry>
  <entry>
    <title>Disqus 添加有趣的 Reactions 的功能</title>
    <url>//post/disqus-reactions.html</url>
    <content><![CDATA[<p>听v友说添加了个Disqus添加个Reactions功能，看起来很有趣，赶快来试了一下～看看能不能消灭博客一直 O 回复的问题 ==</p><a id="more"></a><h3 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h3><p>加效果是这样的，如图：</p><p><img data-src="https://st.razeen.cn/img/blog/Jietu20180831-212655.png" alt></p><p>是不是很炫酷～</p><h3 id="添加"><a href="#添加" class="headerlink" title="添加"></a>添加</h3><blockquote><p>在Admin&gt;&gt;Edit Settings&gt;&gt;Reactions 即可设置。 可以自定义选项哦～</p></blockquote><p><img data-src="https://st.razeen.cn/img/blog/Jietu20180831-211817.png" alt></p>]]></content>
      <categories>
        <category>博客折腾日记</category>
      </categories>
      <tags>
        <tag>disqus</tag>
      </tags>
  </entry>
  <entry>
    <title>记录学位证、毕业证补办过程</title>
    <url>//post/fill-do-degree-graduation-certificate.html</url>
    <content><![CDATA[<p>毕业证、学位证对于我们真是太重要了，一般人也不会丢。但，如果你像我一样真的丢了，怎么办？</p><p>（PS：从来都没丢过重要东西，头次直接把两个证一起丢了！！）</p><a id="more"></a><p><em>补充：母校合肥学院</em></p><h3 id="心路历程"><a href="#心路历程" class="headerlink" title="心路历程"></a>心路历程</h3><p>丢了后，我Google了一下，看了一些流程，发现都是说的，先登报，然后巴拉巴拉。一看要登报，直接把我劝退。</p><p>继续搜索，发现有机构能帮忙补办，于是我加微信联系了一下。好家伙，真热情，问了学校，立马说能办，本人配合一下就行，14天内能办好，还给出了帮其他人补办的截图，一切看着都不错。最后问了下价格，好家伙，两个证件3400，再次劝退。</p><p>再到淘宝试一试。找了一家补办证件的，1400能办好，但周期大概30天，感觉还是不值且周期长。</p><p>最后还是得靠自己。</p><p>咨询了一下辅导员，嗯，还是辅导员靠谱（辅导员的教诲需要牢记！）。</p><p><img data-src="https://st.razeen.cn/img/diudiu.jpg" alt="辅导员"></p><h3 id="补办流程"><a href="#补办流程" class="headerlink" title="补办流程"></a>补办流程</h3><p>当然，辅导员说的也比较模糊，最后还是直接打电话给教务处咨询了一下，总结下来其实流程很简单：</p><ul><li><p>到学校网站下载“申请书”，如下图；</p><p><img data-src="https://st.razeen.cn/img/apply.png" alt="辅导员"></p><p>在申请表中，我们也看到了登报说明的东西，打电话问教务处，说是已经不用了，很早就取消了。</p></li></ul><ul><li><p>到档案处找老师查档案（开具 新生录取大表复印件（有本人姓名）；学历/学位证书签领表复印件）</p></li><li><p>带上下面材料去 学位办 提交申请。</p><ul><li style="list-style:none"><input type="checkbox">身份证复印件；</li><li style="list-style:none"><input type="checkbox">两张近期蓝底照片，小2寸（包括同底版电子档照片，小于16KB，发送至<a href="mailto:jwcxxk@hfuu.edu.cn" target="_blank" rel="noopener">jwcxxk@hfuu.edu.cn</a>）；</li><li style="list-style:none"><input type="checkbox">新生录取大表复印件（有本人姓名）(院办档案室提供)；</li><li style="list-style:none"><input type="checkbox">学历/学位证书签领表复印件 (院办档案室提供)。</li></ul></li></ul><p>然后等就可以了。</p><p>注：</p><ol><li>开具的证明与原证书具有同等效力。</li><li>毕业证明书将在学信网进行电子标注，以备核查，同时对原注册学历证书标明遗失作废。</li></ol><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>写这篇文章重点不仅是补办流程，还想说，证件丢了先不要急，先打电话问问证件得源头，不要被一些网上搜索忽悠。也许事情比我们想象得简单很多！！</p>]]></content>
      <categories>
        <category>生活记实</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title>Gin文件上传与下载</title>
    <url>//post/gin-file-down-upload.html</url>
    <content><![CDATA[<p>Gin是用Go编写的web框架。性能还不错，而且使用比较简单，还支持RESTful API。</p><p>日常的使用中我们可能要处理一些文件的上传与下载，我这里简单总结一下。</p><a id="more"></a><h3 id="单文件上传"><a href="#单文件上传" class="headerlink" title="单文件上传"></a>单文件上传</h3><p>我们使用<code>multipart/form-data</code>格式上传文件，利用<code>c.Request.FormFile</code>解析文件。</p><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// HandleUploadFile 上传单个文件</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HandleUploadFile</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">	file, header, err := c.Request.FormFile(<span class="string">"file"</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		c.JSON(http.StatusBadRequest, gin.H&#123;<span class="string">"msg"</span>: <span class="string">"文件上传失败"</span>&#125;)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	content, err := ioutil.ReadAll(file)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		c.JSON(http.StatusBadRequest, gin.H&#123;<span class="string">"msg"</span>: <span class="string">"文件读取失败"</span>&#125;)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Println(header.Filename)</span><br><span class="line">	fmt.Println(<span class="keyword">string</span>(content))</span><br><span class="line">	c.JSON(http.StatusOK, gin.H&#123;<span class="string">"msg"</span>: <span class="string">"上传成功"</span>&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们上传文件可以看到。</p><p><img data-src="https://st.razeen.cn/img/201809/jietu20180906-002227.png" alt="jietu20180906-002227"></p><p>我们已经看到文件上传成功，已经文件名字与内容。</p><h3 id="多文件上传"><a href="#多文件上传" class="headerlink" title="多文件上传"></a>多文件上传</h3><p>多文件的上传利用<code>c.Request.MultipartForm</code>解析。</p><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// HandleUploadMutiFile 上传多个文件</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HandleUploadMutiFile</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 限制放入内存的文件大小</span></span><br><span class="line">	err := c.Request.ParseMultipartForm(<span class="number">4</span> &lt;&lt; <span class="number">20</span>)  <span class="comment">// 4Mb</span></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		c.JSON(http.StatusBadRequest, gin.H&#123;<span class="string">"msg"</span>: <span class="string">"文件太大"</span>&#125;)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	formdata := c.Request.MultipartForm</span><br><span class="line">	files := formdata.File[<span class="string">"file"</span>]</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> files &#123;</span><br><span class="line">		file, err := v.Open()</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			c.JSON(http.StatusBadRequest, gin.H&#123;<span class="string">"msg"</span>: <span class="string">"文件读取失败"</span>&#125;)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">defer</span> file.Close()</span><br><span class="line"></span><br><span class="line">		content, err := ioutil.ReadAll(file)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			c.JSON(http.StatusBadRequest, gin.H&#123;<span class="string">"msg"</span>: <span class="string">"文件读取失败"</span>&#125;)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		fmt.Println(v.Filename)</span><br><span class="line">		fmt.Println(<span class="keyword">string</span>(content))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	c.JSON(http.StatusOK, gin.H&#123;<span class="string">"msg"</span>: <span class="string">"上传成功"</span>&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>多个文件，遍历文件内容即可读取。</p><p><del>利用<code>c.Request.ParseMultipartForm()</code>可设置上传文件的大小，这里限制了4Mb。</del><br><code>c.Request.ParseMultipartForm()</code>并不能限制上传文件的大小，只是限制了上传的文件读取到内存部分的大小，如果超过了就存入了系统的临时文件中。<br>如果需要限制文件大小，需要使用<code>github.com/gin-contrib/size</code>中间件，如<a href="https://github.com/razeencheng/demo-go/blob/master/gin/gin.go" target="_blank" rel="noopener">demo</a>中使用<code>r.Use(limits.RequestSizeLimiter(4 &lt;&lt; 20))</code>限制最大4Mb。</p><p>我们看到</p><p><img data-src="https://st.razeen.cn/img/201809/jietu20180906-002143.png" alt="jietu20180906-002143"></p><p>两个文件已经上传成功。</p><h3 id="文件下载"><a href="#文件下载" class="headerlink" title="文件下载"></a>文件下载</h3><p>文件的下载主要是注意设置文件名，文件类型等。</p><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// HandleDownloadFile 下载文件</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HandleDownloadFile</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">	content := c.Query(<span class="string">"content"</span>)</span><br><span class="line"></span><br><span class="line">	content = <span class="string">"hello world, 我是一个文件，"</span> + content</span><br><span class="line"></span><br><span class="line">	c.Writer.WriteHeader(http.StatusOK)</span><br><span class="line">	c.Header(<span class="string">"Content-Disposition"</span>, <span class="string">"attachment; filename=hello.txt"</span>)</span><br><span class="line">	c.Header(<span class="string">"Content-Type"</span>, <span class="string">"application/text/plain"</span>)</span><br><span class="line">	c.Header(<span class="string">"Accept-Length"</span>, fmt.Sprintf(<span class="string">"%d"</span>, <span class="built_in">len</span>(content)))</span><br><span class="line">	c.Writer.Write([]<span class="keyword">byte</span>(content))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过</p><ul><li><code>Content-Disposition</code>设置文件名字；</li><li><code>Content-Type</code>设置文件类型，可以到<a href="http://www.runoob.com/http/http-content-type.html" target="_blank" rel="noopener">这里</a>查阅；</li><li><code>Accept-Length</code>这个设置文件长度；</li><li><code>c.Writer.Write</code>写出文件。</li></ul><p>成功下载可以看到：</p><p><img data-src="https://st.razeen.cn/img/201809/jietu20180906-004014.png" alt="jietu20180906-004014"></p><ul><li>完整demo<a href="https://github.com/razeencheng/demo-go/blob/master/gin/gin.go" target="_blank" rel="noopener">在这里</a></li></ul>]]></content>
      <categories>
        <category>Go学习笔记</category>
        <category>Go基础</category>
      </categories>
      <tags>
        <tag>golang</tag>
        <tag>gin</tag>
      </tags>
  </entry>
  <entry>
    <title>Go学习笔记(四) | win上使用VSCode搭建Go开发环境</title>
    <url>//post/go-build-vscode-win-env.html</url>
    <content><![CDATA[<p>每天背着个Mac挤地铁，挤得一身汗不说，还担心把屏幕挤坏了。看着家里这台闲着的Window,我决定给他用起来。那么问题来了，用什么IDE呢？</p><a id="more"></a><p>打了两届GopherChina的酱油，其他的没学到，倒是发现大神们都在用VSCode，Mac上体验了一段时间，虽然不能完全代替mvim, 但用起来已经算是好用了,特别在调试上。这篇博客带你在win上从零开始搭建Go开发环境。</p><h3 id="安装VSCode"><a href="#安装VSCode" class="headerlink" title="安装VSCode"></a>安装VSCode</h3><p>下载安装这个肯定不用我说了，下载地址点<a href="https://vscode.cdn.azure.cn/stable/d0182c3417d225529c6d5ad24b7572815d0de9ac/VSCodeSetup-x64-1.23.1.exe" target="_blank" rel="noopener">这里</a>, 安装完成后大致如下：</p><p><img data-src="https://st.razeen.cn/img/image/vscode-001.png" alt></p><p>默认会把 <code>D:\Program Files\Microsoft VS Code\bin</code> ( 我装在<code>D:\Program Files文件夹下</code>)加入系统环境变量中，重启后起效。</p><p><em>系统环境变量 电脑 &gt; 属性 &gt; 高级系统设置 &gt; 环境变量 可查看</em></p><h3 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h3><p>到<a href="https://git-scm.com/download/win" target="_blank" rel="noopener">git-scm.com</a>下载<a href="https://github-production-release-asset-2e65be.s3.amazonaws.com/23216272/52993848-638c-11e8-87c7-4d75fc1d0b18?X-Amz-Algorithm=AWS4-HMAC-SHA256&amp;X-Amz-Credential=AKIAIWNJYAX4CSVEH53A%2F20180531%2Fus-east-1%2Fs3%2Faws4_request&amp;X-Amz-Date=20180531T143613Z&amp;X-Amz-Expires=300&amp;X-Amz-Signature=214bfd27c56730466d2a43ae8f6a8104fc19ca3004275a5f6ffb7f929dc667c1&amp;X-Amz-SignedHeaders=host&amp;actor_id=16044915&amp;response-content-disposition=attachment%3B%20filename%3DGit-2.17.1.2-64-bit.exe&amp;response-content-type=application%2Foctet-stream" target="_blank" rel="noopener"><code>Git for Windows</code></a>。除了第二步安装在D盘、第五步选择将VSCode作为默认编辑器外，其他都使用的默认设置，一部一部完成。</p><p><img data-src="https://st.razeen.cn/img/image/vscode-002.png =400x" alt></p><p>之后再次打开VSCode，VSCode会自动找到已安装的Git，如下。</p><p><img data-src="https://st.razeen.cn/img/image/vscode-003.png =400x" alt></p><h3 id="安装Go"><a href="#安装Go" class="headerlink" title="安装Go"></a>安装Go</h3><p>到<a href="https://golang.org/dl/" target="_blank" rel="noopener">golang,org</a>下载<a href="https://dl.google.com/go/go1.10.2.windows-amd64.msi" target="_blank" rel="noopener"><code>Windows安装版</code></a>，直接运行安装。默认配置一步步走下去即可。默认添加<code>GOROOT</code>、<code>GOPATH</code>、<code>GOBIN</code>如下图所示。</p><p><img data-src="https://st.razeen.cn/img/image/vscode-004.png" alt></p><p>因个人喜好，<code>GOPATH</code>我设置到D盘了。当然你可以设置多个，但<code>go get</code>等一般会下载到你设置的第一个<code>GOPATH</code>中。</p><p><img data-src="https://st.razeen.cn/img/image/vscode-005.png" alt></p><p>之后重启一下，相关环境变量就起作用了。</p><h3 id="安装扩展以及相关设置"><a href="#安装扩展以及相关设置" class="headerlink" title="安装扩展以及相关设置"></a>安装扩展以及相关设置</h3><p>打开VSCode, <code>Ctrk+Shift+X</code> 直接进入装扩展界面。</p><p>需要安装的有</p><ul><li><p>Go for Visual Studio Code （直接搜索go就能看到，直接点安装）</p><p><img data-src="https://st.razeen.cn/img/image/vscode-006.png" alt></p></li><li><p>VSCode设置<code>GOPATH</code> （这一步可忽略，上一步安装Go中设置的环境变量一般重启后生效。我个人偏向单独再设置一下）</p><p><img data-src="https://st.razeen.cn/img/image/vscode-007.png" alt></p></li><li><p>相关组件</p><p>打开命令行工具（或者直接在VSCode内打开终端），依次执行以下命令，通过源码安装相关组件。部分需要FQ。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span> get -u -v github.com/nsf/gocode</span><br><span class="line"><span class="keyword">go</span> get -u -v github.com/rogpeppe/godef</span><br><span class="line"><span class="keyword">go</span> get -u -v github.com/golang/lint/golint</span><br><span class="line"><span class="keyword">go</span> get -u -v github.com/lukehoban/<span class="keyword">go</span>-find-references</span><br><span class="line"><span class="keyword">go</span> get -u -v github.com/lukehoban/<span class="keyword">go</span>-outline</span><br><span class="line"><span class="keyword">go</span> get -u -v sourcegraph.com/sqs/goreturns</span><br><span class="line"><span class="keyword">go</span> get -u -v golang.org/x/tools/cmd/gorename</span><br><span class="line"><span class="keyword">go</span> get -u -v github.com/tpng/gopkgs</span><br><span class="line"><span class="keyword">go</span> get -u -v github.com/newhook/<span class="keyword">go</span>-symbols</span><br></pre></td></tr></table></figure><p>经过漫长的等待，我们终于下载好了这些组件。之后你可以打开一个存在的项目或者新建一个Go项目，会提示你安装缺失的组件，安装提示安装即可。</p><p><img data-src="https://st.razeen.cn/img/image/vscode-008.png" alt></p><p><img data-src="https://st.razeen.cn/img/image/vscode-009.png" alt></p><p>我们写个<code>Hello World</code>试试：</p><p><img data-src="https://st.razeen.cn/img/image/vscode-010.png" alt></p><p>完美通过，我们我们基本的环境以及搭建完成了，写代码基本可以了。</p></li></ul><h3 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h3><p>打开项目，按F5或者点击<code>调试&gt;启动调试</code>就可以进入调试页面。我们预先打好一些断点，可以很方便的调试大部分代码。</p><p><img data-src="https://st.razeen.cn/img/image/vscode-011.png" alt></p><p>调试主要使用的工具为<code>github.com/peterh/liner github.com/derekparker/delve/cmd/dlv</code>, 支持一些自定义配置，如果你需要自定义配置通过<code>调试&gt;打开配置</code>设置。</p><p><img data-src="https://st.razeen.cn/img/image/vscode-012.png" alt></p><h3 id="一键生成单元测试"><a href="#一键生成单元测试" class="headerlink" title="一键生成单元测试"></a>一键生成单元测试</h3><p>在你需要生成单元测试的函数上，右击<code>Go: Generate Unit Tests For Function</code>即可生成。如果你没有按照该插件，会指导你安装。</p><p><img data-src="https://st.razeen.cn/img/image/vscode-013.png" alt></p><p>生成的测试代码如下，我们还可以点击函数上方<code>run test</code>或<code>debug test</code>j运行测试或调试。</p><p><img data-src="https://st.razeen.cn/img/image/vscode-015.png" alt></p><h3 id="安装Vim"><a href="#安装Vim" class="headerlink" title="安装Vim"></a>安装Vim</h3><p>由于我是mvim转过来的，vim上的一些快捷操作确实能很大程度提高工作效率，Vim对于我来说肯定是必须安装，恰好VSCode的vim支持的还不错,甚至连<code>gd</code>跳转定义，<code>ctrl-o</code>返回等等操作都有，用起来还是相当顺手的~。</p><p>直接<code>Ctrl+Shift+X</code>搜索vim,第一个就是，直接安装即可。</p><p><img data-src="https://st.razeen.cn/img/image/vscode-014.png" alt></p><p>之后你就可以愉快的使用vim操作了。</p><p>到这里，你就可以愉快的敲代码了~~~</p>]]></content>
      <categories>
        <category>Go学习笔记</category>
        <category>Go工具</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>vscode</tag>
      </tags>
  </entry>
  <entry>
    <title>Go学习笔记(三) | 怎么写Go基准测试（性能测试）</title>
    <url>//post/go-how-to-write-benchmark.html</url>
    <content><![CDATA[<p>或许你经常会思考这样的问题，我用不同的方法实现了同样的效果，哪个会更快？哪个内存消耗更小？这时候你一个简单的基准测试就能解决你的疑惑。</p><a id="more"></a><p>Go向来是以工具丰富而著称的，在学习Go的过程中，你会发现无论是写一个单元测试，还是做一些竞争检测都能很快的上手，而且用的很痛快。当然，接下来要说的基准测试也一样。</p><p>基准测试工具就在Go的测试包中，下面就用<a href="https://github.com/razeencheng/demo-go/tree/master/benchmark" target="_blank" rel="noopener">一个例子</a>来介绍。</p><h3 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子"></a>举个栗子</h3><p>由于一些场景需要，我需要将<code>[]byte</code>输出16进制字符。</p><p>有时候我会这么写:</p><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line">fmt.Sprintf(<span class="string">"%x"</span>, b)</span><br></pre></td></tr></table></figure><p>但有时候我会这么写：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hex.EncodeToString(b)</span><br></pre></td></tr></table></figure><p>但到底哪种写法更好呢？今天我就来比较一下。</p><p>直接写了个<code>main.go</code></p><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">EncodeA</span><span class="params">(b []<span class="keyword">byte</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> fmt.Sprintf(<span class="string">"%x"</span>, b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">EncodeB</span><span class="params">(b []<span class="keyword">byte</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> hex.EncodeToString(b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再写个测试<code>main_test.go</code></p><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> buf = []<span class="keyword">byte</span>(<span class="string">"skdjadialsdgasadasdhsakdjsahlskdjagloqweiqwo"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkEncodeA</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">		EncodeA(buf)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkEncodeB</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">		EncodeB(buf)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就这么简单，我们的基本测试就写完了。从我的写法中你也许就知道：</p><ul><li>和单元测试一样，都写在<code>_test.go</code>文件中；</li><li>需要以<code>Benchmark</code>为函数名开头；</li><li>和单元测试类似，必须接受一个<code>*testing.B</code>参数；</li><li>被测试代码放在一个循环中。</li></ul><p>我们直接跑一下。当然我们也是用<code>go test</code>来执行测试，简单的测试只要带上<code>-bench=.</code>就可以了。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> go <span class="built_in">test</span> -bench=.</span></span><br><span class="line">goos: darwin</span><br><span class="line">goarch: amd64</span><br><span class="line">pkg: github.com/razeencheng/demo-go/benchmark</span><br><span class="line">BenchmarkEncodeA-8       5000000               265 ns/op</span><br><span class="line">BenchmarkEncodeB-8      10000000               161 ns/op</span><br><span class="line">PASS</span><br><span class="line">ok      github.com/razeencheng/demo-go/benchmark        3.397s</span><br></pre></td></tr></table></figure><p>前两行是平台信息，第三行包名。第四、五行就是测试的结果了。</p><ul><li><code>BenchmarkEncodeA-8</code> ,<code>BenchmarkEncodeB-8</code> 基准测试函数名-GOMAXPROCS</li><li><code>5000000</code>,<code>10000000</code> 被测试的函数执行次数，也就是<code>EncodeA()</code>被执行了5000000次，<code>EncodeB()</code>被执行了10000000次，也就是<code>b.N</code>的值了。</li><li><code>265 ns/op</code>,<code>161 ns/op</code>表示每次调用被测试函数花费的时间。</li></ul><p>从花费的时间上来看，我们知道<code>EncodeB()</code>要快一点。</p><h3 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h3><p>你以为就这么简单的结束了么？NONONO。</p><ul><li><code>-bench</code> 可接收一个有效的正则表达式来执行符合条件的测试函数。当你的函数很多时，可以用它来过滤.</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> go <span class="built_in">test</span> -bench=BenchmarkEncodeA</span></span><br><span class="line">goos: darwin</span><br><span class="line">goarch: amd64</span><br><span class="line">pkg: github.com/razeencheng/demo-go/benchmark</span><br><span class="line">BenchmarkEncodeA-8       5000000               256 ns/op</span><br><span class="line">PASS</span><br><span class="line">ok      github.com/razeencheng/demo-go/benchmark        1.575s</span><br></pre></td></tr></table></figure><ul><li><code>-benchmem</code>可以查看内存分配</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> go <span class="built_in">test</span> -bench=. -benchmem</span></span><br><span class="line">goos: darwin</span><br><span class="line">goarch: amd64</span><br><span class="line">pkg: github.com/razeencheng/demo-go/benchmark</span><br><span class="line">BenchmarkEncodeA-8       5000000               261 ns/op             128 B/op          2 allocs/op</span><br><span class="line">BenchmarkEncodeB-8      10000000               162 ns/op             192 B/op          2 allocs/op</span><br><span class="line">PASS</span><br><span class="line">ok      github.com/razeencheng/demo-go/benchmark        3.408s</span><br></pre></td></tr></table></figure><p>其中<code>B/op</code> 表示每次执行会分配多少内存，<code>allocs/op</code>表示每次执行会发生多少次内存分配。</p><ul><li><p><code>-benchtime</code>指定每个测试执行的时间。默认<code>1s</code>,当你的函数比较耗时你可以设置更长一点。因为<code>b.N</code>是与这个时间有关的。</p><p>当你的运行时间没达到<code>-benchtime</code>制定的时间前，<code>b.N</code>将以1，2，5，10，20，50…增加，然后重新运行测试代码。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> go <span class="built_in">test</span> -bench=. -benchmem -benchtime=5s</span></span><br><span class="line">goos: darwin</span><br><span class="line">goarch: amd64</span><br><span class="line">pkg: github.com/razeencheng/demo-go/benchmark</span><br><span class="line">BenchmarkEncodeA-8      30000000               254 ns/op             128 B/op          2 allocs/op</span><br><span class="line">BenchmarkEncodeB-8      50000000               160 ns/op             192 B/op          2 allocs/op</span><br><span class="line">PASS</span><br><span class="line">ok      github.com/razeencheng/demo-go/benchmark        16.113s</span><br></pre></td></tr></table></figure></li><li><p><code>-count</code>指定每个测试执行的次数。</p></li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> go <span class="built_in">test</span> -bench=. -benchmem -count=3</span></span><br><span class="line">goos: darwin</span><br><span class="line">goarch: amd64</span><br><span class="line">pkg: github.com/razeencheng/demo-go/benchmark</span><br><span class="line">BenchmarkEncodeA-8       5000000               256 ns/op             128 B/op          2 allocs/op</span><br><span class="line">BenchmarkEncodeA-8       5000000               255 ns/op             128 B/op          2 allocs/op</span><br><span class="line">BenchmarkEncodeA-8       5000000               253 ns/op             128 B/op          2 allocs/op</span><br><span class="line">BenchmarkEncodeB-8      10000000               163 ns/op             192 B/op          2 allocs/op</span><br><span class="line">BenchmarkEncodeB-8      10000000               160 ns/op             192 B/op          2 allocs/op</span><br><span class="line">BenchmarkEncodeB-8      10000000               160 ns/op             192 B/op          2 allocs/op</span><br><span class="line">PASS</span><br><span class="line">ok      github.com/razeencheng/demo-go/benchmark        9.984s</span><br></pre></td></tr></table></figure><p>我常用的也就这些了。</p><p>但对于<code>testing.B</code>来说，它拥有了<code>testing.T</code>的全部接口，所以<code>Fail,Skip,Error</code>这些都可以用，而且还增加了</p><ul><li><code>SetBytes( i uint64)</code> 统计内存消耗。</li><li><code>SetParallelism(p int)</code> 制定并行数目。</li><li><code>StartTimer / StopTimer / ResertTimer</code> 操作计时器。</li></ul><p>你可以按需使用。</p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p><code>b.N</code>为一个自增字段，谨慎用它做函数参数。</p>]]></content>
      <categories>
        <category>Go学习笔记</category>
        <category>Go基础</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>benchmark</tag>
      </tags>
  </entry>
  <entry>
    <title>Go学习笔记(五) | 使用代码片段(snippets)提高编码效率</title>
    <url>//post/go-snippets.html</url>
    <content><![CDATA[<p>在Coding的时候，难免会有一些重复的代码或者形式相似的代码，在写这些代码的时候，你会觉得索然无味，甚至有点讨厌。这时候，你就会想，这段代码是否可以抽象成一个通用的片段，我简单敲几个快捷键就出来了呢。这也就代码片段所解决的问题。</p><a id="more"></a><p>现在几乎大部分的编译器都支持代码片段，如下图就是我用VSCode写一段简单的代码。</p><p><img data-src="https://st.razeen.cn/img/201812/snippets_001.png" alt></p><p>在写这段代码的时候我就用到了代码片段，即<code>1</code>中,当我们敲下<code>func</code>关键词后出现的第三个提示。只需要Tab一下，我们就可以使用该片段。如<code>2</code>中所示，该片段已经为我设定好了哪些位置可能需要填写，我们只需要Tab到对应位置填写即可。</p><p>其实这样的片段，我们一直在使用，如<code>for</code>自动补全格式，<code>switch</code>自动补全case等，当然这些都是他人已经定制好的，有时我们需要自己去定义一些符合自己业务场景的该怎么做呢？</p><h3 id="VSCode-自定义Go片段"><a href="#VSCode-自定义Go片段" class="headerlink" title="VSCode 自定义Go片段"></a>VSCode 自定义Go片段</h3><p>如下图所示：</p><ol><li><p><code>Shift + Cmd + P</code> 打开命令窗口，输入snippets;</p></li><li><p>选择 <code>Preferences: Open User Snippets</code>;</p></li><li><p>选择 <code>go.json</code>；</p></li></ol><p><img data-src="https://st.razeen.cn/img/201812/jietu20181205-101858.png" alt></p><p>这样我们就可以编辑该<code>go.json</code>文件了。片段的书写就是以json的形式在该文件内定义的，具体格式如下：</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">"Print to console": &#123;</span><br><span class="line">	"prefix": "log",</span><br><span class="line">	"body": [</span><br><span class="line">		"console.log('$1');",</span><br><span class="line">		<span class="string">"$2"</span></span><br><span class="line">	],</span><br><span class="line">	"description": "Log output to console"</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>其中：</p><ol><li><code>prefix</code> 指的是前缀，也就是当我们敲出<code>log</code>时，就自动提示该片段；</li><li><code>body</code> 就是片段的具体内容，$1,$2… 是占位符号，当使用片段时就可以使用Tab在这些占位符之间跳跃；我们也可以使用<code>${1:default}</code>来设置一些标签帮助我们辨识。</li><li><code>description</code> 以及 <code>Print to console</code> 都是我们在选择该片段时提示的内容。<code>description</code>可不写。</li></ol><p>效果如下所示：</p><p><img data-src="https://st.razeen.cn/img/201812/jietu20181205-011243.png" alt></p><p><img data-src="https://st.razeen.cn/img/201812/jietu20181205-011634.png" alt></p><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><p>1.在使用<code>gin</code>的时候，我们的Handle函数总是这样的<code>func HandleXXX(c *gin.Context)</code>,于是我们可以定义一个<code>gin handle</code>的片段；</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">"GIN Route Handler": &#123;</span><br><span class="line">	"prefix": "ginh",</span><br><span class="line">	"body": [</span><br><span class="line">		"// Handle$&#123;1&#125; godoc",</span><br><span class="line">		"func Handle$&#123;1&#125;(c *gin.Context) &#123;",</span><br><span class="line">		"$2",</span><br><span class="line">		"&#125;",</span><br><span class="line">	]</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>2.在使用<code>gorm</code>的时候，我们定义结构需要指定字段名称等，其形式总是这样的<code>gorm:\&quot;column:xxx&quot;</code>,于是:</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">"GORM" : &#123;</span><br><span class="line">	"prefix": "gormcl",</span><br><span class="line">	"body" : [</span><br><span class="line">		"`gorm:\"column:$&#123;1:columnName&#125;\"`",</span><br><span class="line">		<span class="string">"$2"</span></span><br><span class="line">	]</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>3.在使用<code>Swago</code>自动生成API文档时，我们需要去按照固定的范式写注释，于是:</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">"SWAG API": &#123;</span><br><span class="line">	"prefix": "swag",</span><br><span class="line">	"body": [</span><br><span class="line">		"// @Summary $1",</span><br><span class="line">                       "// @Tags $2",</span><br><span class="line">		"// @Description $3",</span><br><span class="line">		"// @Accept $&#123;4:mpfd&#125; $&#123;5:json&#125;",</span><br><span class="line">		"// @Produce $&#123;6:json&#125;",</span><br><span class="line">		"// @Param $&#123;7:param&#125; $&#123;8:query&#125; $&#123;9:string&#125; $&#123;10:true&#125; \"$&#123;11:describe&#125;\"  $&#123;12:Enums()&#125; $&#123;13:default&#125;",</span><br><span class="line">		"// @Success 200 &#123;$&#123;14:object&#125;&#125; $&#123;15:model&#125;",</span><br><span class="line">		<span class="string">"// @Router /$&#123;16:path&#125; [$&#123;17:get&#125;]"</span></span><br><span class="line">	]</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>等等，有了片段后，我们可以通过<code>prefix+Tab</code>更加高效的将这些重复内容编写出来，快去试试吧～</p><h3 id="vim自定义Go片段"><a href="#vim自定义Go片段" class="headerlink" title="vim自定义Go片段"></a>vim自定义Go片段</h3><p>当然，除了宇宙第一编辑器VSCode外，vim上使用片段也是相当爽快的。</p><p>在vim上使用片段，需要装两个插件</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Plugin &apos;SirVer/ultisnips&apos;</span><br><span class="line">Plugin &apos;honza/vim-snippets&apos;</span><br></pre></td></tr></table></figure><p>前者是片段的引擎，后者是网友提供的一些片段集合，安装好这两个插件后，我们在<code>~/.vim/bundle/vim-snippets/UltiSnips</code> 与 <code>~/.vim/bundle/vim-snippets/snippets</code> 下能看到多种语言的代码片段。</p><blockquote><p>这里 <code>UltiSnips/*</code> 与 <code>snippets/*</code> 下的区别是片段使用的引擎不一样。 <code>SnipMate</code>和<code>UltiSnips</code>是vim比较流行的片段引擎。 不同的引擎，语法稍有区别。 但<code>UltiSnips</code>是兼容<code>SnipMate</code>的。</p></blockquote><p>我们这里主要看到<code>~/.vim/bundle/vim-snippets/UltiSnips/go.snippets</code>。打开该文件，我们能看到很多已经定义好的片段，只要按照该语法在该文件加入自定义片段即可使用。</p><p>其语法结构很简单</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">snippet &lt;prefix&gt; &lt;name&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">endsnippet</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">有时我们会看到`&lt;name&gt;` 后面会接着`b`,`a`，等字符。</span><br><span class="line"></span><br><span class="line">其中`b`意味着 begin (snippet should be expanded only at the beginning of a line)，也就是表示该片段只能在一段开始的时候使用。</span><br><span class="line"></span><br><span class="line">而`a`代表这自动展开的意思，其实还有`w,i,r,s,t,m`等限定词，具体可以使用`:help ultisnip`查看帮助文档。</span><br><span class="line"></span><br><span class="line">了解语法后，可以将上面VSCode使用的片段在vim实现了～</span><br><span class="line"></span><br><span class="line">#### 例子</span><br><span class="line"></span><br><span class="line">**1.gin handle**</span><br><span class="line"></span><br><span class="line">``` snippets</span><br><span class="line">snippet ginh &quot;GIN Route Handler&quot; b</span><br><span class="line">// Handle$1 godoc</span><br><span class="line">func Handle$1(c *gin.Context) &#123;</span><br><span class="line">    $2</span><br><span class="line">&#125;</span><br><span class="line">endsnippet</span><br></pre></td></tr></table></figure><p><strong>2.gorm</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">snippet gormcl &quot;gorm comments&quot; </span><br><span class="line">\`gorm:&quot;column:$&#123;1:columnName&#125;$2&quot;\`</span><br><span class="line">endsnippet</span><br></pre></td></tr></table></figure><p><strong>3.swago</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">snippet swag &quot;swag comments for api doc&quot; b</span><br><span class="line">// @Summary $1</span><br><span class="line">// @Tags $2</span><br><span class="line">// @Description $3</span><br><span class="line">// @Accept $&#123;4:mpfd&#125; $&#123;5:json&#125;</span><br><span class="line">// @Produce $&#123;6:json&#125;</span><br><span class="line">// @Param $&#123;7:param&#125; $&#123;8:query&#125; $&#123;9:string&#125; $&#123;10:true&#125; &quot;$&#123;11:describe&#125;&quot; $&#123;12:Enums()&#125; $&#123;13:default&#125;</span><br><span class="line">// @Success 200 &#123;$&#123;14:object&#125;&#125; $&#123;15:model&#125;</span><br><span class="line">// @Router $&#123;16:path&#125; [$&#123;17:get&#125;]</span><br><span class="line">endsnippet</span><br></pre></td></tr></table></figure><p>在实际的coding过程中，不断的积累一些代码片段，写一些适合自己业务场景的片段，确实能行而有效的提高代码的效率，提高代码的整洁度。</p>]]></content>
      <categories>
        <category>Go学习笔记</category>
        <category>Go工具</category>
      </categories>
      <tags>
        <tag>golang</tag>
        <tag>snippet</tag>
      </tags>
  </entry>
  <entry>
    <title>Go学习笔记(六) | 使用swaggo自动生成Restful API文档</title>
    <url>//post/go-swagger.html</url>
    <content><![CDATA[<p>相信很多程序猿和我一样不喜欢写API文档。写代码多舒服，写文档不仅要花费大量的时间，有时候还不能做到面面具全。但API文档是必不可少的，相信其重要性就不用我说了，一份含糊的文档甚至能让前后端人员打起来。 而今天这篇博客介绍的swaggo就是让你只需要专注于代码就可以生成完美API文档的工具。废话说的有点多，我们直接看文章。</p><a id="more"></a><p>大概最后文档效果是这样的：</p><p><img data-src="https://st.razeen.cn/img/201901/jietu20190113-003056.png" alt></p><h3 id="关于Swaggo"><a href="#关于Swaggo" class="headerlink" title="关于Swaggo"></a>关于Swaggo</h3><p>或许你使用过<a href="https://swagger.io/" target="_blank" rel="noopener">Swagger</a>, 而 swaggo就是代替了你手动编写yaml的部分。只要通过一个命令就可以将注释转换成文档，这让我们可以更加专注于代码。</p><p>目前swaggo主要实现了swagger 2.0 的以下部分功能：</p><ul><li style="list-style:none"><input type="checkbox" checked>基本结构（Basic Structure）</li><li style="list-style:none"><input type="checkbox" checked>API 地址与基本路径（API Host and Base Path）</li><li style="list-style:none"><input type="checkbox" checked>路径与操作 （Paths and Operations）</li><li style="list-style:none"><input type="checkbox" checked>参数描述（Describing Parameters）</li><li style="list-style:none"><input type="checkbox" checked>请求参数描述（Describing Request Body）</li><li style="list-style:none"><input type="checkbox" checked>返回描述（Describing Responses）</li><li style="list-style:none"><input type="checkbox" checked>MIME 类型（MIME Types）</li><li style="list-style:none"><input type="checkbox" checked>认证（Authentication）<ul><li style="list-style:none"><input type="checkbox" checked>Basic Authentication</li><li style="list-style:none"><input type="checkbox" checked>API Keys</li></ul></li><li style="list-style:none"><input type="checkbox" checked>添加实例（Adding Examples）</li><li style="list-style:none"><input type="checkbox" checked>文件上传（File Upload）</li><li style="list-style:none"><input type="checkbox" checked>枚举（Enums）</li><li style="list-style:none"><input type="checkbox" checked>按标签分组（Grouping Operations With Tags）</li><li style="list-style:none"><input type="checkbox">扩展（Swagger Extensions）</li></ul><p><em>下文内容均以gin-swaggo为例</em></p><p><em><a href="https://github.com/razeencheng/demo-go/tree/master/swaggo-gin" target="_blank" rel="noopener">这里是demo地址</a></em></p><blockquote><p>2020/05/16 更新：</p><p>swag 升级到了 v1.6.5，返回数据格式有更新。</p><p>最新的请关注<a href="https://github.com/swaggo/swag/blob/master/README_zh-CN.md" target="_blank" rel="noopener">官网文档</a>。</p><p>本文最后，优化部分可以了解一下。</p></blockquote><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><h4 id="安装swag-cli-及下载相关包"><a href="#安装swag-cli-及下载相关包" class="headerlink" title="安装swag cli 及下载相关包"></a>安装<code>swag cli</code> 及下载相关包</h4><p>要使用swaggo,首先需要安装<code>swag cli</code>。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go get -u github.com/swaggo/swag/cmd/swag</span><br></pre></td></tr></table></figure><p>然后我们还需要两个包。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># gin-swagger 中间件</span></span><br><span class="line">go get github.com/swaggo/gin-swagger</span><br><span class="line"><span class="comment"># swagger 内置文件</span></span><br><span class="line">go get github.com/swaggo/gin-swagger/swaggerFiles</span><br></pre></td></tr></table></figure><p>可以看一下自己安装的版本</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">swag --version</span><br><span class="line">swag version v1.6.5</span><br></pre></td></tr></table></figure><h4 id="在main-go内添加注释"><a href="#在main-go内添加注释" class="headerlink" title="在main.go内添加注释"></a>在<code>main.go</code>内添加注释</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"github.com/gin-gonic/gin"</span></span><br><span class="line">	ginSwagger <span class="string">"github.com/swaggo/gin-swagger"</span></span><br><span class="line">	<span class="string">"github.com/swaggo/gin-swagger/swaggerFiles"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// @title Swagger Example API</span></span><br><span class="line"><span class="comment">// @version 1.0</span></span><br><span class="line"><span class="comment">// @description This is a sample server celler server.</span></span><br><span class="line"><span class="comment">// @termsOfService https://razeen.me</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// @contact.name Razeen</span></span><br><span class="line"><span class="comment">// @contact.url https://razeen.me</span></span><br><span class="line"><span class="comment">// @contact.email me@razeen.me</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// @license.name Apache 2.0</span></span><br><span class="line"><span class="comment">// @license.url http://www.apache.org/licenses/LICENSE-2.0.html</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// @host 127.0.0.1:8080</span></span><br><span class="line"><span class="comment">// @BasePath /api/v1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	r := gin.Default()</span><br><span class="line">    store := sessions.NewCookieStore([]<span class="keyword">byte</span>(<span class="string">"secret"</span>))</span><br><span class="line">	r.Use(sessions.Sessions(<span class="string">"mysession"</span>, store))</span><br><span class="line"></span><br><span class="line">	r.GET(<span class="string">"/swagger/*any"</span>, ginSwagger.WrapHandler(swaggerFiles.Handler))</span><br><span class="line"></span><br><span class="line">	v1 := r.Group(<span class="string">"/api/v1"</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		v1.GET(<span class="string">"/hello"</span>, HandleHello)</span><br><span class="line">		v1.POST(<span class="string">"/login"</span>, HandleLogin)</span><br><span class="line">		v1Auth := r.Use(HandleAuth)</span><br><span class="line">		&#123;</span><br><span class="line">			v1Auth.POST(<span class="string">"/upload"</span>, HandleUpload)</span><br><span class="line">			v1Auth.GET(<span class="string">"/list"</span>, HandleList)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	r.Run(<span class="string">":8080"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上所示，我们需要导入</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ginSwagger &quot;github.com/swaggo/gin-swagger&quot;</span><br><span class="line">&quot;github.com/swaggo/gin-swagger/swaggerFiles&quot;</span><br></pre></td></tr></table></figure><p>同时，添加注释。其中：</p><ul><li><code>titile</code>: 文档标题</li><li><code>version</code>: 版本</li><li><code>description,termsOfService,contact ...</code> 这些都是一些声明，可不写。</li><li><code>license.name</code> 额，这个是必须的。</li><li><code>host</code>,<code>BasePath</code>: 如果你想直接swagger调试API，这两项需要填写正确。前者为服务文档的端口，ip。后者为基础路径，像我这里就是“/api/v1”。</li><li>在原文档中还有<code>securityDefinitions.basic</code>,<code>securityDefinitions.apikey</code>等，这些都是用来做认证的，我这里暂不展开。</li></ul><p>到这里，我们在<code>mian.go</code>同目录下执行<code>swag init</code>就可以自动生成文档，如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  swaggo-gin git:(master) ✗ swag init</span><br><span class="line">2019/01/12 21:29:14 Generate swagger docs....</span><br><span class="line">2019/01/12 21:29:14 Generate general API Info</span><br><span class="line">2019/01/12 21:29:14 create docs.go at  docs/docs.go</span><br></pre></td></tr></table></figure><p>然后我们导入这个自动生成的<code>docs</code>包，运行：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"github.com/gin-gonic/gin"</span></span><br><span class="line">	ginSwagger <span class="string">"github.com/swaggo/gin-swagger"</span></span><br><span class="line">	<span class="string">"github.com/swaggo/gin-swagger/swaggerFiles"</span></span><br><span class="line"></span><br><span class="line">	_ <span class="string">"github.com/razeencheng/demo-go/swaggo-gin/docs"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// @title Swagger Example API</span></span><br><span class="line"><span class="comment">// @version 1.0</span></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  swaggo-gin git:(master) ✗ go build</span><br><span class="line">➜  swaggo-gin git:(master) ✗ ./swaggo-gin</span><br><span class="line">[GIN-debug] [WARNING] Creating an Engine instance with the Logger and Recovery middleware already attached.</span><br><span class="line"></span><br><span class="line">[GIN-debug] [WARNING] Running <span class="keyword">in</span> <span class="string">"debug"</span> mode. Switch to <span class="string">"release"</span> mode <span class="keyword">in</span> production.</span><br><span class="line"> - using env:   <span class="built_in">export</span> GIN_MODE=release</span><br><span class="line"> - using code:  gin.SetMode(gin.ReleaseMode)</span><br><span class="line"></span><br><span class="line">[GIN-debug] GET    /api/v1/hello             --&gt; main.HandleHello (3 handlers)</span><br><span class="line">[GIN-debug] POST   /api/v1/login             --&gt; main.HandleLogin (3 handlers)</span><br><span class="line">[GIN-debug] POST   /upload                   --&gt; main.HandleUpload (4 handlers)</span><br><span class="line">[GIN-debug] GET    /list                     --&gt; main.HandleList (4 handlers)</span><br><span class="line">[GIN-debug] GET    /swagger/*any             --&gt; github.com/swaggo/gin-swagger.WrapHandler.func1 (4 handlers)</span><br><span class="line">[GIN-debug] Listening and serving HTTP on :8080</span><br></pre></td></tr></table></figure><p>浏览器打开<a href="http://127.0.0.1:8080/swagger/index.html" target="_blank" rel="noopener">http://127.0.0.1:8080/swagger/index.html</a>, 我们可以看到如下文档标题已经生成。</p><p><img data-src="https://st.razeen.cn/img/201901/jietu20190112-213823.png" alt></p><h4 id="在Handle函数上添加注释"><a href="#在Handle函数上添加注释" class="headerlink" title="在Handle函数上添加注释"></a>在Handle函数上添加注释</h4><p>接下来，我们需要在每个路由处理函数上加上注释，如：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// @Summary 测试SayHello</span></span><br><span class="line"><span class="comment">// @Description 向你说Hello</span></span><br><span class="line"><span class="comment">// @Tags 测试</span></span><br><span class="line"><span class="comment">// @Accept mpfd</span></span><br><span class="line"><span class="comment">// @Produce json</span></span><br><span class="line"><span class="comment">// @Param who query string true "人名"</span></span><br><span class="line"><span class="comment">// @Success 200 &#123;string&#125; string "&#123;"msg": "hello Razeen"&#125;"</span></span><br><span class="line"><span class="comment">// @Failure 400 &#123;string&#125; string "&#123;"msg": "who are you"&#125;"</span></span><br><span class="line"><span class="comment">// @Router /hello [get]</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HandleHello</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">	who := c.Query(<span class="string">"who"</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> who == <span class="string">""</span> &#123;</span><br><span class="line">		c.JSON(http.StatusBadRequest, gin.H&#123;<span class="string">"msg"</span>: <span class="string">"who are u?"</span>&#125;)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	c.JSON(http.StatusOK, gin.H&#123;<span class="string">"msg"</span>: <span class="string">"hello "</span> + who&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们再次<code>swag init</code>, 运行一下。</p><p><img data-src="https://st.razeen.cn/img/201901/jietu20190112-220025.png" alt></p><p>此时，该API的相关描述已经生成了，我们点击<code>Try it out</code>还可以直接测试该API。</p><p><img data-src="https://st.razeen.cn/img/201901/jietu20190112-220515.png" alt></p><p>是不是很好用，当然这并没有结束，这些注释字段，我们一个个解释。</p><p><img data-src="https://st.razeen.cn/img/201901/jietu20190112-223012.png" alt></p><p>这些注释对应出现在API文档的位置，我在上图中已经标出，这里我们主要详细说说下面参数：</p><h5 id="Tags"><a href="#Tags" class="headerlink" title="Tags"></a>Tags</h5><p>Tags 是用来给API分组的。</p><h5 id="Accept"><a href="#Accept" class="headerlink" title="Accept"></a>Accept</h5><p>接收的参数类型，支持表单(<code>mpfd</code>) , JSON(<code>json</code>)等，更多如下表。</p><h5 id="Produce"><a href="#Produce" class="headerlink" title="Produce"></a>Produce</h5><p>返回的数据结构，一般都是<code>json</code>, 其他支持如下表：</p><table><thead><tr><th>Mime Type</th><th>声明</th></tr></thead><tbody><tr><td>application/json</td><td>json</td></tr><tr><td>text/xml</td><td>xml</td></tr><tr><td>text/plain</td><td>plain</td></tr><tr><td>html</td><td>html</td></tr><tr><td>multipart/form-data</td><td>mpfd</td></tr><tr><td>application/x-www-form-urlencoded</td><td>x-www-form-urlencoded</td></tr><tr><td>application/vnd.api+json</td><td>json-api</td></tr><tr><td>application/x-json-stream</td><td>json-stream</td></tr><tr><td>application/octet-stream</td><td>octet-stream</td></tr><tr><td>image/png</td><td>png</td></tr><tr><td>image/jpeg</td><td>jpeg</td></tr><tr><td>image/gif</td><td>gif</td></tr></tbody></table><h5 id="Param"><a href="#Param" class="headerlink" title="Param"></a>Param</h5><p>参数，从前往后分别是：</p><blockquote><p>@Param who query string true “人名”</p><p>@Param <code>1.参数名</code> <code>2.参数类型</code> <code>3.参数数据类型</code> <code>4.是否必须</code> <code>5.参数描述</code> <code>6.其他属性</code></p></blockquote><ul><li><p>1.参数名</p><p>参数名就是我们解释参数的名字。</p></li><li><p>2.参数类型</p><p>参数类型主要有四种：</p><ul><li><p><code>path</code> 该类型参数直接拼接在URL中，如<a href="https://github.com/razeencheng/demo-go/blob/master/swaggo-gin/handle.go" target="_blank" rel="noopener">Demo</a>中<code>HandleGetFile</code>：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// @Param id path integer true &quot;文件ID&quot;</span><br></pre></td></tr></table></figure></li><li><p><code>query</code> 该类型参数一般是组合在URL中的，如<a href="https://github.com/razeencheng/demo-go/blob/master/swaggo-gin/handle.go" target="_blank" rel="noopener">Demo</a>中<code>HandleHello</code></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// @Param who query string true &quot;人名&quot;</span><br></pre></td></tr></table></figure></li><li><p><code>formData</code> 该类型参数一般是<code>POST,PUT</code>方法所用，如<a href="https://github.com/razeencheng/demo-go/blob/master/swaggo-gin/handle.go" target="_blank" rel="noopener">Demo</a>中<code>HandleLogin</code></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// @Param user formData string true &quot;用户名&quot; default(admin)</span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li><p><code>body</code> 当<code>Accept</code>是<code>JSON</code>格式时，我们使用该字段指定接收的JSON类型</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// @Param param body main.JSONParams true &quot;需要上传的JSON&quot;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>3.参数数据类型</p><p>数据类型主要支持一下几种：</p><ul><li>string (string)</li><li>integer (int, uint, uint32, uint64)</li><li>number (float32)</li><li>boolean (bool)</li></ul><p>注意，如果你是上传文件可以使用<code>file</code>, 但参数类型一定是<code>formData</code>, 如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// @Param file formData file true &quot;文件&quot;</span><br></pre></td></tr></table></figure></li><li><p>4.是否是必须</p><p>表明该参数是否是必须需要的，必须的在文档中会黑体标出，测试时必须填写。</p></li><li><p>5.参数描述</p><p>就是参数的一些说明</p></li><li><p>6.其他属性</p><p>除了上面这些属性外，我们还可以为该参数填写一些额外的属性，如枚举，默认值，值范围等。如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">枚举</span><br><span class="line">// @Param enumstring query string false &quot;string enums&quot; Enums(A, B, C)</span><br><span class="line">// @Param enumint query int false &quot;int enums&quot; Enums(1, 2, 3)</span><br><span class="line">// @Param enumnumber query number false &quot;int enums&quot; Enums(1.1, 1.2, 1.3)</span><br><span class="line"></span><br><span class="line">值添加范围</span><br><span class="line">// @Param string query string false &quot;string valid&quot; minlength(5) maxlength(10)</span><br><span class="line">// @Param int query int false &quot;int valid&quot; mininum(1) maxinum(10)</span><br><span class="line"></span><br><span class="line">设置默认值</span><br><span class="line">// @Param default query string false &quot;string default&quot; default(A)</span><br></pre></td></tr></table></figure><p>而且这些参数是可以组合使用的，如：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// @Param enumstring query string false &quot;string enums&quot; Enums(A, B, C) default(A)</span><br></pre></td></tr></table></figure></li></ul><h5 id="Success"><a href="#Success" class="headerlink" title="Success"></a>Success</h5><p>指定成功响应的数据。格式为：</p><blockquote><p>// @Success <code>1.HTTP响应码</code> <code>{2.响应参数类型}</code> <code>3.响应数据类型</code> <code>4.其他描述</code></p></blockquote><ul><li><p>1.HTTP响应码</p><p>也就是200，400，500那些。</p></li><li><p>2.响应参数类型 / 3.响应数据类型</p><p>返回的数据类型，可以是自定义类型，可以是json。</p><ul><li>自定义类型</li></ul><p>在平常的使用中，我都会返回一些指定的模型序列化JSON的数据，这时，就可以这么写：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// @Success 200 &#123;object&#125; main.File</span><br></pre></td></tr></table></figure><p>其中，模型直接用<code>包名.模型</code>即可。你会说，假如我返回模型数组怎么办？这时你可以这么写：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// @Success 200 &#123;anrry&#125; main.File</span><br></pre></td></tr></table></figure><ul><li>json</li></ul><p>将如你只是返回其他的数据格式可如下写：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// @Success 200 &#123;string&#125; string &quot;&quot;</span><br></pre></td></tr></table></figure></li><li><p>4.其他描述</p><p>可以添加一些说明。</p></li></ul><h5 id="Failure"><a href="#Failure" class="headerlink" title="Failure"></a>Failure</h5><p>​ 同Success。</p><h5 id="Router"><a href="#Router" class="headerlink" title="Router"></a>Router</h5><p>​ 指定路由与HTTP方法。格式为：</p><blockquote><p>// @Router <code>/path/to/handle</code> [<code>HTTP方法</code>]</p></blockquote><p>​ 不用加基础路径哦。</p><h3 id="生成文档与测试"><a href="#生成文档与测试" class="headerlink" title="生成文档与测试"></a>生成文档与测试</h3><p>其实上面已经穿插的介绍了。</p><p>在<code>main.go</code>下运行<code>swag init</code>即可生成和更新文档。</p><p>点击文档中的<code>Try it out</code>即可测试。 如果部分API需要登陆，可以Try登陆接口即可。</p><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>看到这里，基本可以使用了。但文档一般只是我们测试的时候需要，当我的产品上线后，接口文档是不应该给用户的，而且带有接口文档的包也会大很多（swaggo是直接build到二进制里的）。</p><p>想要处理这种情况，我们可以在编译的时候优化一下，如利用<code>build tag</code>来控制是否编译文档。</p><p>在<code>main.go</code>声明<code>swagHandler</code>,并在该参数不为空时才加入路由：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> swagHandler gin.HandlerFunc</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    </span><br><span class="line">    	<span class="keyword">if</span> swagHandler != <span class="literal">nil</span> &#123;</span><br><span class="line">			r.GET(<span class="string">"/swagger/*any"</span>, swagHandler)</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时,我们将该参数在另外加了<code>build tag</code>的包中初始化。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// +build doc</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	_ <span class="string">"github.com/razeencheng/demo-go/swaggo-gin/docs"</span></span><br><span class="line"></span><br><span class="line">	ginSwagger <span class="string">"github.com/swaggo/gin-swagger"</span></span><br><span class="line">	<span class="string">"github.com/swaggo/gin-swagger/swaggerFiles"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">	swagHandler = ginSwagger.WrapHandler(swaggerFiles.Handler)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后我们就可以使用<code>go build -tags &quot;doc&quot;</code>来打包带文档的包，直接<code>go build</code>来打包不带文档的包。</p><p>你会发现，即使我这么小的Demo,编译后的大小也要相差19M !</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">➜  swaggo-gin git:(master) ✗ go build</span><br><span class="line">➜  swaggo-gin git:(master) ✗ ll swaggo-gin</span><br><span class="line">-rwxr-xr-x  1 xxx  staff    15M Jan 13 00:23 swaggo-gin</span><br><span class="line">➜  swaggo-gin git:(master) ✗ go build -tags &quot;doc&quot;</span><br><span class="line">➜  swaggo-gin git:(master) ✗ ll swaggo-gin</span><br><span class="line">-rwxr-xr-x  1 xxx  staff    34M Jan 13 00:24 swaggo-gin</span><br></pre></td></tr></table></figure><p>文章到这里也就结束了，完整的<a href="https://github.com/razeencheng/demo-go/tree/master/swaggo-gin" target="_blank" rel="noopener">Demo地址在这里</a>。</p><p>相关链接</p><ul><li><a href="https://github.com/swaggo/swag" target="_blank" rel="noopener">Swaggo Github</a></li><li><a href="https://swagger.io/" target="_blank" rel="noopener">Swagger</a></li></ul>]]></content>
      <categories>
        <category>Go学习笔记</category>
        <category>Go工具</category>
      </categories>
      <tags>
        <tag>golang</tag>
        <tag>gin</tag>
        <tag>swagger</tag>
        <tag>restful-api</tag>
      </tags>
  </entry>
  <entry>
    <title>Go学习笔记（九） 计时器的生命周期[译]</title>
    <url>//post/go-timers-life-cycle.html</url>
    <content><![CDATA[<p><img data-src="https://st.razeen.cn/img/go-timer.png" alt="Illustration created for “A Journey With Go”, made from the original Go Gopher, created by Renee French."></p><p><em>全文基于GO 1.14</em></p><p>计时器在定时执行一些任务时很有用。Go内部依靠调度器来管理创建的计时器。而Go的调度程序是协作式的调度方式，这会让整个调度看起来比较复杂，因为goroutune必须自己停止（依赖channel阻塞或system call), 或者由调度器自己在某个调度点暂停。</p><a id="more"></a><p><em>有关抢占的更多信息，建议您阅读作者的文章<a href="https://medium.com/a-journey-with-go/go-goroutine-and-preemption-d6bc2aa2f4b7" target="_blank" rel="noopener">Go: Goroutine and Preemption</a></em>.</p><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p>下面是一段简单示例代码：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	sigs := <span class="built_in">make</span>(<span class="keyword">chan</span> os.Signal,<span class="number">1</span>)</span><br><span class="line">	signal.Notify(sigs,syscall.SIGINT,syscall.SIGTERM)</span><br><span class="line"></span><br><span class="line">	time.AfterFunc(time.Second, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="built_in">println</span>(<span class="string">"done"</span>)</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	&lt;- sigs</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>计时器创建后，他会保存到一个链接到当前P的计时器内部列表上，下图就是这段代码的表示形式：</p><p><img data-src="https://st.razeen.cn/img/timer-on-p.png" alt></p><p><em>有关G，M，P模型的更多信息，建议您阅读作者的文章<a href="https://medium.com/a-journey-with-go/go-goroutine-os-thread-and-cpu-management-2f5a5eaf518a" target="_blank" rel="noopener">Go: Goroutine, OS Thread and CPU Management</a></em></p><p>从图中可以看到，一旦创建了计时器，它就会注册一个内部回调，该内部回调将使用<code>go</code>回调用户函数，并将其转换为goroutine。</p><p>然后，将通过调度程序管理计时器。在每一轮调度中，它都会检查计时器是否准备好运行，如果准备就绪，则准备运行。实际上，由于Go调度程序本身不会运行任何代码，因此运行计时器的回调会将其goroutine排队到本地队列中。然后，当调度程序在队列中将其接收时，goroutine将运行。如选图所示：</p><p><img data-src="https://st.razeen.cn/img/timer-on-p2.png" alt></p><p>根据本地队列的大小，计时器运行可能会稍有延迟。不过，由于Go 1.14中的异步抢占，goroutines在运行时间10ms后会被抢占，降低了延迟的可能性。</p><h3 id="延迟"><a href="#延迟" class="headerlink" title="延迟"></a>延迟</h3><p>为了了解计时器可能存在的延迟，我们创造一个场景：从同一goroutine创建大量计时器。</p><p>由于计时器都链接到当前<code>P</code>，因此繁忙的<code>P</code>无法及时运行其链接的计时器。代码如下：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	trace.Start(os.Stderr)</span><br><span class="line">	<span class="keyword">defer</span> trace.Stop()</span><br><span class="line"></span><br><span class="line">	sigs := <span class="built_in">make</span>(<span class="keyword">chan</span> os.Signal,<span class="number">1</span>)</span><br><span class="line">	signal.Notify(sigs,syscall.SIGINT,syscall.SIGTERM)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//time.AfterFunc(time.Second, func() &#123;</span></span><br><span class="line">	<span class="comment">//	println("done")</span></span><br><span class="line">	<span class="comment">//&#125;)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> num <span class="keyword">int64</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i:=<span class="number">0</span>; i&lt; <span class="number">1e3</span> ; i++ &#123;</span><br><span class="line">		time.AfterFunc(time.Second, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			atomic.AddInt64(&amp;num,<span class="number">1</span>)</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	t:= <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="number">1e10</span>; i++ &#123;</span><br><span class="line">		t ++</span><br><span class="line">	&#125;</span><br><span class="line">	_ = t</span><br><span class="line"></span><br><span class="line">	&lt;- sigs</span><br><span class="line"></span><br><span class="line">	<span class="built_in">println</span>(num,<span class="string">"timers created,"</span>,t,<span class="string">"iterations done"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过go tool trace， 我们可以看到goroutine正在占用处理器：</p><p><img data-src="https://st.razeen.cn/img/timer-on-p3.png" alt></p><p>由于异步抢占的原因，代表正在运行的goroutine图形被分成了大量较小的块。</p><p>在这些块中，一个空间看起来比其他空间大。让我们放大一下：</p><p><img data-src="https://st.razeen.cn/img/timer-on-p4.png" alt></p><p>在该计时器需要运行时，就会发生改情况。此时，当前goroutine已被Go调度程序抢占和取代。调度程序将计时器转换为可运行的goroutine，如图所示。</p><p>但是，当前线程的Go调度程序并不是唯一运行计时器的调度程序。Go实施了一种计时器窃取策略，以确保在当前P繁忙时可以由另一个P运行计时器。由于异步抢占，它不太可能发生，但是在我们的示例中，由于使用了大量的计时器，它发生了。如下图所示：</p><p><img data-src="https://st.razeen.cn/img/timer-on-p5.png" alt></p><p>如果我们不考虑计时器窃取，将发生以下情况：</p><p><img data-src="https://st.razeen.cn/img/timer-on-p6.png" alt></p><p>持有计时器的所有goroutine都会添加到本地队列中。然后，由于 <code>P</code>之间的窃取，将准确的调度计时器。</p><p>所以，由于异步抢占和工作窃取，延迟几乎不可能发生。</p><blockquote><p>原文 <a href="https://medium.com/a-journey-with-go/go-timers-life-cycle-403f3580093a" target="_blank" rel="noopener">Go: Timers’ Life Cycle</a></p></blockquote>]]></content>
      <categories>
        <category>Go学习笔记</category>
      </categories>
      <tags>
        <tag>golang</tag>
        <tag>timer</tag>
      </tags>
  </entry>
  <entry>
    <title>利用 git hook 规范你的代码与 commit message</title>
    <url>//post/golang-and-git-commit-message-pre-commit.html</url>
    <content><![CDATA[<p>在团队协作时，由于个人编码习惯的差异，导致代码格式，风格都会有所不同，这就给代码审核带来一定的困难，更严重的是会导致整体的代码质量不可控。这时，我们有必要借助一些工具来约束我们的代码格式。在Go中，我们经常使用的工具有：</p><ul><li><code>goimports</code>: 自动导包；</li><li><code>gofmt</code> : 格式化我们的代码；</li><li><code>golint</code>: 检查代码命名，注释等；</li><li><code>go vet</code>: 静态错误检查。</li></ul><p>那么，我们可以利用这些工具来规范团队的代码风格。但如果每次手动执行这些命令，或者仅仅依靠IDE去检查，这是不靠谱的，因为人的行为本身是不靠谱的==。</p><p>于是，我们可以结合<code>git hook</code>, 强制执行这些检查，检查不通过，代码都无法提交，从而达到强一致性。</p><p>同时，结合上一篇<a href="https://razeencheng.com/post/conventional-commits-and-standard-version.html">&lt;&lt;规范git commit message与自动化版本控制&gt;&gt;</a>, 这里我们介绍一下利用pre-commit 约束commit-msg来约束我们的代码与git commit message。</p><a id="more"></a><p><em><a href="https://github.com/razeencheng/git-hooks" target="_blank" rel="noopener">源码在这里</a></em></p><h3 id="go-pre-commit-hook"><a href="#go-pre-commit-hook" class="headerlink" title="go pre-commit hook"></a>go pre-commit hook</h3><p>那么，我们怎么写一个pre-commit hook呢？</p><ul><li>首先，我们需要判断用户是否装上面这些工具；</li><li>然后，我们需要对git暂存区的代码(不包括vendor)，利用上面提到的四个工具进检查。</li></ul><p>直接上代码。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"></span><br><span class="line">has_errors=0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取git暂存的所有go代码</span></span><br><span class="line"><span class="comment"># --cached 暂存的</span></span><br><span class="line"><span class="comment"># --name-only 只显示名字</span></span><br><span class="line"><span class="comment"># --diff-filter=ACM 过滤暂存文件，A=Added C=Copied M=Modified, 即筛选出添加/复制/修改的文件</span></span><br><span class="line">allgofiles=$(git diff --cached --name-only --diff-filter=ACM | grep <span class="string">'.go$'</span>)</span><br><span class="line"></span><br><span class="line">gofiles=()</span><br><span class="line">godirs=()</span><br><span class="line"><span class="keyword">for</span> allfile <span class="keyword">in</span> <span class="variable">$&#123;allgofiles[@]&#125;</span>; <span class="keyword">do</span> </span><br><span class="line">    <span class="comment"># 过滤vendor的</span></span><br><span class="line">    <span class="comment"># 过滤prootobuf自动生产的文件</span></span><br><span class="line">    <span class="keyword">if</span> [[ <span class="variable">$allfile</span> == <span class="string">"vendor"</span>* || <span class="variable">$allfile</span> == *<span class="string">".pb.go"</span> ]];<span class="keyword">then</span></span><br><span class="line">        <span class="built_in">continue</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        gofiles+=(<span class="string">"<span class="variable">$allfile</span>"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 文件夹去重</span></span><br><span class="line">        existdir=0</span><br><span class="line">        dir=`<span class="built_in">echo</span> <span class="string">"<span class="variable">$allfile</span>"</span> |xargs -n1 dirname|sort -u`</span><br><span class="line">        <span class="keyword">for</span> somedir <span class="keyword">in</span> <span class="variable">$&#123;godirs[@]&#125;</span>; <span class="keyword">do</span></span><br><span class="line">            <span class="keyword">if</span> [[ <span class="variable">$dir</span> == <span class="variable">$somedir</span> ]]; <span class="keyword">then</span> </span><br><span class="line">                existdir=1</span><br><span class="line">                <span class="built_in">break</span></span><br><span class="line">            <span class="keyword">fi</span></span><br><span class="line">        <span class="keyword">done</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> [[ <span class="variable">$existdir</span> -eq 0 ]]; <span class="keyword">then</span> </span><br><span class="line">            godirs+=(<span class="string">"<span class="variable">$dir</span>"</span>)</span><br><span class="line">        <span class="keyword">fi</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line">[ -z <span class="string">"<span class="variable">$gofiles</span>"</span> ] &amp;&amp; <span class="built_in">exit</span> 0</span><br><span class="line"></span><br><span class="line"><span class="comment"># gofmt 格式化代码</span></span><br><span class="line">unformatted=$(gofmt -l <span class="variable">$&#123;gofiles[@]&#125;</span>)</span><br><span class="line"><span class="keyword">if</span> [ -n <span class="string">"<span class="variable">$unformatted</span>"</span> ]; <span class="keyword">then</span></span><br><span class="line">	<span class="built_in">echo</span> &gt;&amp;2 <span class="string">"gofmt FAIL:\n Run following command:"</span></span><br><span class="line">	<span class="keyword">for</span> f <span class="keyword">in</span> <span class="variable">$&#123;unformatted[@]&#125;</span>; <span class="keyword">do</span></span><br><span class="line">		<span class="built_in">echo</span> &gt;&amp;2 <span class="string">" gofmt -w <span class="variable">$PWD</span>/<span class="variable">$f</span>"</span></span><br><span class="line">	<span class="keyword">done</span></span><br><span class="line">	<span class="built_in">echo</span> <span class="string">"\n"</span></span><br><span class="line">	has_errors=1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># goimports 自动导包</span></span><br><span class="line"><span class="keyword">if</span> goimports &gt;/dev/null 2&gt;&amp;1; <span class="keyword">then</span>  <span class="comment"># 检测是否安装</span></span><br><span class="line">	unimports=$(goimports -l <span class="variable">$&#123;gofiles[@]&#125;</span>)</span><br><span class="line">	<span class="keyword">if</span> [ -n <span class="string">"<span class="variable">$unimports</span>"</span> ]; <span class="keyword">then</span></span><br><span class="line">		<span class="built_in">echo</span> &gt;&amp;2 <span class="string">"goimports FAIL:\nRun following command:"</span></span><br><span class="line">		<span class="keyword">for</span> f <span class="keyword">in</span> <span class="variable">$&#123;unimports[@]&#125;</span> ; <span class="keyword">do</span></span><br><span class="line">			<span class="built_in">echo</span> &gt;&amp;2 <span class="string">" goimports -w <span class="variable">$PWD</span>/<span class="variable">$f</span>"</span></span><br><span class="line">		<span class="keyword">done</span></span><br><span class="line">		<span class="built_in">echo</span> <span class="string">"\n"</span></span><br><span class="line">		has_errors=1</span><br><span class="line">	<span class="keyword">fi</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	<span class="built_in">echo</span> <span class="string">'Error: goimports not install. Run: "go get -u golang.org/x/tools/cmd/goimports"'</span> &gt;&amp;2</span><br><span class="line">	<span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># golint 代码规范检测</span></span><br><span class="line"><span class="keyword">if</span> golint &gt;/dev/null 2&gt;&amp;1; <span class="keyword">then</span>  <span class="comment"># 检测是否安装</span></span><br><span class="line">	lint_errors=<span class="literal">false</span></span><br><span class="line">	<span class="keyword">for</span> file <span class="keyword">in</span> <span class="variable">$&#123;gofiles[@]&#125;</span> ; <span class="keyword">do</span></span><br><span class="line">		lint_result=<span class="string">"<span class="variable">$(golint $file)</span>"</span> <span class="comment"># run golint</span></span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">test</span> -n <span class="string">"<span class="variable">$lint_result</span>"</span> ; <span class="keyword">then</span></span><br><span class="line">			<span class="built_in">echo</span> <span class="string">"golint '<span class="variable">$file</span>':\n<span class="variable">$lint_result</span>"</span></span><br><span class="line">			lint_errors=<span class="literal">true</span></span><br><span class="line">			has_errors=1</span><br><span class="line">		<span class="keyword">fi</span></span><br><span class="line">	<span class="keyword">done</span></span><br><span class="line">	<span class="keyword">if</span> [ <span class="variable">$lint_errors</span> = <span class="literal">true</span> ] ; <span class="keyword">then</span></span><br><span class="line">		<span class="built_in">echo</span> <span class="string">"\n"</span></span><br><span class="line">	<span class="keyword">fi</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	<span class="built_in">echo</span> <span class="string">'Error: golint not install. Run: "go get -u github.com/golang/lint/golint"'</span> &gt;&amp;2</span><br><span class="line">	<span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># go vet 静态错误检查</span></span><br><span class="line">show_vet_header=<span class="literal">true</span></span><br><span class="line"><span class="keyword">for</span> dir <span class="keyword">in</span> <span class="variable">$&#123;godirs[@]&#125;</span> ; <span class="keyword">do</span></span><br><span class="line">    vet=$(go vet <span class="variable">$PWD</span>/<span class="variable">$dir</span> 2&gt;&amp;1)</span><br><span class="line">    <span class="keyword">if</span> [ -n <span class="string">"<span class="variable">$vet</span>"</span> -a <span class="variable">$show_vet_header</span> = <span class="literal">true</span> ] ; <span class="keyword">then</span></span><br><span class="line">	<span class="built_in">echo</span> <span class="string">"govet FAIL:"</span></span><br><span class="line">	show_vet_header=<span class="literal">false</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">    <span class="keyword">if</span> [ -n <span class="string">"<span class="variable">$vet</span>"</span> ] ; <span class="keyword">then</span></span><br><span class="line">	<span class="built_in">echo</span> <span class="string">"<span class="variable">$vet</span>\n"</span></span><br><span class="line">	has_errors=1</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span> <span class="variable">$has_errors</span></span><br></pre></td></tr></table></figure><h3 id="commit-msg-hook"><a href="#commit-msg-hook" class="headerlink" title="commit-msg hook"></a>commit-msg hook</h3><p>结合上一篇的规范化git commit message提交，我们这里做几点限制：</p><ul><li>至少15个字符（15个字符都没有，提交信息肯定不详细)；</li><li>必须以<code>feat|fix|chore|docs</code>关键词开头，可选<code>(scope)</code> , 之后必须紧跟冒号和空格<code>:</code> ,之后就是具体的描述。</li></ul><p>直接上脚本：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 忽略merge request</span></span><br><span class="line">MERGE_MSG=`cat <span class="variable">$1</span> | egrep <span class="string">'^Merge branch*'</span>`</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">"<span class="variable">$MERGE_MSG</span>"</span> != <span class="string">""</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">exit</span> 0</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">COMMIT_MSG=`cat <span class="variable">$1</span> | egrep <span class="string">"^(feat|fix|docs|chore)(\(\w+\))?:\s(\S|\w)+"</span>`</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">"<span class="variable">$COMMIT_MSG</span>"</span> = <span class="string">""</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"Commit Message Irregular，Please check!\n"</span></span><br><span class="line">    <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$&#123;#COMMIT_MSG&#125;</span> -lt 15 ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"Commit Message Too Short，Please show me more detail!\n"</span></span><br><span class="line">    <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><h3 id="配置Hooks"><a href="#配置Hooks" class="headerlink" title="配置Hooks"></a>配置Hooks</h3><p><code>git hooks</code>已经写好了，我们开始配置。</p><p>首先进入你的项目，找到<code>.git/hooks</code>文件夹，可以看到很多<code>*.simple</code>结尾的文件，我们新增<code>commit-msg</code>和<code>pre-commit</code>文件，或者去掉<code>commit-msg.simple</code>和<code>pre-commit.simple</code>的<code>simple</code>后缀。</p><p>然后，我们分别用 <strong>go pre-commit hook</strong> 和 <strong>commit-msg hook</strong>两部分的脚本替换<code>pre-commit</code>和<code>commit-msg</code>的内容。</p><p>最后，我们给这两个文件执行权限。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chmod +x commit-msg pre-commit</span><br></pre></td></tr></table></figure><p>之后我们就可以正常使用了。</p><p><strong>一键安装</strong></p><p>用Mac电脑的童鞋，可以在需要支持的项目下面，一键安装。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -kSL https://raw.githubusercontent.com/razeencheng/git-hooks/master/install.sh | sh</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>开发实战总结</category>
      </categories>
      <tags>
        <tag>golang</tag>
        <tag>git hook</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang 中的 RESTful API 最佳实践</title>
    <url>//post/golang-and-restful-api.html</url>
    <content><![CDATA[<p>RESRful API已经流行很多年了，我也一直在使用它。最佳实践也看过不少，但当一个项目完成，再次回顾/梳理项目时，会发现很多API和规范还是多少有些出入。在这篇文章中，我们结合Go Web再次梳理一下RESTful API的相关最佳实践。</p><a id="more"></a><p><em><a href="https://github.com/razeencheng/demo-go/blob/master/restful-api/main.go" target="_blank" rel="noopener">示例完整代码在这里</a></em></p><h3 id="关于RESTful-API"><a href="#关于RESTful-API" class="headerlink" title="关于RESTful API"></a>关于RESTful API</h3><p>关于什么是RESTful API，不再累述。推荐几个相关链接。</p><ul><li><a href="https://www.ruanyifeng.com/blog/2011/09/restful.html" target="_blank" rel="noopener">理解RESTful架构</a></li><li><a href="https://restfulapi.net/" target="_blank" rel="noopener">REST API Tutorial</a></li></ul><h3 id="1-使用JSON"><a href="#1-使用JSON" class="headerlink" title="1.使用JSON"></a>1.使用JSON</h3><p>不管是接收还是返回数据都推荐使用JSON。</p><p>通常返回数据的格式有JSON和XML，但XML过于冗长，可读性差，而且各种语言的解析上也不如JSON，使用JSON的好处，显而易见。</p><p>而接收数据，我们这里也推荐使用JSON，对于后端开发而言，入参直接与模型绑定，省去冗长的参数解析能简化不少代码，而且JSON能更简单的传递一些更复杂的结构等。</p><p>正如示例代码中的这一段，我们以<code>gin</code>框架为例。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// HandleLogin doc</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HandleLogin</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">	param := &amp;LoginParams&#123;&#125;</span><br><span class="line">	<span class="keyword">if</span> err := c.BindJSON(param); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		c.JSON(http.StatusBadRequest, &amp;Resp&#123;Error: <span class="string">"parameters error"</span>&#125;)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 做一些校验</span></span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">	session := sessions.Default(c)</span><br><span class="line">	session.Set(sessionsKey, param.UserID)</span><br><span class="line">	session.Save()</span><br><span class="line">	c.JSON(http.StatusOK, &amp;Resp&#123;Data: <span class="string">"login succeed"</span>&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过<code>c.BindJSON</code>,轻松的将入参于模型<code>LoginParams</code>绑定；通过<code>c.JSON</code>轻松的将数据JSON序列化返回。</p><p>但所有接口都必须用JSON么？那也未必。比如文件上传，这时我们使用<code>FormData</code>比把文件base64之类的放到JSON里面更高效。</p><h3 id="2-路径中不包含动词"><a href="#2-路径中不包含动词" class="headerlink" title="2.路径中不包含动词"></a>2.路径中不包含动词</h3><p>我们的HTTP请求方法中已经有<code>GET</code>,<code>POST</code>等这些动作了，完全没有必要再路径中加上动词。</p><p>我们常用HTTP请求方法包括<code>GET</code>,<code>POST</code>,<code>PUT</code>和<code>DELETE</code>, 这也对应了我们经常需要做的数据库操作。<code>GET</code>查找/获取资源，<code>POST</code>新增资源，<code>PUT</code>修改资源，<code>DELETE</code>删除资源。</p><p>如下，这些路径中没有任何动词，简洁明了。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取文章列表</span></span><br><span class="line">v1.GET(<span class="string">"/articles"</span>, HandleGetArticles)</span><br><span class="line"><span class="comment">// 发布文章</span></span><br><span class="line">v1.POST(<span class="string">"/articles"</span>, HandlePostArticles)</span><br><span class="line"><span class="comment">// 修改文章</span></span><br><span class="line">v1.PUT(<span class="string">"/articles"</span>, HandleUpdateArticles)</span><br><span class="line"><span class="comment">// 删除文章</span></span><br><span class="line">v1.DELETE(<span class="string">"/articles/:id"</span>, HandleDeleteArticles)</span><br></pre></td></tr></table></figure><h3 id="3-路径中对应资源用复数"><a href="#3-路径中对应资源用复数" class="headerlink" title="3.路径中对应资源用复数"></a>3.路径中对应资源用复数</h3><p>就像我们上面这段代码，<code>articles</code>对于的是我们的文章资源，背后就是一张数据库表<code>articles</code>, 所以操作这个资源的应该都用复数形式。</p><h3 id="4-次要资源可分层展示"><a href="#4-次要资源可分层展示" class="headerlink" title="4.次要资源可分层展示"></a>4.次要资源可分层展示</h3><p>一个博客系统中，最主要的应该是文章了，而评论应该是其子资源，我们可以评论嵌套在它的父资源后面，如：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取评论列表</span></span><br><span class="line">v1.GET(<span class="string">"/articles/:articles_id/comments"</span>, HandleGetComments)</span><br><span class="line"><span class="comment">// 添加评论</span></span><br><span class="line">v1.POST(<span class="string">"/articles/:articles_id/comments"</span>, HandleAddComments)</span><br><span class="line"><span class="comment">// 修改评论</span></span><br><span class="line">v1.PUT(<span class="string">"/articles/:articles_id/comments/:id"</span>, HandleUpdateComments)</span><br><span class="line"><span class="comment">// 删除评论</span></span><br><span class="line">v1.DELETE(<span class="string">"/articles/:articles_id/comments/:id"</span>, HandleDeleteComments)</span><br></pre></td></tr></table></figure><p>那么，我们需要获取所有文章的评论怎么办？可以这么写：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">v1.GET(<span class="string">"/articles/-/comments"</span>, HandleGetComments)</span><br></pre></td></tr></table></figure><p>但这也不是决对的，资源虽然有层级关系，但这种层级关系不宜太深，个人感觉两层最多了，如果超过，可以直接拿出来放在一级。</p><h3 id="5-分页、排序、过滤"><a href="#5-分页、排序、过滤" class="headerlink" title="5.分页、排序、过滤"></a>5.分页、排序、过滤</h3><p>获取列表时，会使用到分页、排序过滤。一般：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">?page=1&amp;page_size=10  <span class="comment"># 指定页面page与分页大小page_size</span></span><br><span class="line">?sort=-create_at,+author <span class="comment"># 按照创建时间create_at降序，作者author升序排序</span></span><br><span class="line">?title=helloworld <span class="comment"># 按字段title搜索</span></span><br></pre></td></tr></table></figure><h3 id="6-统一数据格式"><a href="#6-统一数据格式" class="headerlink" title="6.统一数据格式"></a>6.统一数据格式</h3><p>不管是路径的格式，还是参数的格式，还是返回值的格式建议统一形式。</p><p>一般常用的格式有<code>蛇形</code>,<code>大驼峰</code>和<code>小驼峰</code>，个人比较喜欢<code>蛇形</code>。Anyway, 不管哪种，只要统一即可。</p><p>除了参数的命名统一外，返回的数据格式，最好统一，方便前端对接。</p><p>如下，我们定义<code>Resp</code>为通用返回数据结构，<code>Data</code>中存放反会的数据，如果出错，将错误信息放在<code>Error</code>中。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Resp doc</span></span><br><span class="line"><span class="keyword">type</span> Resp <span class="keyword">struct</span> &#123;</span><br><span class="line">	Data  <span class="keyword">interface</span>&#123;&#125; <span class="string">`json:"data"`</span></span><br><span class="line">	Error <span class="keyword">string</span>      <span class="string">`json:"error"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 登陆成功返回</span></span><br><span class="line">  c.JSON(http.StatusOK, &amp;Resp&#123;Data: <span class="string">"login succeed"</span>&#125;)</span><br><span class="line"><span class="comment">// 查询列表</span></span><br><span class="line">	c.JSON(http.StatusOK, &amp;Resp&#123;Data: <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;</span><br><span class="line">		<span class="string">"result"</span>: tempStorage,</span><br><span class="line">		<span class="string">"total"</span>:  <span class="built_in">len</span>(tempStorage),</span><br><span class="line">	&#125;&#125;)</span><br><span class="line"><span class="comment">// 参数错误</span></span><br><span class="line">	c.JSON(http.StatusBadRequest, &amp;Resp&#123;Error: <span class="string">"parameters error"</span>&#125;)</span><br></pre></td></tr></table></figure><h3 id="7-善用HTTP状态码"><a href="#7-善用HTTP状态码" class="headerlink" title="7.善用HTTP状态码"></a>7.善用HTTP状态码</h3><p>HTTP状态码有很多，我们没有必要也不可能全部用上，常用如下：</p><ul><li>200 StatusOK - 只有成功请求都返回200。</li><li>400 StatusBadRequest - 当出现参数不对，用户参数校验不通过时，给出该状态，并返回Error</li><li>401 StatusUnauthorized - 没有登陆/经过认证</li><li>403 Forbidden - 服务端拒绝授权(如密码错误)，不允许访问</li><li>404 Not Found - 路径不存在</li><li>500 Internal Server Error - 所请求的服务器遇到意外的情况并阻止其执行请求</li><li>502 Bad Gateway - 网关或代理从上游接收到了无效的响应</li><li>503 Service Unavailable - 服务器尚未处于可以接受请求的状态</li></ul><p>其中<code>502</code>,<code>503</code>，我们写程序时并不会明确去抛出。所以我们平常用6个状态码已经能很好的展示服务端状态了。</p><p>同时，我们将状态与返回值对应起来，<code>200</code>状态下，返回<code>Data</code>数据；其他状态返回<code>Error</code>。</p><h3 id="8-API版本化"><a href="#8-API版本化" class="headerlink" title="8.API版本化"></a>8.API版本化</h3><p>正如Demo中所示，我们将路由分组到了<code>/api/v1</code>路径下面，版本化API。如果后续的服务端升级，但可能仍有很大部分客户端请求未升级，依然请求老版本的API，那么我们只需要增加<code>/api/v2</code>，然后在该路径下为已升级的客户端提供服务。这样，我们就做到了API的版本控制，可以平滑的从一个版本切换到另外一个版本。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">v1 := r.Group(<span class="string">"/api/v1"</span>)</span><br><span class="line">&#123;</span><br><span class="line">	v1.POST(<span class="string">"/login"</span>, HandleLogin)</span><br><span class="line">	v1.GET(<span class="string">"/articles"</span>, HandleGetArticles)</span><br><span class="line">	v1.GET(<span class="string">"/articles/:id/comments"</span>, HandleGetComments)</span><br><span class="line">   <span class="comment">// ....</span></span><br></pre></td></tr></table></figure><h3 id="9-统一-‘-‘-开头"><a href="#9-统一-‘-‘-开头" class="headerlink" title="9. 统一 ‘/‘ 开头"></a>9. 统一 ‘/‘ 开头</h3><p>所以路由中，路径都以’/‘开头，虽然框架会为我们做这件事，但还是建议统一加上。</p><h3 id="10-增加-更新操作-返回资源"><a href="#10-增加-更新操作-返回资源" class="headerlink" title="10. 增加/更新操作 返回资源"></a>10. 增加/更新操作 返回资源</h3><p>对于<code>POST</code>,<code>PUT</code>操作，建议操作后，返回更新后的资源。</p><h3 id="11-使用HTTPS"><a href="#11-使用HTTPS" class="headerlink" title="11. 使用HTTPS"></a>11. 使用HTTPS</h3><p>对于暴露出去的接口/OpenAPI，一定使用HTTPS。一般时候，我们可以直接在服务前面架设一个WebServer，在WebServer内部署证书即可。当然，如果是直接由后端暴露出的接口，有必要直接在后端开启HTTPS！</p><h3 id="12-规范的API文档"><a href="#12-规范的API文档" class="headerlink" title="12. 规范的API文档"></a>12. 规范的API文档</h3><p>对于我们这种前后端分离的架构，API文档是很重要。在Go中，我们很容易的能用swag结合代码注释自动生成API文档，在<a href="https://razeencheng.com/post/go-swagger.html"> &lt;使用swaggo自动生成Restful API文档&gt;</a>中，我详细的介绍了怎么生成以及怎么写注释。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>API写的好不好，重要的还是看是否遵循WEB标准和保持一致性，最终目的也是让这些API更清晰，易懂，安全，希望这些建议对你有所帮助。</p>]]></content>
      <categories>
        <category>Go学习笔记</category>
        <category>Go实战</category>
      </categories>
      <tags>
        <tag>golang</tag>
        <tag>restful api</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang CGO Mac 交叉编译 Windows</title>
    <url>//post/golang-cgo-mac-win-cross-compilation.html</url>
    <content><![CDATA[<p>有个小项目，使用sqlite3数据库，需要跨平台编译。我在Mac上开发的，现在编译一份windows平台的。</p><a id="more"></a><h3 id="pre"><a href="#pre" class="headerlink" title="pre"></a>pre</h3><p>编译的参数</p><p>GOOS：目标平台的操作系统（darwin、freebsd、linux、windows）<br>GOARCH：目标平台的体系架构（386、amd64、arm）<br>CGO_ENABLED： 是否开启CGO（事实证明交叉编译不支持CGO）</p><h3 id="section-1"><a href="#section-1" class="headerlink" title="section 1"></a>section 1</h3><p>首先，我想到的是：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ GOOS=windows GOARCH=386 CGO_ENABLED=1 go build  -o hello.exe</span><br></pre></td></tr></table></figure><p>嗯，不出所料：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># runtime/cgo</span></span><br><span class="line">gcc_libinit_windows.c:7:10: fatal error: <span class="string">'windows.h'</span> file not found</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">然后，google一下， `fatal error: <span class="string">'windows.h'</span> file not found`。 </span><br><span class="line"></span><br><span class="line">嗯，stackoverflow，github...都瞄了一下，各种c库问题，各种解决方法参差不齐。</span><br><span class="line"></span><br><span class="line">我这个人比较懒，决定换种解决方法。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">### section 2</span></span><br><span class="line"></span><br><span class="line">联想到以前使用sqlite3项目需要交叉编译Linux平台的，我们采用过docker内编译的方法，我这里也尝试一下。</span><br><span class="line"></span><br><span class="line">``` bash</span><br><span class="line">$ docker run --rm -i -v <span class="variable">$GOPATH</span>:/go  golang:1.11 bash</span><br><span class="line">$ GOOS=windows GOARCH=386 CGO_ENABLED=1 go build  -o hello.exe</span><br><span class="line"></span><br><span class="line"><span class="comment"># runtime/cgo</span></span><br><span class="line">gcc: error: unrecognized <span class="built_in">command</span> line option <span class="string">'-mthreads'</span>; did you mean <span class="string">'-pthread'</span>?</span><br></pre></td></tr></table></figure><p>还是存在问题。 那么继续Google一下。</p><p>在github <code>go-sqlite3</code>下我们发现有人提了相同的<a href="https://github.com/mattn/go-sqlite3/issues/303" target="_blank" rel="noopener">issue</a></p><p>有code反应，该如下解决：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ apt-get update</span><br><span class="line">$ apt-get install gcc-multilib</span><br><span class="line">$ apt-get install gcc-mingw-w64</span><br><span class="line"></span><br><span class="line">$ GOOS=windows GOARCH=386  CGO_ENABLED=1 CXX_FOR_TARGET=i686-w64-mingw32-g++ CC_FOR_TARGET=i686-w64-mingw32-gcc go build -o hello.exe</span><br></pre></td></tr></table></figure><p>之后再次尝试，依然还是同样的问题。</p><h3 id="section-3"><a href="#section-3" class="headerlink" title="section 3"></a>section 3</h3><p>Google一番未果，寻求同事帮助。</p><p>同事：“这问题我遇到过”</p><p>我：“怎么解决的”</p><p>同事： “没法解决，用sqlite3，mac上交叉编译不了win的”</p><p>我：“。。。”</p><p>同事：“装个Win虚拟机，直接在win上编译就OK了”</p><p>我：“。。。”</p><p>最后，顺利的在win虚拟机内编译成功该程序。</p><p>End</p>]]></content>
      <categories>
        <category>Go学习笔记</category>
        <category>Go实战</category>
      </categories>
      <tags>
        <tag>golang</tag>
        <tag>交叉编译</tag>
        <tag>cgo</tag>
      </tags>
  </entry>
  <entry>
    <title>CentOS 安装 tshark 抓包工具</title>
    <url>//post/how-to-install-tshark-on-centos.html</url>
    <content><![CDATA[<p>准备在服务器上用<code>tshark</code>抓包，分析一下数据。直接<code>yum install tshark</code>却发现没有这个包。网上搜索一下，各种奇葩安装方式，又是安装<code>apt</code>？又是安装各种环境？我相信既然CentOS已经有了<code>yum</code>这么好的包管理工具，那么一定有更简单的方式。</p><a id="more"></a><p>最后只好在<code>Google</code>上直接用我这蹩脚的英文搜索一下。果然，一句<code>how to install tshark on centos</code>顺利解决了我的问题。</p><p>原来一直是自己对<code>yum</code>这个命令了解太少了，平时只会<code>yum install</code>,<code>yum update</code> :first_quarter_moon_with_face: 。那么到底故事如何，客官且听我细细道来。</p><p>当我试图直接安装时：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ yum install tshark</span><br><span class="line">已加载插件：fastestmirror</span><br><span class="line">Loading mirror speeds from cached hostfile</span><br><span class="line">没有可用软件包 tshark。</span><br><span class="line">错误：无须任何处理</span><br></pre></td></tr></table></figure><p>那么，该怎么办呢？ 原来<code>yum</code>提供了搜索功能。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ yum whatprovides *tshark*</span><br><span class="line">已加载插件：fastestmirror</span><br><span class="line">Loading mirror speeds from cached hostfile</span><br><span class="line">base/7/x86_64/filelists_db                                                    | 6.9 MB  00:00:00</span><br><span class="line">epel/x86_64/filelists                                                         |  10 MB  00:00:00</span><br><span class="line">extras/7/x86_64/filelists_db                                                  | 524 kB  00:00:00</span><br><span class="line">updates/7/x86_64/filelists_db                                                 | 2.1 MB  00:00:00</span><br><span class="line">1:bash-completion-extras-2.1-11.el7.noarch : Additional programmable completions <span class="keyword">for</span> Bash</span><br><span class="line">源    ：epel</span><br><span class="line">匹配来源：</span><br><span class="line">文件名    ：/usr/share/bash-completion/completions/tshark</span><br><span class="line"></span><br><span class="line">wireshark-1.10.14-14.el7.i686 : Network traffic analyzer</span><br><span class="line">源    ：base</span><br><span class="line">匹配来源：</span><br><span class="line">文件名    ：/usr/sbin/tshark</span><br><span class="line">文件名    ：/usr/share/wireshark/tshark.html</span><br><span class="line">文件名    ：/usr/share/man/man1/tshark.1.gz</span><br><span class="line"></span><br><span class="line">wireshark-1.10.14-14.el7.x86_64 : Network traffic analyzer</span><br><span class="line">源    ：base</span><br><span class="line">匹配来源：</span><br><span class="line">文件名    ：/usr/sbin/tshark</span><br><span class="line">文件名    ：/usr/share/wireshark/tshark.html</span><br><span class="line">文件名    ：/usr/share/man/man1/tshark.1.gz</span><br></pre></td></tr></table></figure><p>我们可以看到<code>wireshark</code>包已经包含了<code>tshark</code>包。</p><p>接下来就是我们熟悉的步骤了==。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ yum install wireshark</span><br><span class="line">已加载插件：fastestmirror</span><br><span class="line">Loading mirror speeds from cached hostfile</span><br><span class="line">正在解决依赖关系</span><br><span class="line">--&gt; 正在检查事务</span><br><span class="line">---&gt; 软件包 wireshark.x86_64.0.1.10.14-14.el7 将被 安装</span><br><span class="line">--&gt; 正在处理依赖关系 libsmi.so.2()(64bit)，它被软件包 wireshark-1.10.14-14.el7.x86_64 需要</span><br><span class="line">--&gt; 正在处理依赖关系 libcares.so.2()(64bit)，它被软件包 wireshark-1.10.14-14.el7.x86_64 需要</span><br><span class="line">--&gt; 正在检查事务</span><br><span class="line">---&gt; 软件包 c-ares.x86_64.0.1.10.0-3.el7 将被 安装</span><br><span class="line">---&gt; 软件包 libsmi.x86_64.0.0.4.8-13.el7 将被 安装</span><br><span class="line">--&gt; 解决依赖关系完成</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">已安装:</span><br><span class="line">  wireshark.x86_64 0:1.10.14-14.el7</span><br><span class="line"></span><br><span class="line">作为依赖被安装:</span><br><span class="line">	c-ares.x86_64 0:1.10.0-3.el7                                                                        libsmi.x86_64 0:0.4.8-13.el7</span><br><span class="line"></span><br><span class="line">完毕！</span><br></pre></td></tr></table></figure><p>最后我们验证一下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"> $ tshark -v</span><br><span class="line">TShark 1.10.14 (Git Rev Unknown from unknown)</span><br><span class="line"></span><br><span class="line">Copyright 1998-2015 Gerald Combs &lt;gerald@wireshark.org&gt; and contributors.</span><br><span class="line">This is free software; see the <span class="built_in">source</span> <span class="keyword">for</span> copying conditions. There is NO</span><br><span class="line">warranty; not even <span class="keyword">for</span> MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</span><br><span class="line"></span><br><span class="line">Compiled (64-bit) with GLib 2.50.3, with libpcap, with libz 1.2.7, with POSIX</span><br><span class="line">capabilities (Linux), without libnl, with SMI 0.4.8, with c-ares 1.10.0, with</span><br><span class="line">Lua 5.1, without Python, with GnuTLS 3.3.26, with Gcrypt 1.5.3, with MIT</span><br><span class="line">Kerberos, without GeoIP.</span><br><span class="line"></span><br><span class="line">Running on Linux 3.10.0-693.11.1.el7.x86_64, with locale zh_CN.UTF-8, with</span><br><span class="line">libpcap version 1.5.3, with libz 1.2.7.</span><br><span class="line">Intel(R) Xeon(R) CPU E5-2682 v4 @ 2.50GHz</span><br><span class="line"></span><br><span class="line">Built using gcc 4.8.5 20150623 (Red Hat 4.8.5-16).</span><br></pre></td></tr></table></figure><p>写这边文章并不只是只是为了说明<code>tshark</code>怎么在centos怎么安装，更多的是有时候我们需要扩展自己的知识面，避免重复造轮子。</p>]]></content>
      <categories>
        <category>Linux 点滴</category>
      </categories>
      <tags>
        <tag>centos</tag>
        <tag>tshark</tag>
        <tag>wireshark</tag>
        <tag>yum</tag>
      </tags>
  </entry>
  <entry>
    <title>gRPC在Go中的使用（一）Protocol Buffers语法与相关使用</title>
    <url>//post/how-to-use-grpc-in-golang-01.html</url>
    <content><![CDATA[<p>在gRPC官网用了一句话来介绍:“一个高性能、开源的通用RPC框架”，同时介绍了其四大特点：</p><ul><li>定义简单</li><li>支持多种编程语言多种平台</li><li>快速启动和缩放</li><li>双向流媒体和集成身份验证</li></ul><a id="more"></a><p>在<code>gRPC在go中使用</code>系列中，关于其简介与性能我就不多介绍，相信在社区也有很多关于这些的讨论。这里我主要从三个层次来总结我以往在Go中使用gRPC的一些经验，主要分为：</p><ol><li>Protocol Buffers语法与相关使用</li><li>gRPC实现简单通讯</li><li>gRPC服务认证与双向流通讯</li></ol><p>*<em>注:下面Protocol Buffers简写protobuf.</em></p><p>这篇我们先介绍protobuf的相关语法、怎么书写<code>.proto</code>文件以及go代码生成。</p><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>要熟练的使用GRPC，protobuf的熟练使用必不可少。</p><p>gRPC使用<a href="https://github.com/google/protobuf" target="_blank" rel="noopener">protobuf</a>来定义服务。protobuf是由Google开发的一种数据序列化协议，可以把它想象成是XML或JSON格式，但更小，更快更简洁。而且一次定义，可生成多种语言的代码。</p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>首先我们需要编写一些<code>.proto</code>文件，定义我们在程序中需要处理的结构化数据。我们直接从一个实例开始讲起，下面是一个proto文件：</p><figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line">syntax = <span class="string">"proto3"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">option</span> go_package = <span class="string">"github.com/razeencheng/demo-go/grpc/demo1/helloworld"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> helloworld;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"github.com/golang/protobuf/ptypes/any/any.proto"</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">HelloWorldRequest</span> </span>&#123;</span><br><span class="line">  <span class="built_in">string</span> greeting = <span class="number">1</span>;</span><br><span class="line">  map&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; infos  = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">HelloWorldResponse</span> </span>&#123;</span><br><span class="line">  <span class="built_in">string</span> reply = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">repeated</span> google.protobuf.Any details = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">service</span> <span class="title">HelloWorldService</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">rpc</span> SayHelloWorld(HelloWorldRequest) <span class="keyword">returns</span> (HelloWorldResponse)&#123;&#125;</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><h4 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h4><p>文件的开头<code>syntax=&quot;proto3&quot;</code>也就指明版本，主要有<code>proto2</code>与<code>proto3</code>,他们在语法上有一定的差异，我这里主要使用的是后者。</p><h4 id="包名"><a href="#包名" class="headerlink" title="包名"></a>包名</h4><p>第二行，指定生成go文件的包名，可选项，默认使用第三行包名。</p><p>第三行，包名。</p><h4 id="导包"><a href="#导包" class="headerlink" title="导包"></a>导包</h4><p>第四行，类似你写go一样，protobuf也可以导入其他的包。</p><h4 id="消息定义"><a href="#消息定义" class="headerlink" title="消息定义"></a>消息定义</h4><p>后面message开头的两个结构就是我们需要传递的消息类型。所有的消息类型都是以<code>message</code>开始，然后定义类型名称。结构内字段的定义为<code>字段规则 字段类型 字段名=字段编号</code></p><ul><li>字段规则主要有 <code>singular</code>和<code>repeated</code>。如其中<code>greeting</code>和<code>reply</code>的字段规则为<code>singular</code>,允许该消息中出现0个或1个该字段(但不能超过一个)，而像<code>details</code>字段允许重复任意次数。其实对应到go里面也就是基本类型和切片类型。</li><li>字段类型，下表是proto内类型与go类型的对应表。</li></ul><table><thead><tr><th>.proto Type</th><th>Notes</th><th>Go Type</th></tr></thead><tbody><tr><td>double</td><td></td><td>float64</td></tr><tr><td>float</td><td></td><td>float32</td></tr><tr><td>int32</td><td>使用可变长度编码。 无效编码负数 - 如果您的字段可能具有负值， 请改用sint32。</td><td>int32</td></tr><tr><td>int64</td><td>使用可变长度编码。 无效编码负数 - 如果您的字段可能具有负值，请改用sint64。</td><td>int64</td></tr><tr><td>uint32</td><td>使用可变长度编码。</td><td>uint32</td></tr><tr><td>uint64</td><td>使用可变长度编码。</td><td>uint64</td></tr><tr><td>sint32</td><td>使用可变长度编码。 带符号的int值。 这些比常规的int32更有效地编码负数。</td><td>int32</td></tr><tr><td>sint64</td><td>使用可变长度编码。 带符号的int值。 这些比常规的int64更有效地编码负数。</td><td>int64</td></tr><tr><td>fixed32</td><td>总是四个字节。 如果值通常大于228，则比uint32效率更高。</td><td>uint32</td></tr><tr><td>fixed64</td><td>总是八个字节。 如果值通常大于256，则会比uint64更高效。</td><td>uint64</td></tr><tr><td>sfixed32</td><td>总是四个字节。</td><td>int32</td></tr><tr><td>sfixed64</td><td>总是八个字节。</td><td>int64</td></tr><tr><td>bool</td><td></td><td>bool</td></tr><tr><td>string</td><td>字符串必须始终包含UTF-8编码或7位ASCII文本。</td><td>string</td></tr><tr><td>bytes</td><td>可能包含任何字节序列。</td><td>[]byte</td></tr></tbody></table><p>看到这里你也许会疑惑，go里面的切片，map，接口等类型我怎么定义呢？别急，下面一一替你解答。</p><p>1.map类型，<code>HelloWorldRequest</code>的<code>infos</code>就是一个map类型，它的结构为<code>map&lt;key_type, value_type&gt; map_field = N</code> 但是在使用的时候你需要注意map类型不能<code>repetead</code>。</p><p>2.切片类型，我们直接定义其规则为<code>repeated</code>就可以了。就像<code>HelloWorldResponse</code>中的<code>details</code>字段一样，它就是一个切片类型。那么你会问了它是什么类型的切片？这就看下面了~</p><p>3.接口类型在proto中没有直接实现，但在<a href="https://github.com/golang/protobuf/blob/master/ptypes/any/any.proto" target="_blank" rel="noopener">google/protobuf/any.proto</a>中定义了一个<code>google.protobuf.Any</code>类型，然后结合<a href="https://github.com/golang/protobuf/blob/master/ptypes/any.go" target="_blank" rel="noopener">protobuf/go</a>也算是曲线救国了~</p><ul><li><p>字段编号</p><p>最后的1，2代表的是每个字段在该消息中的唯一标签，在与消息二进制格式中标识这些字段，而且当你的消息在使用的时候该值不能改变。1到15都是用一个字节编码的，通常用于标签那些频繁发生修改的字段。16到2047用两个字节编码，最大的是2^29-1(536,870,911)，其中19000-19999为预留的，你也不可使用。</p></li></ul><h4 id="服务定义"><a href="#服务定义" class="headerlink" title="服务定义"></a>服务定义</h4><p>如果你要使用RPC(远程过程调用)系统的消息类型，那就需要定义RPC服务接口，protobuf编译器将会根据所选择的不同语言生成服务接口代码及存根。就如：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">service HelloWorldService &#123;</span><br><span class="line">  rpc SayHelloWorld(HelloWorldRequest) returns (HelloWorldResponse)&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>protobuf编译器将产生一个抽象接口<code>HelloWorldService</code>以及一个相应的存根实现。存根将所有的调用指向RpcChannel(SayHelloWorld)，它是一个抽象接口，必须在RPC系统中对该接口进行实现。具体如何使用，将在下一篇博客中详细介绍。</p><h3 id="生成Go代码"><a href="#生成Go代码" class="headerlink" title="生成Go代码"></a>生成Go代码</h3><h4 id="安装protoc"><a href="#安装protoc" class="headerlink" title="安装protoc"></a>安装protoc</h4><p>首先要安装<code>protoc</code>,可直接到<a href="https://github.com/google/protobuf/releases/tag/v3.0.0" target="_blank" rel="noopener">这里</a>下载二进制安装到 <code>$PATH</code>里面，也可以直接下载源码编译。除此之外，你还需要安装go的proto插件<code>protoc-gen-go</code>。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// mac terminal</span></span><br><span class="line"><span class="keyword">go</span> get -u github.com/golang/protobuf/&#123;proto,protoc-gen-<span class="keyword">go</span>&#125;</span><br><span class="line"><span class="comment">// win powershell</span></span><br><span class="line"><span class="keyword">go</span> get -u github.com/golang/protobuf/proto</span><br><span class="line"><span class="keyword">go</span> get -u github.com/golang/protobuf/protoc-gen-<span class="keyword">go</span></span><br></pre></td></tr></table></figure><h4 id="生成go代码"><a href="#生成go代码" class="headerlink" title="生成go代码"></a>生成go代码</h4><p>接下来，使用<code>protoc</code>命令即可生成。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">### mac terminal</span></span><br><span class="line">protoc -I <span class="variable">$&#123;GOPATH&#125;</span>/src --go_out=plugins=grpc:<span class="variable">$&#123;GOPATH&#125;</span>/src <span class="variable">$&#123;GOPATH&#125;</span>/src/github.com/razeencheng/demo-go/grpc/demo1/helloworld/hello_world.proto</span><br><span class="line"><span class="comment">### win powershell</span></span><br><span class="line">protoc -I <span class="variable">$env</span>:GOPATH\src --go_out=plugins=grpc:<span class="variable">$env</span>:GOPATH\src <span class="variable">$env</span>:GOPATH\src\github.com\razeencheng\demo-go\grpc\demo1\helloworld\hello_world.proto</span><br></pre></td></tr></table></figure><p>如上所示 <code>-I</code>指定搜索proto文件的目录,<code>--go_out=plugins=grpc:</code>指定生成go代码的文件夹，后面就是需要生成的proto文件路径。</p><blockquote><p><em>注意：</em> 如果你使用到了其他包的结构，<code>-I</code>需要将该资源包括在内。</p><p>例如我导入了<code>github.com/golang/protobuf/ptypes/any/any.proto</code> 我首先需要</p><p><code>go get -u github.com/golang/protobuf</code>获取该包，然后在使用时资源路径(<code>-I</code>)直接为<code>GOPATH\src</code>。</p></blockquote><p>最后生成的<code>hello-world.pb.go</code>文件。内容大概如下图所示，点<a href="https://github.com/razeencheng/demo-go/blob/master/grpc/demo1/helloworld/hello_world.pb.go" target="_blank" rel="noopener">这里</a>可查看全部。</p><p><img data-src="https://st.razeen.cn/img/image/go/grpc-001.png" alt><br><img data-src="https://st.razeen.cn/img/image/go/grpc-002.png" alt></p><p>图中我们可以看到两个<code>message</code>对应生成了两个结构体，同时会生成一些序列化的方法等。</p><p><img data-src="https://st.razeen.cn/img/image/go/grpc-003.png" alt></p><p><img data-src="https://st.razeen.cn/img/image/go/grpc-004.png" alt></p><p>而定义的<code>service</code>则是生成了对应的<code>client</code>与<code>server</code>接口，那么这到底有什么用？怎么去用呢？<a href="https://razeen.me/post/how-to-use-grpc-in-golang-02.html" target="_blank" rel="noopener">下一篇博客</a>将为你详细讲解~</p><p>看到这，我们简单的了解一下protobuf语法，如果你想了解更多，点<a href="https://developers.google.com/protocol-buffers/docs/proto3" target="_blank" rel="noopener">这里</a>看官方文档。</p>]]></content>
      <categories>
        <category>Go学习笔记</category>
        <category>GRPC</category>
      </categories>
      <tags>
        <tag>golang</tag>
        <tag>grpc</tag>
        <tag>protobuf</tag>
      </tags>
  </entry>
  <entry>
    <title>gRPC在Go中的使用（二）gRPC实现简单通讯</title>
    <url>//post/how-to-use-grpc-in-golang-02.html</url>
    <content><![CDATA[<p>在上一篇中，我们用protobuf定义了两个消息<code>HelloWorldRequest</code>与<code>HelloWorldResponse</code>以及一个<code>HelloWorldService</code>服务。同时，我们还生成了相应的go代码<code>.pb.go</code>。</p><p>那么客户端与服务端怎么去通过这些接口去完成通讯呢？下面我们一起实现一个简单的gRPC通讯。</p><a id="more"></a><p>在RPC通讯中，客户端使用存根(SayHelloWorld)发送请求到服务器并且等待响应返回，整个过程就像我们平常函数调用一样。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">service HelloWorldService &#123;</span><br><span class="line">  rpc SayHelloWorld(HelloWorldRequest) returns (HelloWorldResponse)&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么接下来，我们先创建一个服务端。</p><h3 id="创建服务端"><a href="#创建服务端" class="headerlink" title="创建服务端"></a>创建服务端</h3><p>在生成的<code>hello_world.pb.go</code>中，已经为我们生成了服务端的接口：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// HelloWorldServiceServer is the server API for HelloWorldService service.</span></span><br><span class="line"><span class="keyword">type</span> HelloWorldServiceServer <span class="keyword">interface</span> &#123;</span><br><span class="line">	SayHelloWorld(context.Context, *HelloWorldRequest) (*HelloWorldResponse, error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在服务端我们首先要做的就是实现这个接口。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"context"</span></span><br><span class="line">	<span class="string">"log"</span></span><br><span class="line">	<span class="string">"net"</span></span><br><span class="line"></span><br><span class="line">	pb <span class="string">"github.com/razeencheng/demo-go/grpc/demo2/helloworld"</span></span><br><span class="line"></span><br><span class="line">	<span class="string">"github.com/golang/protobuf/ptypes"</span></span><br><span class="line">	<span class="string">"github.com/golang/protobuf/ptypes/any"</span></span><br><span class="line">	<span class="string">"google.golang.org/grpc"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> SayHelloServer <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *SayHelloServer)</span> <span class="title">SayHelloWorld</span><span class="params">(ctx context.Context, in *pb.HelloWorldRequest)</span> <span class="params">(res *pb.HelloWorldResponse, err error)</span></span> &#123;</span><br><span class="line">	log.Printf(<span class="string">"Client Greeting:%s"</span>, in.Greeting)</span><br><span class="line">	log.Printf(<span class="string">"Client Info:%v"</span>, in.Infos)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> an *any.Any</span><br><span class="line">	<span class="keyword">if</span> in.Infos[<span class="string">"hello"</span>] == <span class="string">"world"</span> &#123;</span><br><span class="line">		an, err = ptypes.MarshalAny(&amp;pb.HelloWorld&#123;Msg: <span class="string">"Good Request"</span>&#125;)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		an, err = ptypes.MarshalAny(&amp;pb.Error&#123;Msg: []<span class="keyword">string</span>&#123;<span class="string">"Bad Request"</span>, <span class="string">"Wrong Info Msg"</span>&#125;&#125;)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> &amp;pb.HelloWorldResponse&#123;</span><br><span class="line">		Reply:   <span class="string">"Hello World !!"</span>,</span><br><span class="line">		Details: []*any.Any&#123;an&#125;,</span><br><span class="line">	&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单如上面的几行，实现了这个接口我们只需要创建一个结构<code>SayHelloServer</code>,同时实现<code>HelloWorldServiceServer</code>的所有方法即可。</p><p>这里为了演示效果我打印了一些数据，同时利用<code>any.Any</code>在不同的情况下返回不同的类型数据。</p><p>当然，只是现实了接口还不够，我们还需要启动一个服务，这样客户端才能使用该服务。启动服务很简单，就像我们平常启用一个Server一样。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 我们首先须监听一个tcp端口</span></span><br><span class="line">	lis, err := net.Listen(<span class="string">"tcp"</span>, <span class="string">":8080"</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 新建一个grpc服务器</span></span><br><span class="line">	grpcServer := grpc.NewServer()</span><br><span class="line">    <span class="comment">// 向grpc服务器注册SayHelloServer</span></span><br><span class="line">	pb.RegisterHelloWorldServiceServer(grpcServer, &amp;SayHelloServer&#123;&#125;)</span><br><span class="line">    <span class="comment">// 启动服务</span></span><br><span class="line">	grpcServer.Serve(lis)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的代码，我们可以看到，简单的4步即可启动一个服务。</p><ol><li>监听一个服务端口，供客户端调用；</li><li>创建一个grpc服务器，当然这里可以设置<code>授权认证</code>,这个在下一篇中我们将详细介绍；</li><li>注册服务，其实是调用生存的<code>.pb.go</code>中的<code>RegisterHelloWorldServiceServer</code>方法，将我们这里实现的<code>SayHelloServer</code>加入到该服务中。</li><li>启动服务，等待客户端连接。</li></ol><p>我们<code>go run server.go</code>,无任何报错，这样一个简单的grpc服务的服务端就准备就绪了。接下来我们看看客户端。</p><h3 id="创建客户端"><a href="#创建客户端" class="headerlink" title="创建客户端"></a>创建客户端</h3><p>例如：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"context"</span></span><br><span class="line">	<span class="string">"log"</span></span><br><span class="line"></span><br><span class="line">	<span class="string">"google.golang.org/grpc"</span></span><br><span class="line"></span><br><span class="line">	pb <span class="string">"github.com/razeencheng/demo-go/grpc/demo2/helloworld"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个 gRPC channel 和服务器交互</span></span><br><span class="line">	conn, err := grpc.Dial(<span class="string">"localhost:8080"</span>, grpc.WithInsecure())</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatalf(<span class="string">"Dial failed:%v"</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> conn.Close()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建客户端</span></span><br><span class="line">	client := pb.NewHelloWorldServiceClient(conn)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 直接调用</span></span><br><span class="line">	resp1, err := client.SayHelloWorld(context.Background(), &amp;pb.HelloWorldRequest&#123;</span><br><span class="line">		Greeting: <span class="string">"Hello Server 1 !!"</span>,</span><br><span class="line">		Infos:    <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;<span class="string">"hello"</span>: <span class="string">"world"</span>&#125;,</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	log.Printf(<span class="string">"Resp1:%+v"</span>, resp1)</span><br><span class="line"></span><br><span class="line">	resp2, err := client.SayHelloWorld(context.Background(), &amp;pb.HelloWorldRequest&#123;</span><br><span class="line">		Greeting: <span class="string">"Hello Server 2 !!"</span>,</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	log.Printf(<span class="string">"Resp2:%+v"</span>, resp2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端的实现比服务端更简洁，三步即可。</p><ol><li>创建一个 gRPC channel 和服务器交互。这里也是可以设置<code>授权认证</code>的；</li><li>创建一个客户端去执行RPC。用到的也是<code>.pb.go</code>内的<code>NewHelloWorldServiceClient</code>方法；</li><li>像函数调用一样去调用RPC服务。</li></ol><p>我直接RUN起来，如下，我们可以看到客户端发送到服务的消息以及服务端对不同消息的不同回复。</p><p><img data-src="https://st.razeen.cn/img/image/grpc/grpc-result.png" alt></p><p>那么到这里，我们简单的实现了一个gRPC通讯。但很多时候，我们可能希望客户端与服务器能更安全的通信，或者客户端与服务器不再是一种固定的结构的传输，需要流式的去处理一些问题等等。针对这些问题，在<a href="https://razeen.me/post/how-to-use-grpc-in-golang-03.html" target="_blank" rel="noopener">下一篇博客</a>中，我将结合实例详细说明。</p><p><em>文中完整代码在<a href="https://github.com/razeencheng/demo-go/tree/master/grpc/demo2" target="_blank" rel="noopener">这里</a>。</em></p>]]></content>
      <categories>
        <category>Go学习笔记</category>
        <category>GRPC</category>
      </categories>
      <tags>
        <tag>golang</tag>
        <tag>grpc</tag>
        <tag>rpc</tag>
      </tags>
  </entry>
  <entry>
    <title>gRPC在Go中的使用（三）gRPC实现TLS加密通信与流模式</title>
    <url>//post/how-to-use-grpc-in-golang-03.html</url>
    <content><![CDATA[<p>在前面的两篇博客中，我们已经知道了如何利用gRPC建立简单RPC通信。但这样简单的实现有时候满足不了我们的业务需求。在一些场景中我们需要防止数据被劫持，或是一些场景中我们希望客户端与服务器不是简单的一问一答，而是建立起一个流式的RPC通信，那么该怎么做到呢？</p><a id="more"></a><h3 id="TLS加密通信"><a href="#TLS加密通信" class="headerlink" title="TLS加密通信"></a>TLS加密通信</h3><p>TLS加密无非就是认证客户端与服务器，如果对SSL/TLS加密通信有所了解的童鞋都知道我们首先需要两张证书。</p><p>所以作为准备工作，我们首先要申请两张测试证书。一张客户端证书，一张服务器证书。</p><h4 id="生成测试证书"><a href="#生成测试证书" class="headerlink" title="生成测试证书"></a>生成测试证书</h4><p>利用<a href="https://myssl.com/create_test_cert.html" target="_blank" rel="noopener">MySSL测试证书生成工具</a>我们可以很简单的生成两张证书，如下所示：</p><p>如图，填入域名生成一张服务器证书，然后将私钥，证书链，根证书都下载下来，保存到文件。</p><p><img data-src="https://st.razeen.cn/img/image/grpc-demo3-001.png" alt></p><p>同样，生成一张客户端证书并保存。</p><p><img data-src="https://st.razeen.cn/img/image/grpc-demo3-002.png" alt></p><h4 id="客户端与服务器TLS认证"><a href="#客户端与服务器TLS认证" class="headerlink" title="客户端与服务器TLS认证"></a>客户端与服务器TLS认证</h4><p>在gRPC通信中，我们完成服务器认证与客户端认证主要使用的是grpc下的<a href="https://godoc.org/google.golang.org/grpc/credentials" target="_blank" rel="noopener">credentials</a>库。下面通过实例来看看怎么使用。</p><p><a href="https://github.com/razeencheng/demo-go/tree/master/grpc/demo3" target="_blank" rel="noopener">代码实例</a></p><p><strong>服务端实现</strong></p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	lis, err := net.Listen(<span class="string">"tcp"</span>, <span class="string">":8080"</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 加载证书和密钥 （同时能验证证书与私钥是否匹配）</span></span><br><span class="line">	cert, err := tls.LoadX509KeyPair(<span class="string">"certs/test_server.pem"</span>, <span class="string">"certs/test_server.key"</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 将根证书加入证书池</span></span><br><span class="line">	<span class="comment">// 测试证书的根如果不加入可信池，那么测试证书将视为不可惜，无法通过验证。</span></span><br><span class="line">	certPool := x509.NewCertPool()</span><br><span class="line">	rootBuf, err := ioutil.ReadFile(<span class="string">"certs/root.pem"</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> !certPool.AppendCertsFromPEM(rootBuf) &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">"fail to append test ca"</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	tlsConf := &amp;tls.Config&#123;</span><br><span class="line">		ClientAuth:   tls.RequireAndVerifyClientCert,</span><br><span class="line">		Certificates: []tls.Certificate&#123;cert&#125;,</span><br><span class="line">		ClientCAs:    certPool,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	serverOpt := grpc.Creds(credentials.NewTLS(tlsConf))</span><br><span class="line">	grpcServer := grpc.NewServer(serverOpt)</span><br><span class="line"></span><br><span class="line">	pb.RegisterHelloWorldServiceServer(grpcServer, &amp;SayHelloServer&#123;&#125;)</span><br><span class="line"></span><br><span class="line">	log.Println(<span class="string">"Server Start..."</span>)</span><br><span class="line">	grpcServer.Serve(lis)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>客户端实现</strong></p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	cert, err := tls.LoadX509KeyPair(<span class="string">"certs/test_client.pem"</span>, <span class="string">"certs/test_client.key"</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 将根证书加入证书池</span></span><br><span class="line">	certPool := x509.NewCertPool()</span><br><span class="line">	bs, err := ioutil.ReadFile(<span class="string">"certs/root.pem"</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> !certPool.AppendCertsFromPEM(bs) &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">"fail to append test ca"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 新建凭证</span></span><br><span class="line">    <span class="comment">// ServerName 需要与服务器证书内的通用名称一致</span></span><br><span class="line">	transportCreds := credentials.NewTLS(&amp;tls.Config&#123;</span><br><span class="line">		ServerName:   <span class="string">"server.razeen.me"</span>,</span><br><span class="line">		Certificates: []tls.Certificate&#123;cert&#125;,</span><br><span class="line">		RootCAs:      certPool,</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	dialOpt := grpc.WithTransportCredentials(transportCreds)</span><br><span class="line"></span><br><span class="line">	conn, err := grpc.Dial(<span class="string">"localhost:8080"</span>, dialOpt)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatalf(<span class="string">"Dial failed:%v"</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> conn.Close()</span><br><span class="line"></span><br><span class="line">	client := pb.NewHelloWorldServiceClient(conn)</span><br><span class="line">	resp1, err := client.SayHelloWorld(context.Background(), &amp;pb.HelloWorldRequest&#123;</span><br><span class="line">		Greeting: <span class="string">"Hello Server 1 !!"</span>,</span><br><span class="line">		Infos:    <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;<span class="string">"hello"</span>: <span class="string">"world"</span>&#125;,</span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Printf(<span class="string">"%v"</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	log.Printf(<span class="string">"Resp1:%+v"</span>, resp1)</span><br><span class="line"></span><br><span class="line">	resp2, err := client.SayHelloWorld(context.Background(), &amp;pb.HelloWorldRequest&#123;</span><br><span class="line">		Greeting: <span class="string">"Hello Server 2 !!"</span>,</span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Printf(<span class="string">"%v"</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	log.Printf(<span class="string">"Resp2:%+v"</span>, resp2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码中，我们不难看出，主要是创建一个通信凭证(TransportCredentials)。利用<code>credentials</code>库的<code>NewTLS</code>方法从<code>tls</code>加载一个通信凭证用于通信。而在其中需要注意的是：</p><ul><li><p>如果你使用的是自签发的证书，注意将根加入证书池。如果你使用的是可信CA签发的证书大部分不用添加，因为系统的可信CA库已经有了。如果没有成功添加, 在通信时会出现以下错误：</p><blockquote><p>rpc error: code = Unavailable desc = all SubConns are in TransientFailure, latest connection error: connection error: desc = “transport: authentication handshake failed: x509: certificate signed by unknown authority”</p></blockquote><p>或</p><blockquote><p>rpc error: code = Unavailable desc = all SubConns are in TransientFailure, latest connection error: connection error: desc = “transport: authentication handshake failed: remote error: tls: bad certificate”</p></blockquote></li><li><p>客户端凭证内 <code>ServerName</code> 需要与服务器证书内的通用名称一致，如果不一致会出现如下错误：</p><blockquote><p>rpc error: code = Unavailable desc = all SubConns are in TransientFailure, latest connection error: connection error: desc = “transport: authentication handshake failed: x509: certificate is valid for server.razeen.me, not xxxxx”</p></blockquote></li></ul><p>之后，我们就可安心的通信了，在私钥不泄漏的情况下，基本不再担心数据劫持问题了。</p><p><strong>这里我想多说一句：</strong>我们经常在提交代码时会直接 <code>git add .</code> ，这是个不好的习惯，有时后我们会将一些不必要的文件提交上去，特别是一些<strong>证书</strong>、<strong>私钥</strong>、<strong>密码</strong>之类的文件。</p><h3 id="流式的RPC通信"><a href="#流式的RPC通信" class="headerlink" title="流式的RPC通信"></a>流式的RPC通信</h3><p>流式PRC通信可以分为:</p><ul><li><p>服务器端流式 RPC;</p><p>客户端发送请求到服务器，拿到一个流去读取返回的消息序列。 客户端读取返回的流，直到里面没有任何消息。如：</p><figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">rpc</span> ListHello(HelloWorldRequest) <span class="keyword">returns</span> (stream HelloWorldResponse) &#123;&#125;</span></span><br></pre></td></tr></table></figure></li></ul><ul><li><p>客户端流式 RPC;</p><p>客户端写入一个消息序列并将其发送到服务器，同样也是使用流。一旦客户端完成写入消息，它等待服务器完成读取返回它的响应。如：</p><figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">rpc</span> SayMoreHello(stream HelloWorldRequest) <span class="keyword">returns</span> (HelloWorldResponse) &#123;&#125;</span></span><br></pre></td></tr></table></figure></li></ul><ul><li><p>双向流式 RPC;</p><p>双方使用读写流去发送一个消息序列。两个流独立操作，因此客户端和服务器可以以任意喜欢的顺序读写。如：</p><figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">rpc</span> SayHelloChat(stream HelloWorldRequest) <span class="keyword">returns</span> (stream HelloWorldRequest) &#123;&#125;</span></span><br></pre></td></tr></table></figure></li></ul><p>从上面的定义不难看出，用<code>stream</code>可以定义一个流式消息。下面我们就通过实例来演示一下流式通信的使用方法。</p><p>首先，我们将上面三个rpc server加入<code>.proto</code> , 并且生成新的<code>.pb.go</code>代码。</p><p>在生成的代码<a href="https://github.com/razeencheng/demo-go/blob/master/grpc/demo3/helloworld/hello_world.pb.go" target="_blank" rel="noopener"><code>hello_world.pb.go</code></a>中，我们可以看到客户端接口如下：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> HelloWorldServiceClient <span class="keyword">interface</span> &#123;</span><br><span class="line">	SayHelloWorld(ctx context.Context, in *HelloWorldRequest, opts ...grpc.CallOption) (*HelloWorldResponse, error)</span><br><span class="line">	ListHello(ctx context.Context, in *HelloWorldRequest, opts ...grpc.CallOption) (HelloWorldService_ListHelloClient, error)</span><br><span class="line">	SayMoreHello(ctx context.Context, opts ...grpc.CallOption) (HelloWorldService_SayMoreHelloClient, error)</span><br><span class="line">	SayHelloChat(ctx context.Context, opts ...grpc.CallOption) (HelloWorldService_SayHelloChatClient, error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务端接口如下:</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// HelloWorldServiceServer is the server API for HelloWorldService service.</span></span><br><span class="line"><span class="keyword">type</span> HelloWorldServiceServer <span class="keyword">interface</span> &#123;</span><br><span class="line">	SayHelloWorld(context.Context, *HelloWorldRequest) (*HelloWorldResponse, error)</span><br><span class="line">	ListHello(*HelloWorldRequest, HelloWorldService_ListHelloServer) error</span><br><span class="line">	SayMoreHello(HelloWorldService_SayMoreHelloServer) error</span><br><span class="line">	SayHelloChat(HelloWorldService_SayHelloChatServer) error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在客户段的接口中，生成了<code>HelloWorldService_XXXXClient</code>接口类型。 在服务端的接口中，生成了<code>HelloWorldService_XXXXServer</code>接口类型。 我们再查看这些接口的定义，发现这这几个接口都是实现了以下几个方法中的数个：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">Send(*HelloWorldRequest) error</span><br><span class="line">Recv() (*HelloWorldRequest, error)</span><br><span class="line">CloseAndRecv() (*HelloWorldResponse, error)</span><br><span class="line">grpc.ClientStream</span><br></pre></td></tr></table></figure><p>看其名字，我们不难知道，流式RPC的使用，或者说流的收发也就离不开这几个方法了。下面我们通过几个实例来验证一下。</p><p>在服务端，我们实现这三个接口。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 服务器端流式 RPC, 接收一次客户端请求，返回一个流</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *SayHelloServer)</span> <span class="title">ListHello</span><span class="params">(in *pb.HelloWorldRequest, stream pb.HelloWorldService_ListHelloServer)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	log.Printf(<span class="string">"Client Say: %v"</span>, in.Greeting)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 我们返回多条数据</span></span><br><span class="line">	stream.Send(&amp;pb.HelloWorldResponse&#123;Reply: <span class="string">"ListHello Reply "</span> + in.Greeting + <span class="string">" 1"</span>&#125;)</span><br><span class="line">	time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">	stream.Send(&amp;pb.HelloWorldResponse&#123;Reply: <span class="string">"ListHello Reply "</span> + in.Greeting + <span class="string">" 2"</span>&#125;)</span><br><span class="line">	time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">	stream.Send(&amp;pb.HelloWorldResponse&#123;Reply: <span class="string">"ListHello Reply "</span> + in.Greeting + <span class="string">" 3"</span>&#125;)</span><br><span class="line">	time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端流式 RPC， 客户端流式请求，服务器可返回一次</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *SayHelloServer)</span> <span class="title">SayMoreHello</span><span class="params">(stream pb.HelloWorldService_SayMoreHelloServer)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="comment">// 接受客户端请求</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		req, err := stream.Recv()</span><br><span class="line">		<span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		log.Printf(<span class="string">"SayMoreHello Client Say: %v"</span>, req.Greeting)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 流读取完成后，返回</span></span><br><span class="line">	<span class="keyword">return</span> stream.SendAndClose(&amp;pb.HelloWorldResponse&#123;Reply: <span class="string">"SayMoreHello Recv Muti Greeting"</span>&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 双向流式 RPC</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *SayHelloServer)</span> <span class="title">SayHelloChat</span><span class="params">(stream pb.HelloWorldService_SayHelloChatServer)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="comment">// 开一个协程去处理客户端数据</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			req, err := stream.Recv()</span><br><span class="line">			<span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			log.Printf(<span class="string">"SayHelloChat Client Say: %v"</span>, req.Greeting)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向客户端写入多条数据</span></span><br><span class="line">	stream.Send(&amp;pb.HelloWorldRequest&#123;Greeting: <span class="string">"SayHelloChat Server Say Hello 1"</span>&#125;)</span><br><span class="line">	time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">	stream.Send(&amp;pb.HelloWorldRequest&#123;Greeting: <span class="string">"SayHelloChat Server Say Hello 2"</span>&#125;)</span><br><span class="line">	time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">	stream.Send(&amp;pb.HelloWorldRequest&#123;Greeting: <span class="string">"SayHelloChat Server Say Hello 3"</span>&#125;)</span><br><span class="line">	time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后我们就可以在客户端分别请求这几个rpc服务。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">    <span class="comment">// 服务器端流式 RPC;</span></span><br><span class="line">    <span class="comment">// 我们向服务器SayHello </span></span><br><span class="line">	recvListHello, err := client.ListHello(context.Background(), &amp;pb.HelloWorldRequest&#123;Greeting: <span class="string">"Hello Server List Hello"</span>&#125;)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatalf(<span class="string">"ListHello err: %v"</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 服务器以流式返回</span></span><br><span class="line">    <span class="comment">// 直到 err==io.EOF时，表示接收完毕。</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		resp, err := recvListHello.Recv()</span><br><span class="line">		<span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Fatal(err)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		log.Printf(<span class="string">"ListHello Server Resp: %v"</span>, resp.Reply)</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">// Client Out:</span></span><br><span class="line"><span class="comment">// 2018/08/06 01:27:55 ListHello Server Resp: ListHello Reply Hello Server List Hello 1</span></span><br><span class="line"><span class="comment">// 2018/08/06 01:27:56 ListHello Server Resp: ListHello Reply Hello Server List Hello 2</span></span><br><span class="line"><span class="comment">// 2018/08/06 01:27:57 ListHello Server Resp: ListHello Reply Hello Server List Hello 3</span></span><br><span class="line"><span class="comment">// Server Out:</span></span><br><span class="line"><span class="comment">// 2018/08/06 01:27:55 Client Say: Hello Server List Hello</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 客户端流式 RPC;</span></span><br><span class="line">	sayMoreClient, err := client.SayMoreHello(context.Background())</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">		sayMoreClient.Send(&amp;pb.HelloWorldRequest&#123;Greeting: fmt.Sprintf(<span class="string">"SayMoreHello Hello Server %d"</span>, i)&#125;)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	sayMoreResp, err := sayMoreClient.CloseAndRecv()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">	log.Printf(<span class="string">"SayMoreHello Server Resp: %v"</span>, sayMoreResp.Reply)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Client Out:</span></span><br><span class="line"><span class="comment">// 2018/08/06 01:31:11 SayMoreHello Server Resp: SayMoreHello Recv Muti Greeting</span></span><br><span class="line"><span class="comment">// Server Out:</span></span><br><span class="line"><span class="comment">// 2018/08/06 01:31:11 SayMoreHello Client Say: SayMoreHello Hello Server 0</span></span><br><span class="line"><span class="comment">// 2018/08/06 01:31:11 SayMoreHello Client Say: SayMoreHello Hello Server 1</span></span><br><span class="line"><span class="comment">// 2018/08/06 01:31:11 SayMoreHello Client Say: SayMoreHello Hello Server 2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 双向流式 RPC;</span></span><br><span class="line">	sayHelloChat, err := client.SayHelloChat(context.Background())</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">			sayHelloChat.Send(&amp;pb.HelloWorldRequest&#123;Greeting: fmt.Sprintf(<span class="string">"SayHelloChat Hello Server %d"</span>, i)&#125;)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		resp, err := sayHelloChat.Recv()</span><br><span class="line">		<span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Fatal(err)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		log.Printf(<span class="string">"SayHelloChat Server Say: %v"</span>, resp.Greeting)</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">// Client Out:</span></span><br><span class="line"><span class="comment">// 2018/08/06 01:31:11 SayHelloChat Server Say: SayHelloChat Server Say Hello 1</span></span><br><span class="line"><span class="comment">// 2018/08/06 01:31:12 SayHelloChat Server Say: SayHelloChat Server Say Hello 2</span></span><br><span class="line"><span class="comment">// 2018/08/06 01:31:13 SayHelloChat Server Say: SayHelloChat Server Say Hello 3</span></span><br><span class="line"><span class="comment">// Server Out:</span></span><br><span class="line"><span class="comment">// 2018/08/06 01:31:11 SayHelloChat Client Say: SayHelloChat Hello Server 0</span></span><br><span class="line"><span class="comment">// 2018/08/06 01:31:11 SayHelloChat Client Say: SayHelloChat Hello Server 1</span></span><br><span class="line"><span class="comment">// 2018/08/06 01:31:11 SayHelloChat Client Say: SayHelloChat Hello Server 2</span></span><br></pre></td></tr></table></figure><p>看了实例，是不是觉得很简单～。三种方式大同小异，只要掌握了怎么去收发流，怎么判断流的结束，基本就可以了。</p><p>好了，gRPC在Go中的使用三篇文章到这里也就结束了，如果博客中有错误或者你还有想知道的，记得留言哦。</p><ul><li><a href="https://github.com/razeencheng/demo-go/tree/master/grpc/demo3" target="_blank" rel="noopener">源代码在这里</a></li></ul>]]></content>
      <categories>
        <category>Go学习笔记</category>
        <category>GRPC</category>
      </categories>
      <tags>
        <tag>golang</tag>
        <tag>grpc</tag>
        <tag>tls</tag>
        <tag>stream</tag>
      </tags>
  </entry>
  <entry>
    <title>GitHub Pages自定义域名开启HTTPS</title>
    <url>//post/https-githubpages.html</url>
    <content><![CDATA[<p>GitHub Pages由于其免费，轻量，搭建方便等缘故已经成为很多coder搭建博客的首选方案。同时，GitHub Pages还支持自定义域名访问，这就让更多人有兴趣实用了。但，一旦你开启了自定义域名，通过自定义域名访问，不再是HTTPS了。这篇博客就是帮你实现自定义域名的HTTPS支持。</p><a id="more"></a><blockquote><p>2018年05月18日 更新</p><p>据最新了解只要你域名CNAME到你的GitHub Page页面，github会自动给你申请一张你域名的Let’s Encrypt证书,而且你还可以在设置里开启强制HTTPS选项。</p></blockquote><p>我们这里主要借助的是Cloudflare免费的CDN服务，让你的GitHub博客支持HTTPS。</p><p>我们可以先看一下最后<a href="https://myssl.com/hslx.xyz" target="_blank" rel="noopener">成果</a>。</p><p><img data-src="https://st.razeen.cn/img/image/https/githubpages/Jietu20180327-142405.png" alt></p><p>轻轻松松获得一个A+。</p><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>在开始之前，你需要先<a href="https://www.cloudflare.com/a/sign-up" target="_blank" rel="noopener">注册</a>一个Cloudflare账号。</p><h3 id="设置DNS"><a href="#设置DNS" class="headerlink" title="设置DNS"></a>设置DNS</h3><p>在你注册完成，登录后，Cloudflare会提示你添加自己的站点，如下图一样(如果没有，点击右上角 Add Site即可)。</p><p><img data-src="https://st.razeen.cn/img/image/https/githubpages/Jietu20180320-121134.png" alt></p><p>填写后，Cloudfire会去查询你的DNS记录。</p><p><img data-src="https://st.razeen.cn/img/image/https/githubpages/Jietu20180320-121356.png" alt></p><p>如果你的DNS解析服务没有设置成Cloudflare,Cloud会提示你改变你的DNS域名解析服务，如下所示。</p><p><img data-src="https://st.razeen.cn/img/image/https/githubpages/Jietu20180320-121454.png" alt></p><p>接下来你只需要，将你的DNS解析服务换成Cloudflare给你的两个地址即可。</p><p><img data-src="https://st.razeen.cn/img/image/https/githubpages/Jietu20180320-121514.png" alt></p><p>例如，我用的是阿里云，直接到阿里的域名管理，修改DNS即可。</p><p><img data-src="https://st.razeen.cn/img/image/https/githubpages/Jietu20180320-121558.png" alt><br><img data-src="https://st.razeen.cn/img/image/https/githubpages/Jietu20180320-121639.png" alt></p><p>完成后，你需要等待一段时间，Cloudflare提示或许需要24小时，我花了几个小时就OK了。</p><p><img data-src="https://st.razeen.cn/img/image/https/githubpages/Jietu20180320-121823.png" alt></p><p>大概两三个小时后，你可以点击Recheck 查看一下是否成功了。</p><h3 id="添加DNS记录"><a href="#添加DNS记录" class="headerlink" title="添加DNS记录"></a>添加DNS记录</h3><p>如下图所示，添加几条DNS记录，分别是</p><ul><li>CNAME： 将<a href="http://www.hslx.xyz" target="_blank" rel="noopener">www.hslx.xyz</a> ☞ hslx.xyz；</li><li>A : 将 hslx.xyz ☞ github pages 的IP；<blockquote><p>目前github pages 官方给出的IP有：</p><ul><li>185.199.108.153</li><li>185.199.109.153</li><li>185.199.110.153</li><li>185.199.111.153<br>(更新于2019/04/12)</li></ul></blockquote></li></ul><p><img data-src="https://st.razeen.cn/img/image/https/githubpages/Jietu20180320-123041.png" alt></p><h3 id="设置HTTPS"><a href="#设置HTTPS" class="headerlink" title="设置HTTPS"></a>设置HTTPS</h3><p>如图，我们设置全站HTTPS。</p><p><img data-src="https://st.razeen.cn/img/image/https/githubpages/Jietu20180320-123224.png" alt></p><p>开启http自动跳转到HTTPS。</p><p><img data-src="https://st.razeen.cn/img/image/https/githubpages/Jietu20180320-123408.png" alt></p><p>同时，我们还需要设置一些页面规则，将所有该站点的资源全部走HTTPS。</p><p><img data-src="https://st.razeen.cn/img/image/https/githubpages/Jietu20180320-123652.png" alt><br><img data-src="https://st.razeen.cn/img/image/https/githubpages/Jietu20180320-123826.png" alt></p><p>到这里，你就全部配置好了。等待一段时间，当你的状态变成如下所示时说明你以成功设置。</p><p><img data-src="https://st.razeen.cn/img/image/https/githubpages/Jietu20180327-141701.png" alt></p><p>赶快试试吧~</p>]]></content>
      <categories>
        <category>博客折腾日记</category>
      </categories>
      <tags>
        <tag>https</tag>
        <tag>github-pages</tag>
      </tags>
  </entry>
  <entry>
    <title>简单了解 PKCS 规范</title>
    <url>//post/introduce-pkcs.html</url>
    <content><![CDATA[<p>接触过密码学的童鞋可能都听说或接触过PKCS #1, PKCS #7, PKCS #8, PKCS #12等等，或许你早已了解PKCS就是指公钥密码标准(Public Key Cryptography Standards)，而这篇博客将带你系统的了解一下整个PKCS规范。</p><a id="more"></a><h3 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h3><p>PKCS即公钥密码标准(Public Key Cryptography Standards),它是由<a href="https://en.wikipedia.org/wiki/RSA_Security" target="_blank" rel="noopener">美国RSA实验室</a>与遍布全球的安全系统开发者一起合作指定的一组规范，以推动公钥密码的发展。最早发布的PKCS文档是早期一群公钥技术使用者在1991年召开的一次会议的成果。目前PKCS规范早已被广泛的应用和实施，部分PKCS规范已经成为多个国际组织正式或事实上的标准，如<a href="https://en.wikipedia.org/wiki/American_National_Standards_Institute" target="_blank" rel="noopener">ANSI</a> X9文档系列，<a href="https://en.wikipedia.org/w/index.php?title=PKIX&amp;redirect=no" target="_blank" rel="noopener">PKIX</a>，<a href="https://en.wikipedia.org/wiki/Secure_Electronic_Transaction" target="_blank" rel="noopener">SET</a>，<a href="https://en.wikipedia.org/wiki/S/MIME" target="_blank" rel="noopener">S/MIME</a>，<a href="https://en.wikipedia.org/wiki/Transport_Layer_Security" target="_blank" rel="noopener">SSL</a>等。PKCS系列主要包括以下标准。</p><table><thead><tr><th></th><th>名称</th><th style="text-align:left">RFC</th></tr></thead><tbody><tr><td>PKCS #1</td><td>RSA Cryptography Standard (RSA密码标准)</td><td style="text-align:left"><a href="https://tools.ietf.org/html/rfc3447" target="_blank" rel="noopener">RFC 3447</a></td></tr><tr><td>PKCS #2</td><td>已撤销，用以规范RSA加密摘要的转换方式，已并入PKCS #1</td><td style="text-align:left">-</td></tr><tr><td>PKCS #3</td><td><a href="https://en.wikipedia.org/wiki/Diffie%E2%80%93Hellman_key_exchange" target="_blank" rel="noopener">Diffie–Hellman Key Agreement</a> Standard (DH秘钥协商标准)</td><td style="text-align:left">-</td></tr><tr><td>PKCS #4</td><td>已撤销，用以定义RSA秘钥的格式，已并入PKCS #1</td><td style="text-align:left">-</td></tr><tr><td>PKCS #5</td><td>Password-based Encryption Standard (基于口令的密码标准)</td><td style="text-align:left"><a href="https://tools.ietf.org/html/rfc2898" target="_blank" rel="noopener">RFC 2898</a></td></tr><tr><td>PKCS #6</td><td>Extended-Certificate Syntax Standard (扩展的证书语法标准)</td><td style="text-align:left">-</td></tr><tr><td>PKCS #7</td><td>Cryptographic Message Syntax Standard (密码消息语法标准)</td><td style="text-align:left"><a href="https://tools.ietf.org/html/rfc2315" target="_blank" rel="noopener">RFC 2315</a></td></tr><tr><td>PKCS #8</td><td>Private-Key Information Syntax Standard (私钥信息语法标准)</td><td style="text-align:left"><a href="https://tools.ietf.org/html/rfc5958" target="_blank" rel="noopener">RFC 5958</a></td></tr><tr><td>PKCS #9</td><td>Selected Attribute Types (可供选择的属性类型)</td><td style="text-align:left"><a href="https://tools.ietf.org/html/rfc2985" target="_blank" rel="noopener">RFC 2985</a></td></tr><tr><td>PKCS #10</td><td>Certification Request Standard (证书请求语法标准)</td><td style="text-align:left"><a href="https://tools.ietf.org/html/rfc2986" target="_blank" rel="noopener">RFC 2986</a></td></tr><tr><td>PKCS #11</td><td>Cryptographic Token Interface (密码Token接口标准)</td><td style="text-align:left">-</td></tr><tr><td>PKCS #12</td><td>Personal Information Exchange Syntax Standar (个人信息交换语法标准)</td><td style="text-align:left"><a href="https://tools.ietf.org/html/rfc7292" target="_blank" rel="noopener">RFC 7292</a></td></tr><tr><td>PKCS #13</td><td><a href="https://en.wikipedia.org/wiki/Elliptic_curve_cryptography" target="_blank" rel="noopener">Elliptic Curve Cryptography</a> Standard (椭圆曲线密码标准)，正在制定中</td><td style="text-align:left"></td></tr><tr><td>PKCS #14</td><td><a href="https://en.wikipedia.org/wiki/Pseudorandom_number_generator" target="_blank" rel="noopener">Pseudo-random Number Generation</a> (伪随机数生成算法PRNG)，正在制定中</td><td style="text-align:left"></td></tr><tr><td>PKCS #15</td><td>Cryptographic Token Information Format Standard (密码Token信息格式标准)</td></tr></tbody></table><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><h4 id="PKCS-1"><a href="#PKCS-1" class="headerlink" title="PKCS #1"></a>PKCS #1</h4><p>PKCS #1 v2.1定义了基于RSA公钥算法的加密解密和签名验签机制，主要包括以下内容:</p><ol><li>秘钥类型:<ul><li>公钥</li><li>私钥</li></ul></li><li>数据转换原子操作： 在数学公式中遇到的潜在大型非负整数与其计算机数据表示形式之间的转换，作为字节序列（一个<a href="https://en.wikipedia.org/wiki/Octet_(computing" target="_blank" rel="noopener">字节字符串</a>)）<ul><li>12OSP (Integer-to-Octet-String primitive)</li><li>OS2IP (Otter-String-to-Integer primitive)</li></ul></li><li>密码原子操作：<ul><li>加密RSAEP，解密RSADP : 基本的加密和解密算法</li><li>签名RSASP1，验签RSAVP1 : 用于生成和验证签名的算法</li></ul></li><li>加密解密方案：<ul><li>RSAES-OAEP: 改进的加密/解密方案; 基于<a href="https://en.wikipedia.org/wiki/Mihir_Bellare" target="_blank" rel="noopener">Mihir Bellare</a>和<a href="https://en.wikipedia.org/wiki/Phillip_Rogaway" target="_blank" rel="noopener">Phillip Rogaway</a>提出的<a href="https://en.wikipedia.org/wiki/Optimal_Asymmetric_Encryption_Padding" target="_blank" rel="noopener">最佳非对称加密填充</a>方案。</li><li>RSAES-PKCS-v1_5 : 在PKCS＃1版本1.5中首次标准化的较早的加密/解密方案。</li></ul></li><li>签名验签方案：<ul><li>RSASSA-PSS ： 改进的带有附录的概率签名方案; 基于Bellare和Rogaway最初发明的概率签名方案 。</li><li>RSASSA-PKCS-v1_5：带有附录的旧签名方案，在PKCS＃1版本1.5中首次标准化。</li></ul></li><li>签名编码方法：<ul><li>EMSA-PSS：签名附件的编码方法，概率签名方案。</li><li>EMSA-PKCS-v1_5 ：PKCS＃1版本1.5中首次标准化的签名附录的编码方法。</li></ul></li></ol><h4 id="PKCS-3"><a href="#PKCS-3" class="headerlink" title="PKCS #3"></a>PKCS #3</h4><p>PKCS #3 v1.4描述了一种基于DH算法进行密钥协商的方法。无需预先沟通，交易双发就可以协商出一个只有双方知道的秘密密钥，该密钥可以对后续双方的数据通信进行加密保护。</p><h4 id="PKCS-5"><a href="#PKCS-5" class="headerlink" title="PKCS #5"></a>PKCS #5</h4><p>PKCS #5 v2.0 描述了一种基于口令产生对称密钥的方法。使用MD2或MD5从口令中派生密码，采用DES的CBC模式加密。这个功能主要用于加密从一个计算机传送到另一个计算机的私人密钥，而不是用于加密消息。主要包括：</p><ol><li>密钥获取函数：<ul><li>PBKDF1</li><li>PBKDF2</li></ul></li><li>加密解密方案：<ul><li>PBES1</li><li>PBES2</li></ul></li><li>消息认证方案：<ul><li>MAC产生</li><li>MAC验证</li></ul></li></ol><h4 id="PKCS-6"><a href="#PKCS-6" class="headerlink" title="PKCS #6"></a>PKCS #6</h4><p>PKCS #6 v1.5描述扩展证书的语法格式。该扩展证书只是对X.509格式进行了扩展，并兼容X.509证书格式。</p><h4 id="PKCS-7"><a href="#PKCS-7" class="headerlink" title="PKCS #7"></a>PKCS #7</h4><p>PKCS #7 v1.5 描述了密码消息的通用语法。该语法允许嵌套，如一个数字信封可以包含另外一个数字信封，或可以对自己做数字信封的数据进行签名；该语法也允许扩展各种属性，还可以用于分发证书和CRL。</p><p>PKCS #7与PEM兼容，可以直接将加密的消息转换成PEM消息，反正亦然。PKCS #7 支持多种基于证书的管理系统，PEM就是其中之一。在RFC 5652中有增强定义。该标准主要包括消息通用语法和6种内容类型（明文、签名、信封、签名信封、摘要、密文）。</p><h4 id="PKCS-8"><a href="#PKCS-8" class="headerlink" title="PKCS #8"></a>PKCS #8</h4><p>PKCS #8 v1.2描述私钥信息的语法格式。私钥信息包括私钥和一组属性。该标准还描述了私钥密文语法，且允许使用基于口令的加密算法来加密私钥。在RFC 5208中又重新定义。</p><h4 id="PKCS-9"><a href="#PKCS-9" class="headerlink" title="PKCS #9"></a>PKCS #9</h4><p>PKCS #9 v2.0 定义了两个新的辅助对象类（pkcsEntity和naturalPerson）和精选的属性类型（基于这两个对象类）。</p><h4 id="PKCS-10"><a href="#PKCS-10" class="headerlink" title="PKCS #10"></a>PKCS #10</h4><p>PKCS #10 v1.7 描述了证书请求的语法格式。证书请求包括DN名字、公钥和一组可选的属性，以及请求方对上述信息的签名。一个证书请求包括可辨别名、公开密钥和（可选的）一组属性，所有这些均由请求证书的用户签名。证书请求被发送给CA，由CA基于证书请求中的内容签发数字证书。在RFC2986中重新定义。</p><h4 id="PKCS-11"><a href="#PKCS-11" class="headerlink" title="PKCS #11"></a>PKCS #11</h4><p>PKCS #11 v2.2 定义了与密码令牌（如硬件安全模块（HSM）和智能卡）的独立于平台的API。主要内容包括：</p><ol><li>通用数据类型（General Data Types）</li><li>对象 （Objects）</li><li>函数（Functions）</li><li>机制（Mechanisms)</li></ol><h4 id="PKCS-12"><a href="#PKCS-12" class="headerlink" title="PKCS #12"></a>PKCS #12</h4><p>PKCS #12 v1.0 描述了用于存储和传递个人身份信息的语法格式。个人身份信息包括私钥、证书、各种秘密以及扩展等。支持本标准的机器设备、应用系统、浏览器、上网亭（Internet Kiosk)等应允许用户导入、导出和操作这种格式的个人身份信息。它的目标是为各种应用提供一个标准的单一秘钥文件。常见的PFX文件就是遵循PKCS #12格式的文件。</p><h4 id="PKCS-15"><a href="#PKCS-15" class="headerlink" title="PKCS #15"></a>PKCS #15</h4><p>PKCS #15v1.1 描述了存储于密码Token中密码凭证的一种格式标准，允许密码令牌的用户向应用程序标识自己。此标准独立于PKCS #11接口和其他API、RSA已经放弃了这个标准的IC卡相关部分，并提交给了ISO/IEC 7816-15。</p><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>在后续的学习过程中将补充一些实例来更加深入了解这些规范，先挖个坑~</p><p><strong>参考资料</strong></p><ul><li>PKI/CA与数字证书技术大全</li></ul>]]></content>
      <categories>
        <category>PKI/CA与数字证书</category>
        <category>PKI/CA</category>
      </categories>
      <tags>
        <tag>pkcs</tag>
      </tags>
  </entry>
  <entry>
    <title>常用 linux 命令小结（一）文件目录操作</title>
    <url>//post/linux-command-line-summary-fopt.html</url>
    <content><![CDATA[<p>经常用到一些linux命令是会突然忘记他们的用法，为了以后熟练的使用它们，这里总结一下自己经常用的命令以及这写命令的常用参数。<br><a id="more"></a></p><h3 id="ls"><a href="#ls" class="headerlink" title="ls"></a>ls</h3><p>很常用的命令,显示目标目录下的文件，日常用到主要有以下几种:</p><ul><li>1.显示<code>/home</code>文件夹下所有文件(包含隐藏文件);</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ls -A /home</span><br><span class="line">$ ls -a /home</span><br><span class="line"><span class="comment"># -A与-a的区别是前者是不显示当前目录`(.)`与父级目录`(..)`。</span></span><br></pre></td></tr></table></figure><ul><li>2.显示<code>/home</code>文件夹下的所有文件和目录的详细资料;</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ls -lR /home</span><br></pre></td></tr></table></figure><ul><li>3.只显示<code>/home</code>子目录</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ls -F /home | grep /</span><br></pre></td></tr></table></figure><ul><li>4.列出”a”开头的所有目录的详细内容</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ls -l a*</span><br><span class="line"><span class="comment"># 这里*就是代表任意字母 (a结尾-*a, a中间-*a*)</span></span><br></pre></td></tr></table></figure><ul><li>5.计算当前目录下的文件数和目录数</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ls -l * | grep <span class="string">"^_"</span> | wc -l</span><br><span class="line">$ ls -l * | grep <span class="string">"^d"</span> | wc -l</span><br></pre></td></tr></table></figure><h3 id="cd"><a href="#cd" class="headerlink" title="cd"></a>cd</h3><p>这个太常见了，用来切换到指定目录，那么你知道还可以返回到你上次的目录么？那就是<code>cd -</code>命令。</p><h3 id="pwd"><a href="#pwd" class="headerlink" title="pwd"></a>pwd</h3><p>平常都用这个命令看自己现在在哪个目录，其实它的<code>-P,-L</code>参数可以显示出实际路径与连接路径。</p><h3 id="mkdir"><a href="#mkdir" class="headerlink" title="mkdir"></a>mkdir</h3><p>在指定位置创建目录。<code>-v</code>可以显示创建信息哦。</p><ul><li><p>1.创建目录；</p></li><li><p>2.递归创建多个目录；</p></li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ mkdir -p <span class="built_in">test</span>/test1/test2</span><br><span class="line"> </span><br><span class="line">$ tree <span class="built_in">test</span></span><br><span class="line"><span class="built_in">test</span></span><br><span class="line">└── test1</span><br><span class="line">    └── test2</span><br></pre></td></tr></table></figure><ul><li>3.创建一个目录结构；</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ mkdir -p s/&#123;s2/&#123;s3,s4&#125;,s5,s6/&#123;s7,s8/s9&#125;&#125;</span><br><span class="line"></span><br><span class="line">$ tree s</span><br><span class="line">s</span><br><span class="line">├── s2</span><br><span class="line">│   ├── s3</span><br><span class="line">│   └── s4</span><br><span class="line">├── s5</span><br><span class="line">└── s6</span><br><span class="line">    ├── s7</span><br><span class="line">    └── s8</span><br><span class="line">        └── s9</span><br></pre></td></tr></table></figure><ul><li>4.创建时设置权限。</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ mkdir -m 666 test2</span><br></pre></td></tr></table></figure><h3 id="rm"><a href="#rm" class="headerlink" title="rm"></a>rm</h3><p>删除文件目录就靠它了。</p><ul><li><p>1.删除指定文件；</p></li><li><p>2.强制删除,不提示；</p></li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ rm -f a.txt</span><br></pre></td></tr></table></figure><ul><li>3.删除目录及目录下文件</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ rm -r a/</span><br></pre></td></tr></table></figure><p><em>当然以上两个一起<code>rm -rf</code>就有很有故事了</em></p><h3 id="mv"><a href="#mv" class="headerlink" title="mv"></a>mv</h3><ul><li>1.文件改名；</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ mv a.txt b.txt</span><br></pre></td></tr></table></figure><ul><li>2.文件(目录)移动；</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ mv a.txt dir_a/</span><br><span class="line">$ mv dir_a dir_b  <span class="comment"># dir_b不存在时,将dir_a改名为dir_b</span></span><br></pre></td></tr></table></figure><ul><li>3.同时移动多个文件；</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ mv a.txt b.txt c.txt dir_a/</span><br></pre></td></tr></table></figure><ul><li>4.强制移动(改名)，如果有同名覆盖；</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ mv -f a.txt b.txt</span><br></pre></td></tr></table></figure><h3 id="cp"><a href="#cp" class="headerlink" title="cp"></a>cp</h3><p>复制文件目录。</p><ul><li>1.复制文件到目录；</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ cp a.txt dir_a</span><br></pre></td></tr></table></figure><ul><li>2.复制目录；</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ cp -r dir_a dir_b</span><br></pre></td></tr></table></figure><p><em>注意：如果dir_b存在，则将dir_a整个目录复制到dir_b下面，否则只是将dir_a下的文件全部复制到dir_b下面。</em></p><ul><li>3.建立快捷方式，也就是连接。</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ cp -s a.txt a_l.txt</span><br></pre></td></tr></table></figure><h3 id="touch"><a href="#touch" class="headerlink" title="touch"></a>touch</h3><p>创建文件。</p><h3 id="cat"><a href="#cat" class="headerlink" title="cat"></a>cat</h3><p>平常要查看一个文件的内容常用这个命令，当然他还有其他几个实用的用途。</p><ul><li>1.将几个文件合并到一个文件；</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ cat a.txt b.txt &gt; c.txt</span><br></pre></td></tr></table></figure><ul><li>2.将文件加上行号输入到另外一个文件；</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ cat -n a.txt &gt; d.txt</span><br><span class="line">$ cat -n a.txt b.txt &gt; e.txt</span><br><span class="line"></span><br><span class="line">$ cat a.txt</span><br><span class="line">shdasdahdasdadhZZ</span><br><span class="line">$ cat b.txt</span><br><span class="line">sss</span><br><span class="line">s</span><br><span class="line">s</span><br><span class="line">s</span><br><span class="line">s</span><br><span class="line">s</span><br><span class="line">s</span><br><span class="line">s</span><br><span class="line"></span><br><span class="line">dada</span><br><span class="line">$ cat e.txt</span><br><span class="line">     1  shdasdahdasdadhZZ</span><br><span class="line">     1  ss</span><br><span class="line">     2  sss</span><br><span class="line">     3  s</span><br><span class="line">     4  s</span><br><span class="line">     5  s</span><br><span class="line">     6  s</span><br><span class="line">     7  s</span><br><span class="line">     8  s</span><br><span class="line">     9  s</span><br><span class="line">    10</span><br><span class="line">    11  dada</span><br></pre></td></tr></table></figure><ul><li>3.如果上面合并时空白行不编号，你可以这样。</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ cat -b a.txt b.txt &gt; f.txt</span><br><span class="line"></span><br><span class="line">$ cat f.txt</span><br><span class="line">     1  shdasdahdasdadhZZ</span><br><span class="line">     1  ss</span><br><span class="line">     2  sss</span><br><span class="line">     3  s</span><br><span class="line">     4  s</span><br><span class="line">     5  s</span><br><span class="line">     6  s</span><br><span class="line">     7  s</span><br><span class="line">     8  s</span><br><span class="line">     9  s</span><br><span class="line"></span><br><span class="line">    10  dada</span><br></pre></td></tr></table></figure><h3 id="nl"><a href="#nl" class="headerlink" title="nl"></a>nl</h3><p>通常用来计算文件中的行号。</p><p><em>虽然<code>cat -n</code> 也可以输出行号，但其默认的结果与<code>cat -n</code> 有点不太一样， <code>nl</code> 可以将行号做比较多的显示设计，包括位数与是否自动补齐 0 等等的功能。</em></p><ul><li>1.让行号前面自动补上0,统一输出格式。</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ nl -b a -n rz b.txt</span><br><span class="line">000001  ss</span><br><span class="line">000002  sss</span><br><span class="line">000003  s</span><br><span class="line">000004  s</span><br><span class="line">000005  s</span><br><span class="line">000006  s</span><br><span class="line">000007  s</span><br><span class="line">000008  s</span><br><span class="line">000009  s</span><br><span class="line">000010</span><br><span class="line">000011  dada</span><br></pre></td></tr></table></figure><h3 id="more"><a href="#more" class="headerlink" title="more"></a>more</h3><p>more命令，功能类似 cat ，cat命令是整个文件的内容从上到下显示在屏幕上。 more会以一页一页的显示方便使用者逐页阅读，而最基本的指令就是按空白键（space）就往下一页显示，按 b 键就会往回（back）一页显示，而且还有搜寻字串的功能 。more命令从前向后读取文件，因此在启动时就加载整个文件。</p><ul><li>1.设定每屏显示的行数；</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ more -10 c.txt</span><br></pre></td></tr></table></figure><ul><li>2.从第n行开始显示内容；</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ more +3 c.txt</span><br></pre></td></tr></table></figure><ul><li>3.查找文件中第一个出现”txt”的文本，从该行显示后面的内容；</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ more +/txt c.txt</span><br></pre></td></tr></table></figure><p><em>more命令的内容很多，很多vi内的命令在这都可以用上，与more类似功能的还要less命令。</em></p><h3 id="tail"><a href="#tail" class="headerlink" title="tail"></a>tail</h3><p>tail 命令从指定点开始将文件写到标准输出，平常我们多用他来追踪日志。</p><ul><li>1.显示文件最近的n行内容；</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ tail -n 5 d.log</span><br></pre></td></tr></table></figure><ul><li>2.循环查看文件内容；</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ tail -f d.log</span><br></pre></td></tr></table></figure><ul><li><ol start="3"><li>从第n行显示文件内容。</li></ol></li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ tail -n +5 d.log</span><br></pre></td></tr></table></figure><h3 id="head"><a href="#head" class="headerlink" title="head"></a>head</h3><p>从字面意思就很好理解，显示文件开头的内容。</p><ul><li>1.显示文件的开头5行；</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ head -n 5 d.log</span><br></pre></td></tr></table></figure><ul><li>2.显示文件的开头5个字节；</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ head -c 5 d.log</span><br></pre></td></tr></table></figure><h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><ul><li><a href="http://www.cnblogs.com/peida/archive/2012/12/05/2803591.html" target="_blank" rel="noopener">竹子~每天一个linux命令</a>*</li></ul>]]></content>
      <categories>
        <category>Linux 点滴</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>command</tag>
      </tags>
  </entry>
  <entry>
    <title>MIME Types 速查表</title>
    <url>//post/mime-types-quick-look.html</url>
    <content><![CDATA[<p>做web开发时，经常需要设置一些返回数据的类型的头部，也就是 MIME Types。 这遍博客就是收罗了大部分的类型, 如果以后发现新的会持续更新。</p><a id="more"></a><table><thead><tr><th>扩展</th><th>MIME 类型</th></tr></thead><tbody><tr><td>.3dm</td><td>x-world/x-3dmf</td></tr><tr><td>.3dmf</td><td>x-world/x-3dmf</td></tr><tr><td>.3gp</td><td>video/3gpp</td></tr><tr><td>.3gp</td><td>audio/3gpp</td></tr><tr><td>.3g2</td><td>video/3gpp2</td></tr><tr><td>.3g2</td><td>audio/3gpp2</td></tr><tr><td>.7z</td><td>application/x-7z-compressed</td></tr><tr><td>.a</td><td>application/octet-stream</td></tr><tr><td>.aab</td><td>application/x-authorware-bin</td></tr><tr><td>.aac</td><td>audio/aac</td></tr><tr><td>.aam</td><td>application/x-authorware-map</td></tr><tr><td>.aas</td><td>application/x-authorware-seg</td></tr><tr><td>.abc</td><td>text/vnd.abc</td></tr><tr><td>.acgi</td><td>text/html</td></tr><tr><td>.afl</td><td>video/animaflex</td></tr><tr><td>.ai</td><td>application/postscript</td></tr><tr><td>.aif</td><td>audio/aiff</td></tr><tr><td>.aif</td><td>audio/x-aiff</td></tr><tr><td>.aifc</td><td>audio/aiff</td></tr><tr><td>.aifc</td><td>audio/x-aiff</td></tr><tr><td>.aiff</td><td>audio/aiff</td></tr><tr><td>.aiff</td><td>audio/x-aiff</td></tr><tr><td>.aim</td><td>application/x-aim</td></tr><tr><td>.aip</td><td>text/x-audiosoft-intra</td></tr><tr><td>.ani</td><td>application/x-navi-animation</td></tr><tr><td>.aos</td><td>application/x-nokia-9000-communicator-add-on-software</td></tr><tr><td>.aps</td><td>application/mime</td></tr><tr><td>.arc</td><td>application/octet-stream</td></tr><tr><td>.arj</td><td>application/arj</td></tr><tr><td>.arj</td><td>application/octet-stream</td></tr><tr><td>.art</td><td>image/x-jg</td></tr><tr><td>.asf</td><td>video/x-ms-asf</td></tr><tr><td>.asm</td><td>text/x-asm</td></tr><tr><td>.asp</td><td>text/asp</td></tr><tr><td>.asx</td><td>application/x-mplayer2</td></tr><tr><td>.asx</td><td>video/x-ms-asf</td></tr><tr><td>.asx</td><td>video/x-ms-asf-plugin</td></tr><tr><td>.au</td><td>audio/basic</td></tr><tr><td>.au</td><td>audio/x-au</td></tr><tr><td>.avi</td><td>application/x-troff-msvideo</td></tr><tr><td>.avi</td><td>video/avi</td></tr><tr><td>.avi</td><td>video/msvideo</td></tr><tr><td>.avi</td><td>video/x-msvideo</td></tr><tr><td>.avs</td><td>video/avs-video</td></tr><tr><td>.azw</td><td>application/vnd.amazon.ebook</td></tr><tr><td>.bcpio</td><td>application/x-bcpio</td></tr><tr><td>.bin</td><td>application/mac-binary</td></tr><tr><td>.bin</td><td>application/macbinary</td></tr><tr><td>.bin</td><td>application/octet-stream</td></tr><tr><td>.bin</td><td>application/x-binary</td></tr><tr><td>.bin</td><td>application/x-macbinary</td></tr><tr><td>.bm</td><td>image/bmp</td></tr><tr><td>.bmp</td><td>image/bmp</td></tr><tr><td>.bmp</td><td>image/x-windows-bmp</td></tr><tr><td>.boo</td><td>application/book</td></tr><tr><td>.book</td><td>application/book</td></tr><tr><td>.boz</td><td>application/x-bzip2</td></tr><tr><td>.bsh</td><td>application/x-bsh</td></tr><tr><td>.bz</td><td>application/x-bzip</td></tr><tr><td>.bz2</td><td>application/x-bzip2</td></tr><tr><td>.c</td><td>text/plain</td></tr><tr><td>.c</td><td>text/x-c</td></tr><tr><td>.c</td><td>++ text/plain</td></tr><tr><td>.cat</td><td>application/vnd.ms-pki.seccat</td></tr><tr><td>.cc</td><td>text/plain</td></tr><tr><td>.cc</td><td>text/x-c</td></tr><tr><td>.ccad</td><td>application/clariscad</td></tr><tr><td>.cco</td><td>application/x-cocoa</td></tr><tr><td>.cdf</td><td>application/cdf</td></tr><tr><td>.cdf</td><td>application/x-cdf</td></tr><tr><td>.cdf</td><td>application/x-netcdf</td></tr><tr><td>.cer</td><td>application/pkix-cert</td></tr><tr><td>.cer</td><td>application/x-x509-ca-cert</td></tr><tr><td>.cha</td><td>application/x-chat</td></tr><tr><td>.chat</td><td>application/x-chat</td></tr><tr><td>.class</td><td>application/java</td></tr><tr><td>.class</td><td>application/java-byte-code</td></tr><tr><td>.class</td><td>application/x-java-class</td></tr><tr><td>.com</td><td>application/octet-stream</td></tr><tr><td>.com</td><td>text/plain</td></tr><tr><td>.conf</td><td>text/plain</td></tr><tr><td>.cpio</td><td>application/x-cpio</td></tr><tr><td>.cpp</td><td>text/x-c</td></tr><tr><td>.cpt</td><td>application/mac-compactpro</td></tr><tr><td>.cpt</td><td>application/x-compactpro</td></tr><tr><td>.cpt</td><td>application/x-cpt</td></tr><tr><td>.crl</td><td>application/pkcs-crl</td></tr><tr><td>.crl</td><td>application/pkix-crl</td></tr><tr><td>.crt</td><td>application/pkix-cert</td></tr><tr><td>.crt</td><td>application/x-x509-ca-cert</td></tr><tr><td>.crt</td><td>application/x-x509-user-cert</td></tr><tr><td>.csh</td><td>application/x-csh</td></tr><tr><td>.csh</td><td>text/x-script.csh</td></tr><tr><td>.csr</td><td>application/pkcs10</td></tr><tr><td>.css</td><td>application/x-pointplus</td></tr><tr><td>.css</td><td>text/css</td></tr><tr><td>.csv</td><td>text/csv</td></tr><tr><td>.cxx</td><td>text/plain</td></tr><tr><td>.dcr</td><td>application/x-director</td></tr><tr><td>.deepv</td><td>application/x-deepv</td></tr><tr><td>.def</td><td>text/plain</td></tr><tr><td>.der</td><td>application/x-x509-ca-cert</td></tr><tr><td>.dif</td><td>video/x-dv</td></tr><tr><td>.dir</td><td>application/x-director</td></tr><tr><td>.dl</td><td>video/dl</td></tr><tr><td>.dl</td><td>video/x-dl</td></tr><tr><td>.doc</td><td>application/msword</td></tr><tr><td>.docx</td><td>application/vnd.openxmlformats-officedocument.wordprocessingml.document</td></tr><tr><td>.dot</td><td>application/msword</td></tr><tr><td>.dp</td><td>application/commonground</td></tr><tr><td>.drw</td><td>application/drafting</td></tr><tr><td>.dump</td><td>application/octet-stream</td></tr><tr><td>.dv</td><td>video/x-dv</td></tr><tr><td>.dvi</td><td>application/x-dvi</td></tr><tr><td>.dwf</td><td>drawing/x-dwf (old)</td></tr><tr><td>.dwf</td><td>model/vnd.dwf</td></tr><tr><td>.dwg</td><td>application/acad</td></tr><tr><td>.dwg</td><td>image/vnd.dwg</td></tr><tr><td>.dwg</td><td>image/x-dwg</td></tr><tr><td>.dxf</td><td>application/dxf</td></tr><tr><td>.dxf</td><td>image/vnd.dwg</td></tr><tr><td>.dxf</td><td>image/x-dwg</td></tr><tr><td>.dxr</td><td>application/x-director</td></tr><tr><td>.el</td><td>text/x-script.elisp</td></tr><tr><td>.elc</td><td>application/x-bytecode.elisp (compiled elisp)</td></tr><tr><td>.elc</td><td>application/x-elc</td></tr><tr><td>.env</td><td>application/x-envoy</td></tr><tr><td>.eps</td><td>application/postscript</td></tr><tr><td>.es</td><td>application/x-esrehber</td></tr><tr><td>.etx</td><td>text/x-setext</td></tr><tr><td>.eot</td><td>application/vnd.ms-fontobject</td></tr><tr><td>.epub</td><td>application/epub+zip</td></tr><tr><td>.evy</td><td>application/envoy</td></tr><tr><td>.evy</td><td>application/x-envoy</td></tr><tr><td>.exe</td><td>application/octet-stream</td></tr><tr><td>.f</td><td>text/plain</td></tr><tr><td>.f</td><td>text/x-fortran</td></tr><tr><td>.f77</td><td>text/x-fortran</td></tr><tr><td>.f90</td><td>text/plain</td></tr><tr><td>.f90</td><td>text/x-fortran</td></tr><tr><td>.fdf</td><td>application/vnd.fdf</td></tr><tr><td>.fif</td><td>application/fractals</td></tr><tr><td>.fif</td><td>image/fif</td></tr><tr><td>.fli</td><td>video/fli</td></tr><tr><td>.fli</td><td>video/x-fli</td></tr><tr><td>.flo</td><td>image/florian</td></tr><tr><td>.flx</td><td>text/vnd.fmi.flexstor</td></tr><tr><td>.fmf</td><td>video/x-atomic3d-feature</td></tr><tr><td>.for</td><td>text/plain</td></tr><tr><td>.for</td><td>text/x-fortran</td></tr><tr><td>.fpx</td><td>image/vnd.fpx</td></tr><tr><td>.fpx</td><td>image/vnd.net-fpx</td></tr><tr><td>.frl</td><td>application/freeloader</td></tr><tr><td>.funk</td><td>audio/make</td></tr><tr><td>.g</td><td>text/plain</td></tr><tr><td>.g3</td><td>image/g3fax</td></tr><tr><td>.gif</td><td>image/gif</td></tr><tr><td>.gl</td><td>video/gl</td></tr><tr><td>.gl</td><td>video/x-gl</td></tr><tr><td>.gsd</td><td>audio/x-gsm</td></tr><tr><td>.gsm</td><td>audio/x-gsm</td></tr><tr><td>.gsp</td><td>application/x-gsp</td></tr><tr><td>.gss</td><td>application/x-gss</td></tr><tr><td>.gtar</td><td>application/x-gtar</td></tr><tr><td>.gz</td><td>application/x-compressed</td></tr><tr><td>.gz</td><td>application/x-gzip</td></tr><tr><td>.gzip</td><td>application/x-gzip</td></tr><tr><td>.gzip</td><td>multipart/x-gzip</td></tr><tr><td>.h</td><td>text/plain</td></tr><tr><td>.h</td><td>text/x-h</td></tr><tr><td>.hdf</td><td>application/x-hdf</td></tr><tr><td>.help</td><td>application/x-helpfile</td></tr><tr><td>.hgl</td><td>application/vnd.hp-hpgl</td></tr><tr><td>.hh</td><td>text/plain</td></tr><tr><td>.hh</td><td>text/x-h</td></tr><tr><td>.hlb</td><td>text/x-script</td></tr><tr><td>.hlp</td><td>application/hlp</td></tr><tr><td>.hlp</td><td>application/x-helpfile</td></tr><tr><td>.hlp</td><td>application/x-winhelp</td></tr><tr><td>.hpg</td><td>application/vnd.hp-hpgl</td></tr><tr><td>.hpgl</td><td>application/vnd.hp-hpgl</td></tr><tr><td>.hqx</td><td>application/binhex</td></tr><tr><td>.hqx</td><td>application/binhex4</td></tr><tr><td>.hqx</td><td>application/mac-binhex</td></tr><tr><td>.hqx</td><td>application/mac-binhex40</td></tr><tr><td>.hqx</td><td>application/x-binhex40</td></tr><tr><td>.hqx</td><td>application/x-mac-binhex40</td></tr><tr><td>.hta</td><td>application/hta</td></tr><tr><td>.htc</td><td>text/x-component</td></tr><tr><td>.htm</td><td>text/html</td></tr><tr><td>.html</td><td>text/html</td></tr><tr><td>.htmls</td><td>text/html</td></tr><tr><td>.htt</td><td>text/webviewhtml</td></tr><tr><td>.htx</td><td>text/html</td></tr><tr><td>.ice</td><td>x-conference/x-cooltalk</td></tr><tr><td>.ico</td><td>image/x-icon</td></tr><tr><td>.ics</td><td>text/calendar</td></tr><tr><td>.idc</td><td>text/plain</td></tr><tr><td>.ief</td><td>image/ief</td></tr><tr><td>.iefs</td><td>image/ief</td></tr><tr><td>.iges</td><td>application/iges</td></tr><tr><td>.iges</td><td>model/iges</td></tr><tr><td>.igs</td><td>application/iges</td></tr><tr><td>.igs</td><td>model/iges</td></tr><tr><td>.ima</td><td>application/x-ima</td></tr><tr><td>.imap</td><td>application/x-httpd-imap</td></tr><tr><td>.inf</td><td>application/inf</td></tr><tr><td>.ins</td><td>application/x-internett-signup</td></tr><tr><td>.ip</td><td>application/x-ip2</td></tr><tr><td>.isu</td><td>video/x-isvideo</td></tr><tr><td>.it</td><td>audio/it</td></tr><tr><td>.iv</td><td>application/x-inventor</td></tr><tr><td>.ivr</td><td>i-world/i-vrml</td></tr><tr><td>.ivy</td><td>application/x-livescreen</td></tr><tr><td>.jam</td><td>audio/x-jam</td></tr><tr><td>.jar</td><td>application/java-archive</td></tr><tr><td>.jav</td><td>text/plain</td></tr><tr><td>.jav</td><td>text/x-java-source</td></tr><tr><td>.java</td><td>text/plain</td></tr><tr><td>.java</td><td>text/x-java-source</td></tr><tr><td>.jcm</td><td>application/x-java-commerce</td></tr><tr><td>.jfif</td><td>image/jpeg</td></tr><tr><td>.jfif</td><td>image/pjpeg</td></tr><tr><td>.jfif</td><td>-tbnl image/jpeg</td></tr><tr><td>.jpe</td><td>image/jpeg</td></tr><tr><td>.jpe</td><td>image/pjpeg</td></tr><tr><td>.jpeg</td><td>image/jpeg</td></tr><tr><td>.jpeg</td><td>image/pjpeg</td></tr><tr><td>.jpg</td><td>image/jpeg</td></tr><tr><td>.jpg</td><td>image/pjpeg</td></tr><tr><td>.jps</td><td>image/x-jps</td></tr><tr><td>.js</td><td>application/x-javascript</td></tr><tr><td>.js</td><td>application/javascript</td></tr><tr><td>.js</td><td>application/ecmascript</td></tr><tr><td>.js</td><td>text/javascript</td></tr><tr><td>.js</td><td>text/ecmascript</td></tr><tr><td>.json</td><td>application/json</td></tr><tr><td>.jut</td><td>image/jutvision</td></tr><tr><td>.kar</td><td>audio/midi</td></tr><tr><td>.kar</td><td>music/x-karaoke</td></tr><tr><td>.key</td><td>application/pkcs8</td></tr><tr><td>.ksh</td><td>application/x-ksh</td></tr><tr><td>.ksh</td><td>text/x-script.ksh</td></tr><tr><td>.la</td><td>audio/nspaudio</td></tr><tr><td>.la</td><td>audio/x-nspaudio</td></tr><tr><td>.lam</td><td>audio/x-liveaudio</td></tr><tr><td>.latex</td><td>application/x-latex</td></tr><tr><td>.lha</td><td>application/lha</td></tr><tr><td>.lha</td><td>application/octet-stream</td></tr><tr><td>.lha</td><td>application/x-lha</td></tr><tr><td>.lhx</td><td>application/octet-stream</td></tr><tr><td>.list</td><td>text/plain</td></tr><tr><td>.lma</td><td>audio/nspaudio</td></tr><tr><td>.lma</td><td>audio/x-nspaudio</td></tr><tr><td>.log</td><td>text/plain</td></tr><tr><td>.lsp</td><td>application/x-lisp</td></tr><tr><td>.lsp</td><td>text/x-script.lisp</td></tr><tr><td>.lst</td><td>text/plain</td></tr><tr><td>.lsx</td><td>text/x-la-asf</td></tr><tr><td>.ltx</td><td>application/x-latex</td></tr><tr><td>.lzh</td><td>application/octet-stream</td></tr><tr><td>.lzh</td><td>application/x-lzh</td></tr><tr><td>.lzx</td><td>application/lzx</td></tr><tr><td>.lzx</td><td>application/octet-stream</td></tr><tr><td>.lzx</td><td>application/x-lzx</td></tr><tr><td>.m</td><td>text/plain</td></tr><tr><td>.m</td><td>text/x-m</td></tr><tr><td>.m1v</td><td>video/mpeg</td></tr><tr><td>.m2a</td><td>audio/mpeg</td></tr><tr><td>.m2v</td><td>video/mpeg</td></tr><tr><td>.m3u</td><td>audio/x-mpequrl</td></tr><tr><td>.man</td><td>application/x-troff-man</td></tr><tr><td>.map</td><td>application/x-navimap</td></tr><tr><td>.mar</td><td>text/plain</td></tr><tr><td>.mbd</td><td>application/mbedlet</td></tr><tr><td>.mc</td><td>$ application/x-magic-cap-package-1.0</td></tr><tr><td>.mcd</td><td>application/mcad</td></tr><tr><td>.mcd</td><td>application/x-mathcad</td></tr><tr><td>.mcf</td><td>image/vasa</td></tr><tr><td>.mcf</td><td>text/mcf</td></tr><tr><td>.mcp</td><td>application/netmc</td></tr><tr><td>.me</td><td>application/x-troff-me</td></tr><tr><td>.mht</td><td>message/rfc822</td></tr><tr><td>.mhtml</td><td>message/rfc822</td></tr><tr><td>.mid</td><td>application/x-midi</td></tr><tr><td>.mid</td><td>audio/midi</td></tr><tr><td>.mid</td><td>audio/x-mid</td></tr><tr><td>.mid</td><td>audio/x-midi</td></tr><tr><td>.mid</td><td>music/crescendo</td></tr><tr><td>.mid</td><td>x-music/x-midi</td></tr><tr><td>.midi</td><td>application/x-midi</td></tr><tr><td>.midi</td><td>audio/midi</td></tr><tr><td>.midi</td><td>audio/x-mid</td></tr><tr><td>.midi</td><td>audio/x-midi</td></tr><tr><td>.midi</td><td>music/crescendo</td></tr><tr><td>.midi</td><td>x-music/x-midi</td></tr><tr><td>.mif</td><td>application/x-frame</td></tr><tr><td>.mif</td><td>application/x-mif</td></tr><tr><td>.mime</td><td>message/rfc822</td></tr><tr><td>.mime</td><td>www/mime</td></tr><tr><td>.mjf</td><td>audio/x-vnd.audioexplosion.mjuicemediafile</td></tr><tr><td>.mjpg</td><td>video/x-motion-jpeg</td></tr><tr><td>.mjs</td><td>application/javascript</td></tr><tr><td>.mm</td><td>application/base64</td></tr><tr><td>.mm</td><td>application/x-meme</td></tr><tr><td>.mme</td><td>application/base64</td></tr><tr><td>.mod</td><td>audio/mod</td></tr><tr><td>.mod</td><td>audio/x-mod</td></tr><tr><td>.moov</td><td>video/quicktime</td></tr><tr><td>.mov</td><td>video/quicktime</td></tr><tr><td>.movie</td><td>video/x-sgi-movie</td></tr><tr><td>.mp2</td><td>audio/mpeg</td></tr><tr><td>.mp2</td><td>audio/x-mpeg</td></tr><tr><td>.mp2</td><td>video/mpeg</td></tr><tr><td>.mp2</td><td>video/x-mpeg</td></tr><tr><td>.mp2</td><td>video/x-mpeq2a</td></tr><tr><td>.mp3</td><td>audio/mpeg3</td></tr><tr><td>.mp3</td><td>audio/x-mpeg-3</td></tr><tr><td>.mp3</td><td>video/mpeg</td></tr><tr><td>.mp3</td><td>video/x-mpeg</td></tr><tr><td>.mpa</td><td>audio/mpeg</td></tr><tr><td>.mpa</td><td>video/mpeg</td></tr><tr><td>.mpc</td><td>application/x-project</td></tr><tr><td>.mpe</td><td>video/mpeg</td></tr><tr><td>.mpeg</td><td>video/mpeg</td></tr><tr><td>.mpg</td><td>audio/mpeg</td></tr><tr><td>.mpg</td><td>video/mpeg</td></tr><tr><td>.mpga</td><td>audio/mpeg</td></tr><tr><td>.mpp</td><td>application/vnd.ms-project</td></tr><tr><td>.mpt</td><td>application/x-project</td></tr><tr><td>.mpv</td><td>application/x-project</td></tr><tr><td>.mpx</td><td>application/x-project</td></tr><tr><td>.mrc</td><td>application/marc</td></tr><tr><td>.ms</td><td>application/x-troff-ms</td></tr><tr><td>.mv</td><td>video/x-sgi-movie</td></tr><tr><td>.my</td><td>audio/make</td></tr><tr><td>.mzz</td><td>application/x-vnd.audioexplosion.mzz</td></tr><tr><td>.nap</td><td>image/naplps</td></tr><tr><td>.naplps</td><td>image/naplps</td></tr><tr><td>.nc</td><td>application/x-netcdf</td></tr><tr><td>.ncm</td><td>application/vnd.nokia.configuration-message</td></tr><tr><td>.nif</td><td>image/x-niff</td></tr><tr><td>.niff</td><td>image/x-niff</td></tr><tr><td>.nix</td><td>application/x-mix-transfer</td></tr><tr><td>.nsc</td><td>application/x-conference</td></tr><tr><td>.nvd</td><td>application/x-navidoc</td></tr><tr><td>.o</td><td>application/octet-stream</td></tr><tr><td>.oda</td><td>application/oda</td></tr><tr><td>.odp</td><td>application/vnd.oasis.opendocument.presentation</td></tr><tr><td>.ods</td><td>application/vnd.oasis.opendocument.spreadsheet</td></tr><tr><td>.odt</td><td>application/vnd.oasis.opendocument.text</td></tr><tr><td>.oga</td><td>audio/ogg</td></tr><tr><td>.ogv</td><td>video/ogg</td></tr><tr><td>.ogx</td><td>application/ogg</td></tr><tr><td>.omc</td><td>application/x-omc</td></tr><tr><td>.otf</td><td>font/otf</td></tr><tr><td>.omcd</td><td>application/x-omcdatamaker</td></tr><tr><td>.omcr</td><td>application/x-omcregerator</td></tr><tr><td>.p</td><td>text/x-pascal</td></tr><tr><td>.p8</td><td>application/pkcs8</td></tr><tr><td>.p10</td><td>application/pkcs10</td></tr><tr><td>.p10</td><td>application/x-pkcs10</td></tr><tr><td>.p12</td><td>application/pkcs-12</td></tr><tr><td>.p12</td><td>application/x-pkcs12</td></tr><tr><td>.p7a</td><td>application/x-pkcs7-signature</td></tr><tr><td>.p7b</td><td>application/x-pkcs7-certificates</td></tr><tr><td>.p7c</td><td>application/pkcs7-mime</td></tr><tr><td>.p7c</td><td>application/x-pkcs7-mime</td></tr><tr><td>.p7m</td><td>application/pkcs7-mime</td></tr><tr><td>.p7m</td><td>application/x-pkcs7-mime</td></tr><tr><td>.p7r</td><td>application/x-pkcs7-certreqresp</td></tr><tr><td>.p7s</td><td>application/pkcs7-signature</td></tr><tr><td>.part</td><td>application/pro_eng</td></tr><tr><td>.pas</td><td>text/pascal</td></tr><tr><td>.pbm</td><td>image/x-portable-bitmap</td></tr><tr><td>.pcl</td><td>application/vnd.hp-pcl</td></tr><tr><td>.pcl</td><td>application/x-pcl</td></tr><tr><td>.pct</td><td>image/x-pict</td></tr><tr><td>.pcx</td><td>image/x-pcx</td></tr><tr><td>.pdb</td><td>chemical/x-pdb</td></tr><tr><td>.pdf</td><td>application/pdf</td></tr><tr><td>.pem</td><td>application/x-pem-file</td></tr><tr><td>.pfunk</td><td>audio/make</td></tr><tr><td>.pfunk</td><td>audio/make.my.funk</td></tr><tr><td>.pfx</td><td>application/x-pkcs12</td></tr><tr><td>.pgm</td><td>image/x-portable-graymap</td></tr><tr><td>.pgm</td><td>image/x-portable-greymap</td></tr><tr><td>.pic</td><td>image/pict</td></tr><tr><td>.pict</td><td>image/pict</td></tr><tr><td>.pkg</td><td>application/x-newton-compatible-pkg</td></tr><tr><td>.pko</td><td>application/vnd.ms-pki.pko</td></tr><tr><td>.pl</td><td>text/plain</td></tr><tr><td>.pl</td><td>text/x-script.perl</td></tr><tr><td>.plx</td><td>application/x-pixclscript</td></tr><tr><td>.pm</td><td>image/x-xpixmap</td></tr><tr><td>.pm</td><td>text/x-script.perl-module</td></tr><tr><td>.pm4</td><td>application/x-pagemaker</td></tr><tr><td>.pm5</td><td>application/x-pagemaker</td></tr><tr><td>.png</td><td>image/png</td></tr><tr><td>.pnm</td><td>application/x-portable-anymap</td></tr><tr><td>.pnm</td><td>image/x-portable-anymap</td></tr><tr><td>.pot</td><td>application/mspowerpoint</td></tr><tr><td>.pot</td><td>application/vnd.ms-powerpoint</td></tr><tr><td>.pov</td><td>model/x-pov</td></tr><tr><td>.ppa</td><td>application/vnd.ms-powerpoint</td></tr><tr><td>.ppm</td><td>image/x-portable-pixmap</td></tr><tr><td>.pps</td><td>application/mspowerpoint</td></tr><tr><td>.pps</td><td>application/vnd.ms-powerpoint</td></tr><tr><td>.ppt</td><td>application/mspowerpoint</td></tr><tr><td>.ppt</td><td>application/powerpoint</td></tr><tr><td>.ppt</td><td>application/vnd.ms-powerpoint</td></tr><tr><td>.ppt</td><td>application/x-mspowerpoint</td></tr><tr><td>.pptx</td><td>application/vnd.openxmlformats-officedocument.presentationml.presentation</td></tr><tr><td>.ppz</td><td>application/mspowerpoint</td></tr><tr><td>.pre</td><td>application/x-freelance</td></tr><tr><td>.prt</td><td>application/pro_eng</td></tr><tr><td>.ps</td><td>application/postscript</td></tr><tr><td>.psd</td><td>application/octet-stream</td></tr><tr><td>.pvu</td><td>paleovu/x-pv</td></tr><tr><td>.pwz</td><td>application/vnd.ms-powerpoint</td></tr><tr><td>.py</td><td>text/x-script.phyton</td></tr><tr><td>.pyc</td><td>application/x-bytecode.python</td></tr><tr><td>.qcp</td><td>audio/vnd.qcelp</td></tr><tr><td>.qd3</td><td>x-world/x-3dmf</td></tr><tr><td>.qd3d</td><td>x-world/x-3dmf</td></tr><tr><td>.qif</td><td>image/x-quicktime</td></tr><tr><td>.qt</td><td>video/quicktime</td></tr><tr><td>.qtc</td><td>video/x-qtc</td></tr><tr><td>.qti</td><td>image/x-quicktime</td></tr><tr><td>.qtif</td><td>image/x-quicktime</td></tr><tr><td>.ra</td><td>audio/x-pn-realaudio</td></tr><tr><td>.ra</td><td>audio/x-pn-realaudio-plugin</td></tr><tr><td>.ra</td><td>audio/x-realaudio</td></tr><tr><td>.rar</td><td>application/x-rar-compressed</td></tr><tr><td>.ram</td><td>audio/x-pn-realaudio</td></tr><tr><td>.ras</td><td>application/x-cmu-raster</td></tr><tr><td>.ras</td><td>image/cmu-raster</td></tr><tr><td>.ras</td><td>image/x-cmu-raster</td></tr><tr><td>.rast</td><td>image/cmu-raster</td></tr><tr><td>.rexx</td><td>text/x-script.rexx</td></tr><tr><td>.rf</td><td>image/vnd.rn-realflash</td></tr><tr><td>.rgb</td><td>image/x-rgb</td></tr><tr><td>.rm</td><td>application/vnd.rn-realmedia</td></tr><tr><td>.rm</td><td>audio/x-pn-realaudio</td></tr><tr><td>.rmi</td><td>audio/mid</td></tr><tr><td>.rmm</td><td>audio/x-pn-realaudio</td></tr><tr><td>.rmp</td><td>audio/x-pn-realaudio</td></tr><tr><td>.rmp</td><td>audio/x-pn-realaudio-plugin</td></tr><tr><td>.rng</td><td>application/ringing-tones</td></tr><tr><td>.rng</td><td>application/vnd.nokia.ringing-tone</td></tr><tr><td>.rnx</td><td>application/vnd.rn-realplayer</td></tr><tr><td>.roff</td><td>application/x-troff</td></tr><tr><td>.rp</td><td>image/vnd.rn-realpix</td></tr><tr><td>.rpm</td><td>audio/x-pn-realaudio-plugin</td></tr><tr><td>.rt</td><td>text/richtext</td></tr><tr><td>.rt</td><td>text/vnd.rn-realtext</td></tr><tr><td>.rtf</td><td>application/rtf</td></tr><tr><td>.rtf</td><td>application/x-rtf</td></tr><tr><td>.rtf</td><td>text/richtext</td></tr><tr><td>.rtx</td><td>application/rtf</td></tr><tr><td>.rtx</td><td>text/richtext</td></tr><tr><td>.rv</td><td>video/vnd.rn-realvideo</td></tr><tr><td>.s</td><td>text/x-asm</td></tr><tr><td>.s3m</td><td>audio/s3m</td></tr><tr><td>.saveme</td><td>application/octet-stream</td></tr><tr><td>.sbk</td><td>application/x-tbook</td></tr><tr><td>.scm</td><td>application/x-lotusscreencam</td></tr><tr><td>.scm</td><td>text/x-script.guile</td></tr><tr><td>.scm</td><td>text/x-script.scheme</td></tr><tr><td>.scm</td><td>video/x-scm</td></tr><tr><td>.sdml</td><td>text/plain</td></tr><tr><td>.sdp</td><td>application/sdp</td></tr><tr><td>.sdp</td><td>application/x-sdp</td></tr><tr><td>.sdr</td><td>application/sounder</td></tr><tr><td>.sea</td><td>application/sea</td></tr><tr><td>.sea</td><td>application/x-sea</td></tr><tr><td>.set</td><td>application/set</td></tr><tr><td>.sgm</td><td>text/sgml</td></tr><tr><td>.sgm</td><td>text/x-sgml</td></tr><tr><td>.sgml</td><td>text/sgml</td></tr><tr><td>.sgml</td><td>text/x-sgml</td></tr><tr><td>.sh</td><td>application/x-bsh</td></tr><tr><td>.sh</td><td>application/x-sh</td></tr><tr><td>.sh</td><td>application/x-shar</td></tr><tr><td>.sh</td><td>text/x-script.sh</td></tr><tr><td>.shar</td><td>application/x-bsh</td></tr><tr><td>.shar</td><td>application/x-shar</td></tr><tr><td>.shtml</td><td>text/html</td></tr><tr><td>.shtml</td><td>text/x-server-parsed-html</td></tr><tr><td>.sid</td><td>audio/x-psid</td></tr><tr><td>.sit</td><td>application/x-sit</td></tr><tr><td>.sit</td><td>application/x-stuffit</td></tr><tr><td>.skd</td><td>application/x-koan</td></tr><tr><td>.skm</td><td>application/x-koan</td></tr><tr><td>.skp</td><td>application/x-koan</td></tr><tr><td>.skt</td><td>application/x-koan</td></tr><tr><td>.sl</td><td>application/x-seelogo</td></tr><tr><td>.smi</td><td>application/smil</td></tr><tr><td>.smil</td><td>application/smil</td></tr><tr><td>.snd</td><td>audio/basic</td></tr><tr><td>.snd</td><td>audio/x-adpcm</td></tr><tr><td>.sol</td><td>application/solids</td></tr><tr><td>.spc</td><td>application/x-pkcs7-certificates</td></tr><tr><td>.spc</td><td>text/x-speech</td></tr><tr><td>.spl</td><td>application/futuresplash</td></tr><tr><td>.spr</td><td>application/x-sprite</td></tr><tr><td>.sprite</td><td>application/x-sprite</td></tr><tr><td>.src</td><td>application/x-wais-source</td></tr><tr><td>.ssi</td><td>text/x-server-parsed-html</td></tr><tr><td>.ssm</td><td>application/streamingmedia</td></tr><tr><td>.sst</td><td>application/vnd.ms-pki.certstore</td></tr><tr><td>.step</td><td>application/step</td></tr><tr><td>.stl</td><td>application/sla</td></tr><tr><td>.stl</td><td>application/vnd.ms-pki.stl</td></tr><tr><td>.stl</td><td>application/x-navistyle</td></tr><tr><td>.stp</td><td>application/step</td></tr><tr><td>.sv4cpio</td><td>application/x-sv4cpio</td></tr><tr><td>.sv4crc</td><td>application/x-sv4crc</td></tr><tr><td>.svf</td><td>image/vnd.dwg</td></tr><tr><td>.svf</td><td>image/x-dwg</td></tr><tr><td>.svg</td><td>image/svg+xml</td></tr><tr><td>.svr</td><td>application/x-world</td></tr><tr><td>.svr</td><td>x-world/x-svr</td></tr><tr><td>.swf</td><td>application/x-shockwave-flash</td></tr><tr><td>.t</td><td>application/x-troff</td></tr><tr><td>.talk</td><td>text/x-speech</td></tr><tr><td>.tar</td><td>application/x-tar</td></tr><tr><td>.tbk</td><td>application/toolbook</td></tr><tr><td>.tbk</td><td>application/x-tbook</td></tr><tr><td>.tcl</td><td>application/x-tcl</td></tr><tr><td>.tcl</td><td>text/x-script.tcl</td></tr><tr><td>.tcsh</td><td>text/x-script.tcsh</td></tr><tr><td>.tex</td><td>application/x-tex</td></tr><tr><td>.texi</td><td>application/x-texinfo</td></tr><tr><td>.texinfo</td><td>application/x-texinfo</td></tr><tr><td>.text</td><td>application/plain</td></tr><tr><td>.text</td><td>text/plain</td></tr><tr><td>.tgz</td><td>application/gnutar</td></tr><tr><td>.tgz</td><td>application/x-compressed</td></tr><tr><td>.tif</td><td>image/tiff</td></tr><tr><td>.tif</td><td>image/x-tiff</td></tr><tr><td>.tiff</td><td>image/tiff</td></tr><tr><td>.tiff</td><td>image/x-tiff</td></tr><tr><td>.tr</td><td>application/x-troff</td></tr><tr><td>.tsi</td><td>audio/tsp-audio</td></tr><tr><td>.tsp</td><td>application/dsptype</td></tr><tr><td>.tsp</td><td>audio/tsplayer</td></tr><tr><td>.tsv</td><td>text/tab-separated-values</td></tr><tr><td>.turbot</td><td>image/florian</td></tr><tr><td>.txt</td><td>text/plain</td></tr><tr><td>.uil</td><td>text/x-uil</td></tr><tr><td>.uni</td><td>text/uri-list</td></tr><tr><td>.unis</td><td>text/uri-list</td></tr><tr><td>.unv</td><td>application/i-deas</td></tr><tr><td>.uri</td><td>text/uri-list</td></tr><tr><td>.uris</td><td>text/uri-list</td></tr><tr><td>.ustar</td><td>application/x-ustar</td></tr><tr><td>.ustar</td><td>multipart/x-ustar</td></tr><tr><td>.uu</td><td>application/octet-stream</td></tr><tr><td>.uu</td><td>text/x-uuencode</td></tr><tr><td>.uue</td><td>text/x-uuencode</td></tr><tr><td>.vcd</td><td>application/x-cdlink</td></tr><tr><td>.vcs</td><td>text/x-vcalendar</td></tr><tr><td>.vda</td><td>application/vda</td></tr><tr><td>.vdo</td><td>video/vdo</td></tr><tr><td>.vew</td><td>application/groupwise</td></tr><tr><td>.viv</td><td>video/vivo</td></tr><tr><td>.viv</td><td>video/vnd.vivo</td></tr><tr><td>.vivo</td><td>video/vivo</td></tr><tr><td>.vivo</td><td>video/vnd.vivo</td></tr><tr><td>.vmd</td><td>application/vocaltec-media-desc</td></tr><tr><td>.vmf</td><td>application/vocaltec-media-file</td></tr><tr><td>.voc</td><td>audio/voc</td></tr><tr><td>.voc</td><td>audio/x-voc</td></tr><tr><td>.vos</td><td>video/vosaic</td></tr><tr><td>.vox</td><td>audio/voxware</td></tr><tr><td>.vqe</td><td>audio/x-twinvq-plugin</td></tr><tr><td>.vqf</td><td>audio/x-twinvq</td></tr><tr><td>.vql</td><td>audio/x-twinvq-plugin</td></tr><tr><td>.vrml</td><td>application/x-vrml</td></tr><tr><td>.vrml</td><td>model/vrml</td></tr><tr><td>.vrml</td><td>x-world/x-vrml</td></tr><tr><td>.vrt</td><td>x-world/x-vrt</td></tr><tr><td>.vsd</td><td>application/x-visio</td></tr><tr><td>.vst</td><td>application/x-visio</td></tr><tr><td>.vsw</td><td>application/x-visio</td></tr><tr><td>.w60</td><td>application/wordperfect6.0</td></tr><tr><td>.w61</td><td>application/wordperfect6.1</td></tr><tr><td>.w6w</td><td>application/msword</td></tr><tr><td>.wav</td><td>audio/wav</td></tr><tr><td>.wav</td><td>audio/x-wav</td></tr><tr><td>.wb1</td><td>application/x-qpro</td></tr><tr><td>.wbmp</td><td>image/vnd.wap.wbmp</td></tr><tr><td>.web</td><td>application/vnd.xara</td></tr><tr><td>.weba</td><td>audio/webm</td></tr><tr><td>.webm</td><td>video/webm</td></tr><tr><td>.webp</td><td>image/webp</td></tr><tr><td>.wiz</td><td>application/msword</td></tr><tr><td>.wk1</td><td>application/x-123</td></tr><tr><td>.wmf</td><td>windows/metafile</td></tr><tr><td>.wml</td><td>text/vnd.wap.wml</td></tr><tr><td>.wmlc</td><td>application/vnd.wap.wmlc</td></tr><tr><td>.wmls</td><td>text/vnd.wap.wmlscript</td></tr><tr><td>.wmlsc</td><td>application/vnd.wap.wmlscriptc</td></tr><tr><td>.word</td><td>application/msword</td></tr><tr><td>.woff</td><td>font/woff</td></tr><tr><td>.woff2</td><td>font/woff2</td></tr><tr><td>.wp</td><td>application/wordperfect</td></tr><tr><td>.wp5</td><td>application/wordperfect</td></tr><tr><td>.wp5</td><td>application/wordperfect6.0</td></tr><tr><td>.wp6</td><td>application/wordperfect</td></tr><tr><td>.wpd</td><td>application/wordperfect</td></tr><tr><td>.wpd</td><td>application/x-wpwin</td></tr><tr><td>.wq1</td><td>application/x-lotus</td></tr><tr><td>.wri</td><td>application/mswrite</td></tr><tr><td>.wri</td><td>application/x-wri</td></tr><tr><td>.wrl</td><td>application/x-world</td></tr><tr><td>.wrl</td><td>model/vrml</td></tr><tr><td>.wrl</td><td>x-world/x-vrml</td></tr><tr><td>.wrz</td><td>model/vrml</td></tr><tr><td>.wrz</td><td>x-world/x-vrml</td></tr><tr><td>.wsc</td><td>text/scriplet</td></tr><tr><td>.wsrc</td><td>application/x-wais-source</td></tr><tr><td>.wtk</td><td>application/x-wintalk</td></tr><tr><td>.xbm</td><td>image/x-xbitmap</td></tr><tr><td>.xbm</td><td>image/x-xbm</td></tr><tr><td>.xbm</td><td>image/xbm</td></tr><tr><td>.xdr</td><td>video/x-amt-demorun</td></tr><tr><td>.xgz</td><td>xgl/drawing</td></tr><tr><td>.xhtml</td><td>application/xhtml+xml</td></tr><tr><td>.xif</td><td>image/vnd.xiff</td></tr><tr><td>.xl</td><td>application/excel</td></tr><tr><td>.xla</td><td>application/excel</td></tr><tr><td>.xla</td><td>application/x-excel</td></tr><tr><td>.xla</td><td>application/x-msexcel</td></tr><tr><td>.xlb</td><td>application/excel</td></tr><tr><td>.xlb</td><td>application/vnd.ms-excel</td></tr><tr><td>.xlb</td><td>application/x-excel</td></tr><tr><td>.xlc</td><td>application/excel</td></tr><tr><td>.xlc</td><td>application/vnd.ms-excel</td></tr><tr><td>.xlc</td><td>application/x-excel</td></tr><tr><td>.xld</td><td>application/excel</td></tr><tr><td>.xld</td><td>application/x-excel</td></tr><tr><td>.xlk</td><td>application/excel</td></tr><tr><td>.xlk</td><td>application/x-excel</td></tr><tr><td>.xll</td><td>application/excel</td></tr><tr><td>.xll</td><td>application/vnd.ms-excel</td></tr><tr><td>.xll</td><td>application/x-excel</td></tr><tr><td>.xlm</td><td>application/excel</td></tr><tr><td>.xlm</td><td>application/vnd.ms-excel</td></tr><tr><td>.xlm</td><td>application/x-excel</td></tr><tr><td>.xls</td><td>application/excel</td></tr><tr><td>.xls</td><td>application/vnd.ms-excel</td></tr><tr><td>.xls</td><td>application/x-excel</td></tr><tr><td>.xls</td><td>application/x-msexcel</td></tr><tr><td>.xlsx</td><td>application/vnd.openxmlformats-officedocument.spreadsheetml.sheet</td></tr><tr><td>.xlt</td><td>application/excel</td></tr><tr><td>.xlt</td><td>application/x-excel</td></tr><tr><td>.xlv</td><td>application/excel</td></tr><tr><td>.xlv</td><td>application/x-excel</td></tr><tr><td>.xlw</td><td>application/excel</td></tr><tr><td>.xlw</td><td>application/vnd.ms-excel</td></tr><tr><td>.xlw</td><td>application/x-excel</td></tr><tr><td>.xlw</td><td>application/x-msexcel</td></tr><tr><td>.xm</td><td>audio/xm</td></tr><tr><td>.xml</td><td>application/xml</td></tr><tr><td>.xml</td><td>text/xml</td></tr><tr><td>.xmz</td><td>xgl/movie</td></tr><tr><td>.xpix</td><td>application/x-vnd.ls-xpix</td></tr><tr><td>.xpm</td><td>image/x-xpixmap</td></tr><tr><td>.xpm</td><td>image/xpm</td></tr><tr><td>.xul</td><td>application/vnd.mozilla.xul+xml</td></tr><tr><td>.x-png</td><td>image/png</td></tr><tr><td>.xsr</td><td>video/x-amt-showrun</td></tr><tr><td>.xwd</td><td>image/x-xwd</td></tr><tr><td>.xwd</td><td>image/x-xwindowdump</td></tr><tr><td>.xyz</td><td>chemical/x-pdb</td></tr><tr><td>.z</td><td>application/x-compress</td></tr><tr><td>.z</td><td>application/x-compressed</td></tr><tr><td>.zip</td><td>application/x-compressed</td></tr><tr><td>.zip</td><td>application/x-zip-compressed</td></tr><tr><td>.zip</td><td>application/zip</td></tr><tr><td>.zip</td><td>multipart/x-zip</td></tr><tr><td>.zoo</td><td>application/octet-stream</td></tr><tr><td>.zsh</td><td>text/x-script.zsh</td></tr></tbody></table>]]></content>
      <categories>
        <category>开发实战总结</category>
      </categories>
      <tags>
        <tag>mime-types</tag>
      </tags>
  </entry>
  <entry>
    <title>折腾服务器(开篇) 我的第一台个人服务器</title>
    <url>//post/my-first-home-server.html</url>
    <content><![CDATA[<p>在对比过VPS，NUC，二手企业服务器，自己组装等方案后，决定还是选择后者。考虑到自己的需求并不要求多高性能（玩玩Gitlab、CI/CD、harbor、k8s、放一些工具、物联网终端等等），以及耗能低、安静，最主要总体价格要低等特点，最后选配如下:</p><table><thead><tr><th>配件</th><th>价格</th><th>备注</th></tr></thead><tbody><tr><td>ASROCK/华擎科技J4105M集成主板+海盗船 2400 DDR4 8Gx2</td><td>¥1099</td><td><a href="https://ark.intel.com/content/www/cn/zh/ark/products/128989/intel-celeron-j4105-processor-4m-cache-up-to-2-50-ghz.html" target="_blank" rel="noopener">CPU是4核1.50 GHz的(最高2.5)，能耗10w</a></td></tr><tr><td>乔思伯 C2 台式机电脑机箱</td><td>¥139</td><td></td></tr><tr><td>航嘉 冷静王钻石版 额定300W</td><td>¥179</td><td>如果不选这机箱，其实可以选个更小的电源</td></tr><tr><td>旧的固态 120G + 西数蓝盘 1T</td><td>0</td><td>蓝盘不知道能撑多久==</td></tr></tbody></table><p>总体下来，1500大洋不到，比开一个vps便宜多了==。</p><p>话不多说，上图。</p><p><img data-src="http://st.razeen.cn/img/blog/IMG_4468.jpg" alt="IMG_4468.jpg"></p><p>​ 集成主板、内存条、硬盘</p><p><img data-src="http://st.razeen.cn/img/blog/IMG_4470.jpg" alt="IMG_4470.jpg"></p><p>​ 机箱、电源</p><p>最后，来一张电信悦me网关、Newifi3 和 装机后的全家福（装机过程略==）。</p><p><img data-src="http://st.razeen.cn/img/blog/IMG_4557.jpg" alt="IMG_4557.jpg"></p><p>接下来就开始我的折腾之旅～。</p>]]></content>
      <categories>
        <category>家庭网络折腾</category>
        <category>个人服务器</category>
      </categories>
      <tags>
        <tag>服务器</tag>
      </tags>
  </entry>
  <entry>
    <title>记-我的首马（上）</title>
    <url>//post/my-first-marathon-01.html</url>
    <content><![CDATA[<p>记-我的首马（上）</p><a id="more"></a><p><img data-src="https://st.razeen.cn/img/blog/IMG_0540.jpg" alt="HelloWorld"></p>]]></content>
      <categories>
        <category>生活记实</category>
        <category>跑步</category>
      </categories>
      <tags>
        <tag>马拉松</tag>
      </tags>
  </entry>
  <entry>
    <title>超详细 vim 配置</title>
    <url>//post/my-macvim-vimrc.html</url>
    <content><![CDATA[<p>MacVim用了很久，非常喜欢vim编程带来的高效，清爽，hack的感觉，感谢<a href="https://github.com/deepzz0/dotfiles/blob/master/macvim/vimrc" target="_blank" rel="noopener">deepzz</a>多年前的传道。这两天花了点时间一行一行的去查vimrc内的配置，大概弄清了每一项配置的作用，并标上注释，整理常用快捷键。</p><a id="more"></a><h3 id="vimrc"><a href="#vimrc" class="headerlink" title="vimrc"></a>vimrc</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">"  repo: https://github.com/razeencheng/dotfiles/macvim</span><br><span class="line">"  email: me@razeen.me</span><br><span class="line"></span><br><span class="line">" 关闭vi的兼容模式(兼容模式下会让vim关闭所有的扩展，丢掉vim很多强大的功能去兼容vi)</span><br><span class="line">set nocompatible</span><br><span class="line"></span><br><span class="line">" filetype vim会对文件自动检测文件类型;</span><br><span class="line">" plugin 会在Vim的运行时环境目录下加载该类型相关的插件;</span><br><span class="line">"   比如为了让Vim更好的支持Python编程，需要下载一些Python相关的插件，此时就必须设置plugin为on;</span><br><span class="line">" indent 不同类型文件有不同的缩进方式;</span><br><span class="line">"   如Python就要求使用4个空格作为缩进,c使用两个tab作为缩进;</span><br><span class="line">"   那么indent就可以为不同文件类型选择合适的缩进方式了;</span><br><span class="line">"   在Vim的安装目录的indent目录下看到定义了很多缩进相关的脚本</span><br><span class="line">filetype plugin indent on</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">" rtp 即 vim runtime path</span><br><span class="line">"   把vim bundle加入rtp</span><br><span class="line">set rtp+=~/.vim/bundle/Vundle.vim</span><br><span class="line"></span><br><span class="line">" 插件开始的位置</span><br><span class="line">call vundle#begin()</span><br><span class="line"></span><br><span class="line">" Vundle插件管理</span><br><span class="line">Plugin 'VundleVim/Vundle.vim'</span><br><span class="line"></span><br><span class="line">" 导航目录侧边栏</span><br><span class="line">Plugin 'scrooloose/nerdtree'</span><br><span class="line">" 使nerdtree tab标签的名称更友好</span><br><span class="line">Plugin 'jistr/vim-nerdtree-tabs'</span><br><span class="line">" nerdtree中看git版本信息</span><br><span class="line">Plugin 'Xuyuanp/nerdtree-git-plugin'</span><br><span class="line"></span><br><span class="line">" 代码自动补全(需要额外配置）</span><br><span class="line">Plugin 'Valloric/YouCompleteMe'</span><br><span class="line">" 下面两个配合 生成代码片段 </span><br><span class="line">Plugin 'SirVer/ultisnips'</span><br><span class="line">Plugin 'honza/vim-snippets'</span><br><span class="line">" Python自动补全</span><br><span class="line">Plugin 'davidhalter/jedi-vim'</span><br><span class="line">" 符号自动补全</span><br><span class="line">Plugin 'Raimondi/delimitMate'</span><br><span class="line"></span><br><span class="line">" 文件搜索, 快速跳转文件</span><br><span class="line">Plugin 'ctrlpvim/ctrlp.vim'</span><br><span class="line">" 全局搜索</span><br><span class="line">Plugin 'dyng/ctrlsf.vim'</span><br><span class="line">" 大纲式导航(右边出现的那个导航的）</span><br><span class="line">Plugin 'majutsushi/tagbar'</span><br><span class="line">" 内容搜索</span><br><span class="line">Plugin 'rking/ag.vim'</span><br><span class="line">" 快速移动（跳转）</span><br><span class="line">Plugin 'Lokaltog/vim-easymotion'</span><br><span class="line">" 成对标签跳转</span><br><span class="line">Plugin 'vim-scripts/matchit.zip'</span><br><span class="line"></span><br><span class="line">" 快速注释</span><br><span class="line">Plugin 'tomtom/tcomment_vim'</span><br><span class="line">" 成对符号编辑(快速给词加环绕符号,例如单引号/双引号/括号/成对标签等)</span><br><span class="line">Plugin 'tpope/vim-surround'</span><br><span class="line">" 多光标操作(类似sublimetext的多光标选中)</span><br><span class="line">Plugin 'terryma/vim-multiple-cursors'</span><br><span class="line"></span><br><span class="line">" 语法检查(支持大部分语言）</span><br><span class="line">Plugin 'vim-syntastic/syntastic'</span><br><span class="line">" 快速对齐</span><br><span class="line">Plugin 'junegunn/vim-easy-align'</span><br><span class="line">" Python开发插件</span><br><span class="line">Plugin 'klen/python-mode'</span><br><span class="line">" Lua开发插件</span><br><span class="line">Plugin 'xolox/vim-lua-ftplugin'</span><br><span class="line">" Lua缩进插件</span><br><span class="line">Plugin 'raymond-w-ko/vim-lua-indent'</span><br><span class="line">" Go开发插件</span><br><span class="line">Plugin 'fatih/vim-go'</span><br><span class="line">" Vue开发插件</span><br><span class="line">Plugin 'posva/vim-vue'  </span><br><span class="line">" 杂项自动加载</span><br><span class="line">Plugin 'xolox/vim-misc'</span><br><span class="line">" 集成各种git操作</span><br><span class="line">Plugin 'tpope/vim-fugitive'</span><br><span class="line">" gitk</span><br><span class="line">Plugin 'gregsexton/gitv'</span><br><span class="line">" git差比对</span><br><span class="line">Plugin 'airblade/vim-gitgutter'</span><br><span class="line">" 状态栏增强显示</span><br><span class="line">Plugin 'bling/vim-airline'</span><br><span class="line">" 配色插件（深色/浅色）</span><br><span class="line">Plugin 'noahfrederick/vim-hemisu'</span><br><span class="line">" 配色</span><br><span class="line">Plugin 'tomasr/molokai'</span><br><span class="line">" 颜色主题</span><br><span class="line">Plugin 'zaki/zazen'</span><br><span class="line">" 关闭全部的Buff, 除了当前的</span><br><span class="line">Plugin 'vim-scripts/BufOnly.vim'</span><br><span class="line"></span><br><span class="line">" 插件结束的位置</span><br><span class="line">call vundle#end()</span><br><span class="line"></span><br><span class="line">" 插件简要使用</span><br><span class="line">" :PluginList       - 插件列表</span><br><span class="line">" :PluginInstall    - 安装插件; 加!表示更新</span><br><span class="line">" :PluginSearch foo - 搜索插件 foo; 加!刷新本地缓存</span><br><span class="line">" :PluginClean      - 移除插件; 加!不需要确认</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">" 对所有缓冲区中的文件启用语法高亮度</span><br><span class="line">syntax on</span><br><span class="line">" 使用bash作为默认shell环境</span><br><span class="line">set shell=bash</span><br><span class="line">" 定义快捷键的前缀</span><br><span class="line">let mapleader = ','</span><br><span class="line"></span><br><span class="line">" 关闭欢迎页面</span><br><span class="line">set shortmess=atI</span><br><span class="line">"被分割窗口之間顯示空白</span><br><span class="line">set fillchars=vert:/</span><br><span class="line"></span><br><span class="line">" 保存历史命令行数</span><br><span class="line">set history=1000</span><br><span class="line">" 关闭swap</span><br><span class="line">set noswapfile</span><br><span class="line">" 关闭备份</span><br><span class="line">set nobackup</span><br><span class="line">" 关闭vim bb声</span><br><span class="line">set noerrorbells</span><br><span class="line">" 高亮当前行</span><br><span class="line">set cursorline</span><br><span class="line">" 高亮当前列</span><br><span class="line">" set cursorcolumn</span><br><span class="line">" 关闭鼠标</span><br><span class="line">" set mouse-=a</span><br><span class="line">" 控制vim剪贴板</span><br><span class="line">set clipboard+=unnamed</span><br><span class="line">" 允许在插入模式下对所有内容进行退格</span><br><span class="line">set backspace=indent,eol,start</span><br><span class="line">" 行间距</span><br><span class="line">set linespace=0</span><br><span class="line">" 刷新率100ms ?</span><br><span class="line">set updatetime=100</span><br><span class="line">" 在新Tab中打开新的缓冲区</span><br><span class="line">set switchbuf=usetab,usetab</span><br><span class="line">" 搜索时 忽略这些文件/夹</span><br><span class="line">set wildignore+=*/.git/*,</span><br><span class="line">      \*/.hg/*,*/.svn/*,</span><br><span class="line">      \*/cscope*,*/*.csv/,</span><br><span class="line">      \*/*.log,*tags*,*/bin/*</span><br><span class="line"></span><br><span class="line">" 在最下面状态栏显示正在输入的命令</span><br><span class="line">set showcmd</span><br><span class="line">" 在左下角的状态栏显示 --INSERT-- 之类的状态</span><br><span class="line">set showmode</span><br><span class="line">" 显示行号</span><br><span class="line">set number</span><br><span class="line">" 行号显示宽度</span><br><span class="line">set numberwidth=4</span><br><span class="line">" 当输入一个左括号时自动匹配右括号</span><br><span class="line">set showmatch</span><br><span class="line">" 关闭Preview窗口</span><br><span class="line">set completeopt-=preview</span><br><span class="line"></span><br><span class="line">" 增强自带的 ? 和 ／ 搜索功能， 并且支持更加高级的正则表达式匹配</span><br><span class="line">set incsearch</span><br><span class="line">" 高亮搜索内容</span><br><span class="line">set hlsearch</span><br><span class="line">" 查找忽略大小写</span><br><span class="line">set ignorecase</span><br><span class="line">" 如果有一个大写字母，则切换到大小写敏感查找</span><br><span class="line">set smartcase</span><br><span class="line"></span><br><span class="line">" 自动缩进所使用的空白长度</span><br><span class="line">set shiftwidth=4</span><br><span class="line">" 按下tab键，插入的是空格和tab制表符的混合</span><br><span class="line">set softtabstop=4</span><br><span class="line">" 空格代替Tab</span><br><span class="line">set expandtab</span><br><span class="line">" 自动缩进，新增加的行和前一行使用相同的缩进形式</span><br><span class="line">set autoindent</span><br><span class="line">" 每一行都和前一行有相同的缩进量，同时能正确的识别出花括号，当遇&#125;，取消缩进形式</span><br><span class="line">set smartindent</span><br><span class="line"></span><br><span class="line">" 默认的字符编码</span><br><span class="line">set encoding=utf-8</span><br><span class="line">" 自动识别文件编码</span><br><span class="line">set fileencodings=utf-8,ucs-bom,gbk,gb2312,gb18030,default</span><br><span class="line">" 文本格式优先unix风格</span><br><span class="line">set fileformats=unix,dos,mac</span><br><span class="line">" 文本格式化选项</span><br><span class="line">" t：根据 textwidth 自动折行</span><br><span class="line">" c：在（程序源代码中的）注释中自动折行，插入合适的注释起始字符</span><br><span class="line">" r：插入模式下在注释中键入回车时，插入合适的注释起始字符</span><br><span class="line">" q：允许使用“gq”命令对注释进行格式化</span><br><span class="line">" o: 如果当前有注释，用O，o时自动插入注释</span><br><span class="line">" w: 尾部白色空格代表下一行继续，非白色表示一个段落的结尾</span><br><span class="line">set formatoptions+=tcroqw</span><br><span class="line"></span><br><span class="line">" 向右切分窗口</span><br><span class="line">set splitright</span><br><span class="line">" 向下切分窗口</span><br><span class="line">set splitbelow</span><br><span class="line"></span><br><span class="line">" 自动保存</span><br><span class="line">set autowrite</span><br><span class="line">" 自动读取文件(如果文本改变，自动更新）</span><br><span class="line">set autoread</span><br><span class="line">" 始终显示状态栏（倒数第二行）</span><br><span class="line">set laststatus=2</span><br><span class="line"></span><br><span class="line">" 主题设置</span><br><span class="line">" GUI的一些可选参数</span><br><span class="line">set guioptions=''</span><br><span class="line">" 背景颜色</span><br><span class="line">set background=dark</span><br><span class="line">" 配色 terminal Color 256色</span><br><span class="line">set t_Co=256</span><br><span class="line">" 字体</span><br><span class="line">set guifont=CamingoCode\ Regular:h15</span><br><span class="line">" 主题</span><br><span class="line">colorscheme molokai</span><br><span class="line">" colorscheme solarized</span><br><span class="line">" colorscheme desert</span><br><span class="line"></span><br><span class="line">" 切换buffer(文件/tab)的时候, 之前编辑的文件就只是切换到后台, 而不是关掉,还可以回切</span><br><span class="line">set hidden</span><br><span class="line">" 自动补全的模式（显示可能匹配的列表,并使用最长的子串进行补全)</span><br><span class="line">set wildmode=list:longest</span><br><span class="line">" 快速滚动</span><br><span class="line">set ttyfast</span><br><span class="line"></span><br><span class="line">" 文本折叠</span><br><span class="line">" 开启折叠</span><br><span class="line">set foldenable</span><br><span class="line">" 折叠方式（安装缩进折叠）</span><br><span class="line">set foldmethod=indent</span><br><span class="line">" 折叠级别</span><br><span class="line">set foldlevel=99</span><br><span class="line"></span><br><span class="line">" 设置折叠的快捷键</span><br><span class="line">" 我这里就是 ,zz</span><br><span class="line">" 第一次 ,zz 折叠，再一次就展开</span><br><span class="line">let g:FoldMethod = 0</span><br><span class="line">map &lt;leader&gt;zz :call ToggleFold()&lt;CR&gt;</span><br><span class="line">fun! ToggleFold()</span><br><span class="line">    if g:FoldMethod == 0</span><br><span class="line">        exe "normal! zM"</span><br><span class="line">        let g:FoldMethod = 1</span><br><span class="line">    else</span><br><span class="line">        exe "normal! zR"</span><br><span class="line">        let g:FoldMethod = 0</span><br><span class="line">    endif</span><br><span class="line">endfun</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">" 在Visual/Select模式下的一些成对字符插入快捷键</span><br><span class="line">" 如你选择  hellworld 然后按下"号，就会成对加上" 变成 "helloworld"</span><br><span class="line">vmap " S"</span><br><span class="line">vmap ' S'</span><br><span class="line">vmap ` S`</span><br><span class="line">vmap [ S[</span><br><span class="line">vmap ( S(</span><br><span class="line">vmap &#123; S&#123;</span><br><span class="line">vmap &#125; S&#125;</span><br><span class="line">vmap ] S]</span><br><span class="line">vmap ) S)</span><br><span class="line">  </span><br><span class="line">" 多个窗口 用Ctr加 jkhl切换</span><br><span class="line">map &lt;C-j&gt; &lt;C-W&gt;j</span><br><span class="line">map &lt;C-k&gt; &lt;C-W&gt;k</span><br><span class="line">map &lt;C-h&gt; &lt;C-W&gt;h</span><br><span class="line">map &lt;C-l&gt; &lt;C-W&gt;l</span><br><span class="line">  </span><br><span class="line">" 普通模式下 shift + h/l 快速切换缓冲区</span><br><span class="line">nmap &lt;S-H&gt; :bp&lt;CR&gt;</span><br><span class="line">nmap &lt;S-L&gt; :bn&lt;CR&gt;</span><br><span class="line"></span><br><span class="line">" 快速切换多个标签页</span><br><span class="line">" ,1 到第一个标签页</span><br><span class="line">noremap &lt;leader&gt;1 1gt</span><br><span class="line">noremap &lt;leader&gt;2 2gt</span><br><span class="line">noremap &lt;leader&gt;3 3gt</span><br><span class="line">noremap &lt;leader&gt;4 4gt</span><br><span class="line">noremap &lt;leader&gt;5 5gt</span><br><span class="line">noremap &lt;leader&gt;6 6gt</span><br><span class="line">noremap &lt;leader&gt;7 7gt</span><br><span class="line">noremap &lt;leader&gt;8 8gt</span><br><span class="line">noremap &lt;leader&gt;9 9gt</span><br><span class="line">noremap &lt;leader&gt;0 :tablast&lt;CR&gt;</span><br><span class="line"></span><br><span class="line">" 开启相对行号</span><br><span class="line">set relativenumber</span><br><span class="line">augroup CursorLineOnlyInActiveWindow</span><br><span class="line">    autocmd!</span><br><span class="line">    autocmd InsertLeave * setlocal relativenumber</span><br><span class="line">    autocmd InsertEnter * setlocal norelativenumber</span><br><span class="line">    autocmd BufEnter * setlocal cursorline</span><br><span class="line">    autocmd BufLeave * setlocal nocursorline</span><br><span class="line">    " autocmd CompleteDone *.go  call OnGolangCompleteDone()</span><br><span class="line">augroup END</span><br><span class="line">function! NumberToggle()</span><br><span class="line">    if(&amp;relativenumber == 1)</span><br><span class="line">        set norelativenumber number</span><br><span class="line">    else</span><br><span class="line">        set relativenumber</span><br><span class="line">    endif</span><br><span class="line">endfunc</span><br><span class="line">nnoremap &lt;C-n&gt; :call NumberToggle()&lt;CR&gt;</span><br><span class="line"></span><br><span class="line">" 自动记住上次位置</span><br><span class="line">autocmd BufReadPost *</span><br><span class="line">    \ if line("'\"")&gt;0&amp;&amp;line("'\"")&lt;=line("$") |</span><br><span class="line">    \   exe "normal g'\"" |</span><br><span class="line">    \ endif</span><br><span class="line"></span><br><span class="line">" auto load vimrc</span><br><span class="line">" autocmd! BufWritePost .vimrc source %</span><br><span class="line"></span><br><span class="line">autocmd BufNewFile,BufRead *.define setf define</span><br><span class="line">" 针对不同的文件类型 设置不同格式</span><br><span class="line">" go中，不用空格代理Tab</span><br><span class="line">autocmd FileType go :set tabstop=4 noexpandtab " Do not use spaces instead of tabs</span><br><span class="line">" cpp c 缩进空格长度为4 用空格代替Tab</span><br><span class="line">autocmd FileType c,cpp :set shiftwidth=4 expandtab</span><br><span class="line">" lua 缩进空格长度为4 </span><br><span class="line">autocmd FileType lua :set shiftwidth=4 </span><br><span class="line">" sh 缩进空格长度为2 空格代理Tab</span><br><span class="line">autocmd FileType sh :set shiftwidth=2 expandtab</span><br><span class="line">" py 缩进空格长度为4 空格代理Tab 自动缩进</span><br><span class="line">autocmd FileType python :set tabstop=4 shiftwidth=4 expandtab ai</span><br><span class="line">" ruby,javascript,html,css,xml 缩进空格长度为2 空格代理Tab 自动缩进</span><br><span class="line">autocmd FileType ruby,javascript,html,css,xml :set tabstop=2 shiftwidth=2 softtabstop=2 expandtab ai</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">" 热键设置</span><br><span class="line">" w!! 用sudo权限保存文件</span><br><span class="line">cmap w!! %!sudo tee &gt; /dev/null %</span><br><span class="line">" ,/ 移除搜索高亮</span><br><span class="line">noremap &lt;silent&gt;&lt;leader&gt;/ :nohls&lt;CR&gt;</span><br><span class="line">" ,sa 选择全部</span><br><span class="line">map &lt;leader&gt;sa ggvG$</span><br><span class="line">" ,w 保存当前文件</span><br><span class="line">nnoremap &lt;leader&gt;w :w&lt;CR&gt;</span><br><span class="line">" ; -&gt; :</span><br><span class="line">nnoremap ; :</span><br><span class="line">" 修复ctags ctrl+]无效问题</span><br><span class="line">nmap &lt;c-]&gt; g&lt;c-]&gt;</span><br><span class="line"></span><br><span class="line">" inoremap &lt;esc&gt; &lt;esc&gt;:set iminsert=0&lt;cr&gt;</span><br><span class="line">" nmap &lt;expr&gt; &lt;c-j&gt; &amp;diff ? ']c' : '&lt;c-j&gt;'</span><br><span class="line">" nmap &lt;expr&gt; &lt;c-k&gt; &amp;diff ? '[c' : '&lt;c-k&gt;'</span><br><span class="line"></span><br><span class="line">" 隐藏文本设置</span><br><span class="line">if has('conceal')</span><br><span class="line">    set conceallevel=2 concealcursor=niv</span><br><span class="line">endif</span><br><span class="line"></span><br><span class="line">" ,bd 关闭但前缓冲区, 不关闭窗口</span><br><span class="line">map &lt;leader&gt;bd :Bclose&lt;cr&gt;:tabclose&lt;cr&gt;gT</span><br><span class="line">command! Bclose call &lt;SID&gt;BufcloseCloseIt()</span><br><span class="line">function! &lt;SID&gt;BufcloseCloseIt()</span><br><span class="line">   let l:currentBufNum = bufnr("%")</span><br><span class="line">   let l:alternateBufNum = bufnr("#")</span><br><span class="line">   if buflisted(l:alternateBufNum)</span><br><span class="line">     buffer #</span><br><span class="line">   else</span><br><span class="line">     bnext</span><br><span class="line">   endif</span><br><span class="line">   if bufnr("%") == l:currentBufNum</span><br><span class="line">     new</span><br><span class="line">   endif</span><br><span class="line">   if buflisted(l:currentBufNum)</span><br><span class="line">     execute("bdelete! ".l:currentBufNum)</span><br><span class="line">   endif</span><br><span class="line">endfunction</span><br><span class="line"></span><br><span class="line">" GUI设置</span><br><span class="line">if has("gui_macvim")</span><br><span class="line">"透明</span><br><span class="line">set transparency=10 </span><br><span class="line">" " fullscreen</span><br><span class="line">" set fullscreen</span><br><span class="line"></span><br><span class="line">" Command + r/R 搜索</span><br><span class="line">let g:ctrlp_map = '&lt;D-p&gt;'</span><br><span class="line">nmap &lt;D-r&gt; :CtrlPBufTag&lt;CR&gt;</span><br><span class="line">imap &lt;D-r&gt; &lt;esc&gt;:CtrlPBufTag&lt;CR&gt;</span><br><span class="line">nmap &lt;D-R&gt; :CtrlPBufTagAll&lt;CR&gt;</span><br><span class="line">imap &lt;D-R&gt; &lt;esc&gt;:CtrlPBufTagAll&lt;CR&gt;</span><br><span class="line"></span><br><span class="line">" Command + / 加注释</span><br><span class="line">map &lt;D-/&gt; :TComment&lt;CR&gt;</span><br><span class="line">vmap &lt;D-/&gt; :TComment&lt;CR&gt;g</span><br><span class="line"></span><br><span class="line">" ,f 快速搜索</span><br><span class="line">nmap &lt;D-f&gt; :CtrlSF &lt;C-R&gt;=expand("&lt;cword&gt;")&lt;CR&gt;</span><br><span class="line">imap &lt;D-f&gt; &lt;ESC&gt;:CtrlSF &lt;C-R&gt;=expand("&lt;cword&gt;")&lt;CR&gt;</span><br><span class="line">vnoremap &lt;D-f&gt;  y :CtrlSF"&lt;C-R&gt;=escape(@", '\\/.*$^~[]()"')&lt;CR&gt;"</span><br><span class="line"></span><br><span class="line">" Commond e 显示/关闭 NERDTree</span><br><span class="line">map &lt;D-e&gt; :NERDTreeTabsToggle&lt;CR&gt;</span><br><span class="line">map &lt;leader&gt;e :NERDTreeFind&lt;CR&gt;&lt;CR&gt;</span><br><span class="line"></span><br><span class="line">" window上改几个按键</span><br><span class="line">" map &lt;D-j&gt; &lt;C-W&gt;j</span><br><span class="line">" map &lt;D-k&gt; &lt;C-W&gt;k</span><br><span class="line">" map &lt;D-l&gt; &lt;C-W&gt;l</span><br><span class="line">" map &lt;D-h&gt; &lt;C-W&gt;h</span><br><span class="line">endif</span><br><span class="line"></span><br><span class="line">" python 设置</span><br><span class="line">" macvim with --with-python3</span><br><span class="line">let g:pymode_python = 'python3'</span><br><span class="line">" close syntax when save file</span><br><span class="line">let g:pymode_lint_on_write = 0</span><br><span class="line"></span><br><span class="line">" vim-go 设置</span><br><span class="line">let g:go_highlight_functions = 1</span><br><span class="line">let g:go_highlight_methods = 1</span><br><span class="line">let g:go_highlight_fields = 1</span><br><span class="line">let g:go_highlight_types = 1</span><br><span class="line">let g:go_highlight_operators = 1</span><br><span class="line">let g:go_highlight_build_constraints = 1</span><br><span class="line">let g:go_fmt_command = "goimports"</span><br><span class="line">let g:go_list_type = "quickfix"</span><br><span class="line">let g:go_def_mode = 'godef'</span><br><span class="line"></span><br><span class="line">" go 相关快捷键</span><br><span class="line">nmap &lt;Leader&gt;gc :GoErrCheck&lt;CR&gt;</span><br><span class="line">nmap &lt;Leader&gt;gb :GoBuild&lt;CR&gt;</span><br><span class="line">nmap &lt;Leader&gt;gd :GoDoc&lt;CR&gt;</span><br><span class="line">nmap &lt;Leader&gt;gt :GoTest&lt;CR&gt;</span><br><span class="line">nmap &lt;Leader&gt;gi :GoInstall&lt;CR&gt;</span><br><span class="line">nmap &lt;Leader&gt;gr :GoRename&lt;CR&gt;</span><br><span class="line">nmap &lt;Leader&gt;gl :GoLint&lt;CR&gt;</span><br><span class="line"></span><br><span class="line">" function! OnGolangCompleteDone()</span><br><span class="line">"     if !exists('v:completed_item') || empty(v:completed_item)</span><br><span class="line">"         return</span><br><span class="line">"     endif</span><br><span class="line">"</span><br><span class="line">"     let complete_str = v:completed_item.word</span><br><span class="line">"     if complete_str == ''</span><br><span class="line">"         return</span><br><span class="line">"     endif</span><br><span class="line">"</span><br><span class="line">"     let line = getline('.')</span><br><span class="line">"     let next_char = line[col('.')-1]</span><br><span class="line">"     if  next_char == "("</span><br><span class="line">"         return</span><br><span class="line">"     end</span><br><span class="line">"     let cur_char =line[col('.')-2]</span><br><span class="line">"</span><br><span class="line">"     let abbr = v:completed_item.abbr</span><br><span class="line">"     let startIdx = match(abbr,"(")</span><br><span class="line">"     let endIdx = match(abbr,")")</span><br><span class="line">"     if endIdx - startIdx &gt; 1</span><br><span class="line">"         let argsStr = strpart(abbr, startIdx+1, endIdx - startIdx -1)</span><br><span class="line">" 	  let argsList = split(argsStr, ",")</span><br><span class="line">" 	  let snippet = ""</span><br><span class="line">" 	  if cur_char != "("</span><br><span class="line">"             let snippet = "("</span><br><span class="line">" 	  end</span><br><span class="line">" 	  let c = 1</span><br><span class="line">" 	  for i in argsList</span><br><span class="line">" 	      if c &gt; 1</span><br><span class="line">" 	          let snippet = snippet. ", "</span><br><span class="line">"             endif</span><br><span class="line">"             " strip space</span><br><span class="line">"             let arg = substitute(i, '^\s*\(.\&#123;-&#125;\)\s*$', '\1', '')</span><br><span class="line">"             let snippet = snippet . '$&#123;'.c.":".arg.'&#125;'</span><br><span class="line">"             let c += 1</span><br><span class="line">"         endfor</span><br><span class="line">"         let snippet = snippet . ")$0"</span><br><span class="line">"         call UltiSnips#Anon(snippet)</span><br><span class="line">"     endif</span><br><span class="line">" endfunction</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">" NERDTree 设置</span><br><span class="line">let g:NERDTreeDirArrows = 0</span><br><span class="line">let g:nerdtree_tabs_open_on_gui_startup = 0</span><br><span class="line">let NERDTreeIgnore=['node_modules']</span><br><span class="line">let NERDTreeShowHidden=1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">" nerdtree-git-plugin 一些git状态符号</span><br><span class="line">let g:NERDTreeIndicatorMapCustom = &#123;</span><br><span class="line">    \ "Modified"  : "✹",</span><br><span class="line">    \ "Staged"    : "✚",</span><br><span class="line">    \ "Untracked" : "✭",</span><br><span class="line">    \ "Renamed"   : "➜",</span><br><span class="line">    \ "Unmerged"  : "═",</span><br><span class="line">    \ "Deleted"   : "✖",</span><br><span class="line">    \ "Dirty"     : "✗",</span><br><span class="line">    \ "Clean"     : "✔︎",</span><br><span class="line">    \ "Unknown"   : "?"</span><br><span class="line">    \ &#125;</span><br><span class="line"></span><br><span class="line">" 状态栏设置</span><br><span class="line">let g:airline#extensions#tabline#enabled = 1</span><br><span class="line">let g:airline_theme='dark'</span><br><span class="line">let g:airline_powerline_fonts=0</span><br><span class="line">let g:airline#extensions#tabline#exclude_preview = 1</span><br><span class="line">let g:airline#extensions#tabline#show_buffers = 1</span><br><span class="line">let g:airline#extensions#tabline#tab_nr_type = 2 " splits and tab number</span><br><span class="line">let g:airline#extensions#bufferline#enabled = 1</span><br><span class="line"></span><br><span class="line">" cscope </span><br><span class="line">if has("cscope")</span><br><span class="line">    " set csprg=/usr/local/bin/cscope</span><br><span class="line">    set csto=0</span><br><span class="line">    set cscopequickfix=s-,c-,d-,i-,t-,e-</span><br><span class="line">    set cst</span><br><span class="line">    set nocsverb</span><br><span class="line">    " add any database in current directory</span><br><span class="line">    if filereadable("cscope.out")</span><br><span class="line">        cs add cscope.out</span><br><span class="line">        " else add database pointed to by environment</span><br><span class="line">    elseif $CSCOPE_DB != ""</span><br><span class="line">        cs add $CSCOPE_DB</span><br><span class="line">    endif</span><br><span class="line">    set csverb</span><br><span class="line">    nmap &lt;D-[&gt; :cs find c &lt;C-R&gt;=expand("&lt;cword&gt;")&lt;CR&gt;&lt;CR&gt;&lt;C-O&gt;:copen&lt;CR&gt;</span><br><span class="line">    nmap &lt;D-\&gt; :cs find s &lt;C-R&gt;=expand("&lt;cword&gt;")&lt;CR&gt;&lt;CR&gt;&lt;C-O&gt;:copen&lt;CR&gt;</span><br><span class="line">    nmap &lt;D-]&gt; :cs find g &lt;C-R&gt;=expand("&lt;cword&gt;")&lt;CR&gt;&lt;CR&gt;</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">" Command y 开启大纲导航</span><br><span class="line">map &lt;D-y&gt; :TagbarToggle&lt;CR&gt;</span><br><span class="line">" 大纲导航设置</span><br><span class="line">let g:tagbar_autofocus=1</span><br><span class="line">let g:tagbar_sort=0</span><br><span class="line">let g:tagbar_type_go = &#123;</span><br><span class="line">    \ 'ctagstype' : 'go',</span><br><span class="line">    \ 'kinds'     : [</span><br><span class="line">        \ 'p:package',</span><br><span class="line">        \ 'i:imports:1',</span><br><span class="line">        \ 'c:constants',</span><br><span class="line">        \ 'v:variables',</span><br><span class="line">        \ 't:types',</span><br><span class="line">        \ 'n:interfaces',</span><br><span class="line">        \ 'w:fields',</span><br><span class="line">        \ 'e:embedded',</span><br><span class="line">        \ 'm:methods',</span><br><span class="line">        \ 'r:constructor',</span><br><span class="line">        \ 'f:functions'</span><br><span class="line">    \ ],</span><br><span class="line">    \ 'sro' : '.',</span><br><span class="line">    \ 'kind2scope' : &#123;</span><br><span class="line">        \ 't' : 'ctype',</span><br><span class="line">        \ 'n' : 'ntype'</span><br><span class="line">    \ &#125;,</span><br><span class="line">    \ 'scope2kind' : &#123;</span><br><span class="line">        \ 'ctype' : 't',</span><br><span class="line">        \ 'ntype' : 'n'</span><br><span class="line">    \ &#125;,</span><br><span class="line">    \ 'ctagsbin'  : 'gotags',</span><br><span class="line">    \ 'ctagsargs' : '-sort -silent'</span><br><span class="line">\ &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">" 搜索设置</span><br><span class="line">" 忽略文件</span><br><span class="line">" MacOSX/Linux</span><br><span class="line">set wildignore+=*/tmp/*,*.so,*.swp,*.zip     </span><br><span class="line">" Windows</span><br><span class="line">set wildignore+=*\\tmp\\*,*.swp,*.zip,*.exe  </span><br><span class="line">" search anything (in files, buffers and MRU files at the same time.)</span><br><span class="line">let g:ctrlp_cmd = 'CtrlPMixed'               </span><br><span class="line">let g:ctrlp_by_filename = 1</span><br><span class="line">" search for nearest ancestor like .git, .hg, and the directory of the current file</span><br><span class="line">let g:ctrlp_working_path_mode = 'ra'         </span><br><span class="line">" show the match window at the top of the screen</span><br><span class="line">let g:ctrlp_match_window_bottom = 1          </span><br><span class="line">" maxiumum height of match window</span><br><span class="line">let g:ctrlp_max_height = 10                  </span><br><span class="line">" jump to a file if it's open already</span><br><span class="line">let g:ctrlp_switch_buffer = 'Et'             </span><br><span class="line">" enable caching</span><br><span class="line">let g:ctrlp_use_caching = 1                  </span><br><span class="line">" speed up by not removing clearing cache evertime</span><br><span class="line">let g:ctrlp_clear_cache_on_exit=1            </span><br><span class="line">" number of recently opened files</span><br><span class="line">let g:ctrlp_mruf_max = 250                   </span><br><span class="line">let g:ctrlp_open_new_file = 't'</span><br><span class="line">let g:ctrlp_open_multiple_files = 't'</span><br><span class="line">let g:ctrlp_open_new_file = 'r'</span><br><span class="line">let g:ctrlp_custom_ignore = &#123;</span><br><span class="line">    \ 'dir':  '\v[\/](\.git|\.hg|\.svn|\.build|github.com|labix.org|bin|pkg)$',</span><br><span class="line">    \ 'file': '\v(\.exe|\.so|\.dll|\.a|\.xls|\.csv|\.json|\.log|\.out|gs|gw|gm|tags|gotags|\/U)$',</span><br><span class="line">    \ 'link': 'SOME_BAD_SYMBOLIC_LINKS',</span><br><span class="line">    \ &#125;</span><br><span class="line">let g:ctrlp_buftag_types = &#123;</span><br><span class="line">    \ 'go'         : '--language-force=go --golang-types=ftv',</span><br><span class="line">    \ 'as'         : '--language-force=actionscript --actionscript-types=fpvc',</span><br><span class="line">    \ 'actionscript': '--language-force=actionscript --actionscript-types=fpvc',</span><br><span class="line">    \ 'coffee'     : '--language-force=coffee --coffee-types=cmfvf',</span><br><span class="line">    \ 'markdown'   : '--language-force=markdown --markdown-types=hik',</span><br><span class="line">    \ 'objc'       : '--language-force=objc --objc-types=mpci',</span><br><span class="line">    \ 'rc'         : '--language-force=rust --rust-types=fTm'</span><br><span class="line">    \ &#125;</span><br><span class="line">let g:ctrlp_prompt_mappings = &#123;</span><br><span class="line">    \ 'PrtBS()':              ['&lt;bs&gt;', '&lt;c-]&gt;'],</span><br><span class="line">    \ 'PrtDelete()':          ['&lt;del&gt;'],</span><br><span class="line">    \ 'PrtDeleteWord()':      ['&lt;c-w&gt;'],</span><br><span class="line">    \ 'PrtClear()':           ['&lt;c-u&gt;'],</span><br><span class="line">    \ 'PrtSelectMove("j")':   ['&lt;c-j&gt;', '&lt;down&gt;'],</span><br><span class="line">    \ 'PrtSelectMove("k")':   ['&lt;c-k&gt;', '&lt;up&gt;'],</span><br><span class="line">    \ 'PrtSelectMove("t")':   ['&lt;Home&gt;', '&lt;kHome&gt;'],</span><br><span class="line">    \ 'PrtSelectMove("b")':   ['&lt;End&gt;', '&lt;kEnd&gt;'],</span><br><span class="line">    \ 'PrtSelectMove("u")':   ['&lt;PageUp&gt;', '&lt;kPageUp&gt;'],</span><br><span class="line">    \ 'PrtSelectMove("d")':   ['&lt;PageDown&gt;', '&lt;kPageDown&gt;'],</span><br><span class="line">    \ 'PrtHistory(-1)':       ['&lt;c-n&gt;'],</span><br><span class="line">    \ 'PrtHistory(1)':        ['&lt;c-p&gt;'],</span><br><span class="line">    \ 'AcceptSelection("e")': ['&lt;cr&gt;', '&lt;2-LeftMouse&gt;'],</span><br><span class="line">    \ 'AcceptSelection("h")': ['&lt;c-x&gt;', '&lt;c-cr&gt;', '&lt;c-s&gt;'],</span><br><span class="line">    \ 'AcceptSelection("t")': ['&lt;c-t&gt;'],</span><br><span class="line">    \ 'AcceptSelection("v")': ['&lt;c-v&gt;', '&lt;RightMouse&gt;'],</span><br><span class="line">    \ 'ToggleFocus()':        ['&lt;s-tab&gt;'],</span><br><span class="line">    \ 'ToggleRegex()':        ['&lt;c-r&gt;'],</span><br><span class="line">    \ 'ToggleByFname()':      ['&lt;c-d&gt;'],</span><br><span class="line">    \ 'ToggleType(1)':        ['&lt;c-f&gt;', '&lt;c-up&gt;'],</span><br><span class="line">    \ 'ToggleType(-1)':       ['&lt;c-b&gt;', '&lt;c-down&gt;'],</span><br><span class="line">    \ 'PrtExpandDir()':       ['&lt;tab&gt;'],</span><br><span class="line">    \ 'PrtInsert("c")':       ['&lt;MiddleMouse&gt;', '&lt;insert&gt;'],</span><br><span class="line">    \ 'PrtInsert()':          ['&lt;c-\&gt;'],</span><br><span class="line">    \ 'PrtCurStart()':        ['&lt;c-a&gt;'],</span><br><span class="line">    \ 'PrtCurEnd()':          ['&lt;c-e&gt;'],</span><br><span class="line">    \ 'PrtCurLeft()':         ['&lt;c-h&gt;', '&lt;left&gt;', '&lt;c-^&gt;'],</span><br><span class="line">    \ 'PrtCurRight()':        ['&lt;c-l&gt;', '&lt;right&gt;'],</span><br><span class="line">    \ 'PrtClearCache()':      ['&lt;F5&gt;'],</span><br><span class="line">    \ 'PrtDeleteEnt()':       ['&lt;F7&gt;'],</span><br><span class="line">    \ 'CreateNewFile()':      ['&lt;c-y&gt;'],</span><br><span class="line">    \ 'MarkToOpen()':         ['&lt;c-z&gt;'],</span><br><span class="line">    \ 'OpenMulti()':          ['&lt;D-o&gt;'],</span><br><span class="line">    \ 'PrtExit()':            ['&lt;esc&gt;', '&lt;c-c&gt;', '&lt;c-g&gt;'],</span><br><span class="line">    \ &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">" 语法检查</span><br><span class="line">set statusline+=%#warningmsg#</span><br><span class="line">set statusline+=%&#123;SyntasticStatuslineFlag()&#125;</span><br><span class="line">set statusline+=%*</span><br><span class="line">let g:syntastic_check_on_wq=1</span><br><span class="line">let g:syntastic_auto_jump=1</span><br><span class="line">let g:syntastic_auto_loc_list=1</span><br><span class="line">let g:syntastic_error_symbol = "▶▶"</span><br><span class="line">let g:syntastic_warning_symbol = "⚠"</span><br><span class="line">let g:syntastic_sh_checkers = ['shellcheck']</span><br><span class="line">" let g:syntastic_go_checkers = ['golint', 'govet', 'errcheck']</span><br><span class="line">" let g:syntastic_go_checkers = ['errcheck']</span><br><span class="line">" passive</span><br><span class="line">let g:syntastic_mode_map = &#123; "mode": "active",</span><br><span class="line">    \ "active_filetypes": ["ruby", "go", "python"],</span><br><span class="line">    \ "passive_filetypes": ["shell"] &#125;</span><br><span class="line"></span><br><span class="line">" 全局查找</span><br><span class="line">command! CO CtrlSFOpen</span><br><span class="line">let g:ctrlsf_winsize = '30%'</span><br><span class="line">let g:ctrlsf_auto_close = 1</span><br><span class="line">let g:ctrlsf_ignore_dir = ['vendor', 'bower_components', 'node_modules']</span><br><span class="line"></span><br><span class="line">" YouCompleteMe 自动补全</span><br><span class="line">" preview window settiing</span><br><span class="line">let g:ycm_add_preview_to_completeopt = 1</span><br><span class="line">let g:ycm_autoclose_preview_window_after_completion = 0</span><br><span class="line">let g:ycm_autoclose_preview_window_after_insertion = 1</span><br><span class="line">" typing 2 chars</span><br><span class="line">let g:ycm_min_num_of_chars_for_completion = 2</span><br><span class="line">" Completion when typing inside comments</span><br><span class="line">let g:ycm_complete_in_comments = 1  </span><br><span class="line">" Query the UltiSnips plugin</span><br><span class="line">let g:ycm_use_ultisnips_completer = 1 </span><br><span class="line">" Collect identifiers from strings and comments and tag fiels</span><br><span class="line">let g:ycm_collect_identifiers_from_comments_and_strings = 1   </span><br><span class="line">let g:ycm_collect_identifiers_from_tags_files = 1</span><br><span class="line">" some symbols</span><br><span class="line">let g:ycm_error_symbol = '&gt;&gt;'</span><br><span class="line">let g:ycm_warning_symbol = '&gt;*'</span><br><span class="line">" Specifies Python interpreter to run jedi</span><br><span class="line">let g:ycm_python_binary_path = 'python3'</span><br><span class="line">" Seed its identifier database</span><br><span class="line">" let g:ycm_seed_identifiers_with_syntax=1</span><br><span class="line">" youcompleteme select keys</span><br><span class="line">let g:ycm_key_list_select_completion = ['&lt;Down&gt;']</span><br><span class="line">let g:ycm_key_list_previous_completion = ['&lt;Up&gt;']</span><br><span class="line">" Where GoTo* commands result should be opened, same-buffer</span><br><span class="line">let g:ycm_goto_buffer_command = 'horizontal-split'</span><br><span class="line">" nnoremap &lt;leader&gt;jd :YcmCompleter GoToDefinition&lt;CR&gt;</span><br><span class="line">" ,jd</span><br><span class="line">nnoremap &lt;leader&gt;jd :YcmCompleter GoToDefinitionElseDeclaration&lt;CR&gt;</span><br><span class="line">" ,gd</span><br><span class="line">nnoremap &lt;leader&gt;gd :YcmCompleter GoToDeclaration&lt;CR&gt;</span><br><span class="line">" ycm 配置</span><br><span class="line">let g:ycm_global_ycm_extra_conf = "~/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp/ycm/.ycm_extra_conf.py"</span><br><span class="line">" blacklist</span><br><span class="line">let g:ycm_filetype_blacklist = &#123;</span><br><span class="line">    \ 'gitcommit' : 1,</span><br><span class="line">    \ 'tagbar' : 1,</span><br><span class="line">    \ 'qf' : 1,</span><br><span class="line">    \ 'notes' : 1,</span><br><span class="line">    \ 'markdown' : 1,</span><br><span class="line">    \ 'unite' : 1,</span><br><span class="line">    \ 'text' : 1,</span><br><span class="line">    \ 'vimwiki' : 1,</span><br><span class="line">    \ 'pandoc' : 1,</span><br><span class="line">    \ 'infolog' : 1,</span><br><span class="line">    \ 'mail' : 1</span><br><span class="line">    \&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">" 代码片段</span><br><span class="line">let g:UltiSnipsExpandTrigger       = "&lt;TAB&gt;"</span><br><span class="line">let g:UltiSnipsJumpForwardTrigger  = "&lt;TAB&gt;"</span><br><span class="line">let g:UltiSnipsJumpBackwardTrigger = "&lt;S-TAB&gt;"</span><br><span class="line">let g:UltiSnipsSnippetDirectories  = ['UltiSnips']</span><br><span class="line">let g:UltiSnipsSnippetsDir = '~/.vim/bundle/vim-snippets/UltiSnips'</span><br><span class="line">" ,us 修改当前文件类型的代码片段</span><br><span class="line">map &lt;leader&gt;us :UltiSnipsEdit&lt;CR&gt;</span><br><span class="line"></span><br><span class="line">" ctrl+j/k</span><br><span class="line">func! g:JInYCM()</span><br><span class="line">    if pumvisible()</span><br><span class="line">        return "\&lt;C-n&gt;"</span><br><span class="line">    else</span><br><span class="line">        return "\&lt;c-j&gt;"</span><br><span class="line">    endif</span><br><span class="line">endfunction</span><br><span class="line"></span><br><span class="line">func! g:KInYCM()</span><br><span class="line">    if pumvisible()</span><br><span class="line">        return "\&lt;C-p&gt;"</span><br><span class="line">    else</span><br><span class="line">        return "\&lt;c-k&gt;"</span><br><span class="line">    endif</span><br><span class="line">endfunction</span><br><span class="line">inoremap &lt;c-j&gt; &lt;c-r&gt;=g:JInYCM()&lt;cr&gt;</span><br><span class="line">au BufEnter,BufRead * exec "inoremap &lt;silent&gt; " . g:UltiSnipsJumpBackwordTrigger . " &lt;C-R&gt;=g:KInYCM()&lt;cr&gt;"</span><br><span class="line">let g:UltiSnipsJumpBackwordTrigger = "&lt;c-k&gt;"</span><br><span class="line"></span><br><span class="line">" 符号自动补全</span><br><span class="line">let g:delimitMate_expand_cr = 1</span><br><span class="line">let delimitMate_balance_matchpairs = 1</span><br><span class="line">let g:delimitMate_expand_space = 2</span><br><span class="line">imap &lt;expr&gt; &lt;TAB&gt; delimitMate#ShouldJump() ? "&lt;Plug&gt;delimitMateS-Tab" : "&lt;TAB&gt;"</span><br><span class="line">inoremap &lt;expr&gt; &lt;S-Tab&gt; delimitMate#JumpAny()</span><br><span class="line"></span><br><span class="line">" 快速跳转</span><br><span class="line">let g:EasyMotion_smartcase = 1</span><br><span class="line">"let g:EasyMotion_startofline = 0 " keep cursor colum when JK motion</span><br><span class="line">" ,,h 显示往前可快速移动的点</span><br><span class="line">map &lt;Leader&gt;&lt;leader&gt;h &lt;Plug&gt;(easymotion-linebackward)</span><br><span class="line">" ,,j 显示往下可快速移动的点</span><br><span class="line">map &lt;Leader&gt;&lt;Leader&gt;j &lt;Plug&gt;(easymotion-j)</span><br><span class="line">" ,,k 显示往上可快速移动的点</span><br><span class="line">map &lt;Leader&gt;&lt;Leader&gt;k &lt;Plug&gt;(easymotion-k)</span><br><span class="line">" ,,l 显示往后可快速移动的点</span><br><span class="line">map &lt;Leader&gt;&lt;leader&gt;l &lt;Plug&gt;(easymotion-lineforward)</span><br><span class="line">" ,,. 显示上一次可快速移动的点</span><br><span class="line">map &lt;Leader&gt;&lt;leader&gt;. &lt;Plug&gt;(easymotion-repeat)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">" git 快捷操作</span><br><span class="line">" :Gdiff  :Gstatus :Gvsplit</span><br><span class="line">nnoremap &lt;leader&gt;gtaa :Git add .&lt;CR&gt;</span><br><span class="line">nnoremap &lt;leader&gt;gtc  :Gcommit&lt;CR&gt;</span><br><span class="line">nnoremap &lt;leader&gt;gtp  :Gpush&lt;CR&gt;</span><br><span class="line">nnoremap &lt;leader&gt;gtl  :Gpull&lt;CR&gt;</span><br><span class="line">nnoremap &lt;leader&gt;gtb  :Gblame&lt;CR&gt;</span><br><span class="line">nnoremap &lt;leader&gt;gtst :Gstatus&lt;CR&gt;</span><br><span class="line">nnoremap &lt;leader&gt;gtd  :Gdiff&lt;CR&gt;</span><br><span class="line">nnoremap &lt;leader&gt;gtlg :Glog&lt;CR&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">" multiplecursors </span><br><span class="line">let g:multi_cursor_use_default_mapping=0</span><br><span class="line">" Default mapping</span><br><span class="line">let g:multi_cursor_next_key='&lt;C-m&gt;'</span><br><span class="line">let g:multi_cursor_prev_key='&lt;C-p&gt;'</span><br><span class="line">let g:multi_cursor_skip_key='&lt;C-x&gt;'</span><br><span class="line">let g:multi_cursor_quit_key='&lt;Esc&gt;'</span><br><span class="line"></span><br><span class="line">" 一些状态栏的颜色</span><br><span class="line">hi Pmenu      guifg=#F6F3E8 guibg=#444444</span><br><span class="line">" hi PmenuSel   guifg=#FFFFFF guibg=#0077DD</span><br><span class="line">hi PmenuSel   guifg=#FFFFFF guibg=#11AADD</span><br><span class="line">hi PMenuSbar  guibg=#5A647E</span><br><span class="line">hi PMenuThumb guibg=#AAAAAA</span><br><span class="line">" hi Visual     guibg=#1122FF</span><br><span class="line">" hi Visual     guibg=#0066FF</span><br><span class="line">hi Visual     guibg=#2566FA</span><br><span class="line">" hi VertSplit guibg=#272822</span><br><span class="line">hi VertSplit guibg=#1B1D1E</span><br><span class="line">hi Cursor    guibg=#FF0000</span><br><span class="line"></span><br><span class="line">" 关闭初当前Buffer外的所有Buffer</span><br><span class="line">nmap &lt;Leader&gt;bo :BufOnly&lt;CR&gt;</span><br></pre></td></tr></table></figure><h3 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h3><p>vim一些基础操作可以看下图。</p><p><img data-src="https://st.razeen.cn/img/blog/vim-keyboard.jpg" alt></p><p>我这里主要整理一些组合操作（这里主要以上面的配置为准）</p><table><thead><tr><th>快捷键</th><th>操作</th><th>备注</th></tr></thead><tbody><tr><td>Cmd e</td><td>开启/关闭 侧边栏（目录树）</td><td></td></tr><tr><td>Cmd y</td><td>开启大纲</td><td></td></tr><tr><td>Cmd+/</td><td>代码注释</td><td></td></tr><tr><td>Ctrl j/k/h/l</td><td>多窗口切换</td><td></td></tr><tr><td>Shift h/l</td><td>切换缓冲区</td><td></td></tr><tr><td>Cmd f</td><td>快速搜索</td><td></td></tr><tr><td>:CO</td><td>打开上次搜索的结果</td><td></td></tr><tr><td>:w!!</td><td>用sudo权限保存文件</td><td></td></tr><tr><td>,1/2/3/4/5/6/7/8/9/0</td><td>切换tab</td><td></td></tr><tr><td>,zz</td><td>折叠行</td><td></td></tr><tr><td>,/</td><td>移除搜索高亮</td><td></td></tr><tr><td>,sa</td><td>选择全部</td><td></td></tr><tr><td>,w</td><td>保存当前文件</td><td></td></tr><tr><td>,bd</td><td>关闭当前缓冲区, 不关闭窗口</td><td></td></tr><tr><td>,gc</td><td>GoErrCheck</td><td></td></tr><tr><td>,gb</td><td>GoBuild</td><td></td></tr><tr><td>,gr</td><td>GoRename</td><td></td></tr><tr><td>,gl</td><td>GoLint</td><td></td></tr><tr><td>,us</td><td>修改当前文件类型的代码片段</td><td></td></tr><tr><td>,,h</td><td>显示往前可快速移动的点</td><td></td></tr><tr><td>,,j</td><td>显示往下可快速移动的点</td><td></td></tr><tr><td>,,k</td><td>显示往上可快速移动的点</td><td></td></tr><tr><td>,,l</td><td>显示往后可快速移动的点</td><td></td></tr><tr><td>,,.</td><td>显示上一次可快速移动的点</td><td></td></tr><tr><td>,gtaa</td><td>Git add</td><td></td></tr><tr><td>,gtc</td><td>git commit</td><td></td></tr><tr><td>,gtl</td><td>git pull</td><td></td></tr><tr><td>,bo</td><td>:BufOnly 关闭初当前Buffer外的所有Buffer</td></tr></tbody></table><h3 id="快速使用该配置"><a href="#快速使用该配置" class="headerlink" title="快速使用该配置"></a>快速使用该配置</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -kSL https://raw.githubusercontent.com/razeencheng/dotfiles/master/macvim/install.sh | sh</span><br></pre></td></tr></table></figure><p>然后打开MacVim执行 “:PluginInstall”。</p><h3 id="QA"><a href="#QA" class="headerlink" title="QA"></a>QA</h3><p><strong>Q1</strong>. 插件安装后，关于<code>YouCompleteMe</code>报错。</p><p><strong>A1</strong>. <code>YouCompleteMe</code>插件需要单独配置, 你可以配置你需要的语言，如golang:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span>  ~/.vim/bundle/YouCompleteMe</span><br><span class="line">git clean -f</span><br><span class="line">git pull</span><br><span class="line">git submodule update --recursive --init</span><br><span class="line">./install.py --clang-completer --go-completer</span><br></pre></td></tr></table></figure><p><strong>Q2</strong>. Cmd f / Cmd e 与MacVim系统按键冲突。</p><p><strong>A2</strong>. 要么修改系统按键，要么修改配置。由于使用频率较高，我把系统的改了，如下。</p><p><img data-src="https://st.razeen.cn/img/blog/modify_sys_keyboard.jpg" alt></p><p>大概4步：</p><ol><li>找到是什么菜单占用了你的按键， 如 “Find…‘;</li><li>在“系统设置” &gt; “键盘” &gt; ‘快捷键’ 中添加你的MacVim；</li><li>修改占用菜单（如“Find…”） 为其他快捷键；</li><li>回来再看看，原来的快捷键已经改了，不再冲突了。</li></ol><p><strong>Q3</strong>: 搜索报错 <code>Option &#39;*g*:*ctrlsf_ackprg*&#39; is not defined or empty.</code></p><p><strong>A3</strong>: 要安装依赖 <code>brew install the_silver_searcher</code></p><h3 id="在-Ubuntu-上的使用"><a href="#在-Ubuntu-上的使用" class="headerlink" title="在 Ubuntu 上的使用"></a>在 Ubuntu 上的使用</h3><p>最近在折腾 Ubuntu, 尝试将这套配置用在 Ubuntu 上。</p><ul><li><p>首先需要安装 <code>Vundle</code>:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/VundleVim/Vundle.vim.git ~/.vim/bundle/Vundle.vim</span><br></pre></td></tr></table></figure></li><li><p>安装 <code>YouCompleteMe</code> 需要先安装 <code>python3-dev</code> 和 <code>cmake</code>:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt install python3-dev cmake</span><br></pre></td></tr></table></figure></li></ul><p>之后就可可以愉快的使用了。</p>]]></content>
      <categories>
        <category>开发实战总结</category>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title>记一次 Nginx DNS 缓存导致转发问题</title>
    <url>//post/nginx-proxy-problem-with-dns-cache.html</url>
    <content><![CDATA[<p>在家里搭建了一个 GitLab 服务器，由于电信家庭宽带的公网 IP 是不固定的，且<code>443</code>端口是被封的，所以买了阿里云作为中转，利用 Ngnix 作 TCP Proxy 结合 DDNS ，这样就能正常上自己的 Git 了。但今天，我发现推代码怎么也推不上去，校对了密钥，服务器状态都没问题。最后上阿里云，重启了下 Nginx，发现可以了。 找了一圈原因，最后发现是 Nginx 转发缓存 DNS 解析导致的，下面我们就复现一下问题并找找为什么，以及解决方式。</p><a id="more"></a><h3 id="复现问题"><a href="#复现问题" class="headerlink" title="复现问题"></a>复现问题</h3><blockquote><p>系统： CentOS 8.3.2011</p><p>Nginx : nginx/1.14.1</p></blockquote><ol><li>直接在默认配置中加上如下配置，其中本地的<code>80</code>端口跑的是 Nginx 默认的服务：</li></ol><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">stream</span> &#123;</span><br><span class="line">    <span class="attribute">log_format</span> basic <span class="string">'<span class="variable">$remote_addr</span> [<span class="variable">$time_local</span>] '</span></span><br><span class="line">                 <span class="string">'<span class="variable">$protocol</span> <span class="variable">$status</span> <span class="variable">$bytes_sent</span> <span class="variable">$bytes_received</span> '</span></span><br><span class="line">                 <span class="string">'<span class="variable">$session_time</span> "<span class="variable">$upstream_addr</span>"'</span>;</span><br><span class="line"></span><br><span class="line">	<span class="attribute">access_log</span> /var/logs/nginx/access2.log basic;</span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span> <span class="number">8080</span>；</span><br><span class="line">        proxy_pass test.razeen.cn:<span class="number">80</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时，<code>test.razeen.cn</code>并没有解析，直接启动<code>nginx</code>，会报错:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nignx: [emerg] host not found <span class="keyword">in</span> upstream <span class="string">"test.razeen.cn"</span> <span class="keyword">in</span> /etc/nginx/nginx.conf:94</span><br></pre></td></tr></table></figure><ol start="2"><li>我添加解析。</li></ol><p><img data-src="https://st.razeen.cn/img/20210306224001_image-20210306224001679.png" alt="image-20210306224001679"></p><p>再次启动，成功启动 nginx, 访问 <code>8080</code> 端口，页面成功展示，日志如下：</p><p><img data-src="https://st.razeen.cn/img/20210306225944_image-20210306225944957.png" alt="image-20210306225944957"></p><p>一切正常。</p><ol start="3"><li>修改解析，解析到其他IP。</li></ol><p><img data-src="https://st.razeen.cn/img/20210306230154_image-20210306230154560.png" alt="image-20210306230154560"></p><p>600s后，无论我们再次访问，查看日志，还是转到了原来的 IP。</p><p><img data-src="https://st.razeen.cn/img/20210306230748_image-20210306230748682.png" alt="image-20210306230748682"></p><ol start="4"><li>重启 nginx, 再次访问，这是 IP 才变成后面修改的。</li></ol><p><img data-src="https://st.razeen.cn/img/20210306231106_image-20210306231106575.png" alt="image-20210306231106575"></p><p>从这里可以看出，Nginx 在启动的时候就会去查询DNS记录，如果不存在解析，直接无法启动。 但，如果中间修改域名的 DNS 解析，Nginx 中的解析并不会刷新。只有 <code>reload or restart</code> 后才会刷新。</p><p>那么实际是什么样的呢？</p><h3 id="解析机制"><a href="#解析机制" class="headerlink" title="解析机制"></a>解析机制</h3><p>直接去查找了一下相关的文章, 从这篇<a href="https://www.nginx.com/blog/dns-service-discovery-nginx-plus/" target="_blank" rel="noopener">Using DNS for Service Discovery with NGINX and NGINX Plus</a> 我们知道:</p><blockquote><p>As NGINX starts up or reloads its configuration, it queries a DNS server to resolve <strong>backends.example.com</strong>. The DNS server returns the list of three backends discussed above, and NGINX uses the default Round Robin algorithm to load balance requests among them. NGINX chooses the DNS server from the OS configuration file <strong>/etc/resolv.conf</strong>.</p><p>This method is the least flexible way to do service discovery and has the following additional drawbacks:</p><ul><li>If the domain name can’t be resolved, NGINX fails to start or reload its configuration.</li><li>NGINX caches the DNS records until the next restart or configuration reload, ignoring the records’ TTL values.</li><li>We can’t specify another load‑balancing algorithm, nor can we configure passive health checks or other features defined by parameters to the <code>server</code> directive, which we’ll describe in the next section.</li></ul></blockquote><ul><li>Nginx 在启动/重载的时候回去解析转发的域名</li><li>如果域名无法解析 Nginx 就无法启动</li><li>只有下次重启/重载的时候才会重新去解析，启动后无视TTL</li></ul><p><em>同时，如果能解析到多个 IP，还会有相应的负载均衡策略哦，后面可以再研究下这个。</em></p><p>这下就很明白了，原来坑就在这里，那么该怎么解决呢？</p><h3 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h3><p>在上面的文章中其实就给出了一种解决方案。</p><p>如下，我们可以指定 DNS 解析服务器并设置 DNS 刷新频率。</p><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="attribute">resolver</span> <span class="number">10.0.0.2</span> valid=<span class="number">10s</span>;</span><br><span class="line"></span><br><span class="line">	<span class="section">server</span> &#123;</span><br><span class="line">        <span class="comment"># resolver 10.0.0.2 valid=10s;  # 也可以写在这里</span></span><br><span class="line">    	<span class="attribute">location</span> / &#123;</span><br><span class="line">            <span class="comment"># resolver 10.0.0.2 valid=10s;   # 也可以写在这</span></span><br><span class="line">        	<span class="attribute">set</span> <span class="variable">$backend_servers</span> backends.example.com;</span><br><span class="line">        	<span class="attribute">proxy_pass</span> http://<span class="variable">$backend_servers</span>:8080;</span><br><span class="line">    	&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面，<code>resolver</code>就是 DNS 服务器的地址， <code>valid</code>是 DNS 刷新的频率<sup>[1]</sup>。</p><p>但，上面这种写法只适合在 <code>http proxy</code>中，在<code>stream proxy</code>中并没有<code>set</code>关键字，如果这么写启动会直接报错。查阅一番后，如下写法是可行的:</p><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">stream</span> &#123;</span><br><span class="line">    <span class="attribute">resolver</span> <span class="number">114.114.114.114</span> valid=<span class="number">10s</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">map</span> <span class="variable">$remote_addr</span> <span class="variable">$backend</span> &#123;</span><br><span class="line">        <span class="attribute">default</span>  test.razeen.cn;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span> <span class="number">8080</span>;</span><br><span class="line">        <span class="comment"># resolver 114.114.114.114 valid=10s;  # 也可以写在这里</span></span><br><span class="line">        <span class="attribute">proxy_pass</span> <span class="variable">$backend</span>:<span class="number">80</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>[1]</strong> 但经过验证，这个 <code>valid</code> DNS 刷新频率还要取决于你<code>resolver</code>中使用的解析服务器。如果<code>resolver</code>不是无缓存的DNS服务器，解析生效就会受影响。</p><p>同时通过 <a href="http://nginx.org/en/docs/stream/ngx_stream_core_module.html" target="_blank" rel="noopener">官方文档</a> 看到，在 <code>stream proxy</code> 中 <code>resolver</code> 既可以写在 <code>steam</code>中，也可以写在<code>server</code>中:</p><blockquote><table><thead><tr><th style="text-align:left">Syntax:</th><th>`<strong>resolver</strong> <em>address</em> … [valid=<em>time</em>] [ipv6=on</th><th>off] [status_zone=<em>zone</em>];`</th></tr></thead><tbody><tr><td style="text-align:left">Default:</td><td>—</td></tr><tr><td style="text-align:left">Context:</td><td><code>stream</code>, <code>server</code></td></tr></tbody></table><p>This directive appeared in version 1.11.3.</p></blockquote><p>在 <a href="http://nginx.org/en/docs/http/ngx_http_core_module.html#resolver" target="_blank" rel="noopener">HTTP PRXOY</a>, <code>resolver</code>可以写在<code>http</code>, <code>server</code>, <code>location</code> 中, <code>set</code> 可以写在<code>server</code>和<code>location</code>中。</p><p>同时上面这样写后，即使域名解析不到也不会导致 Nginx 启动/重启 失败。</p><p>在<a href="https://segmentfault.com/a/1190000022365954" target="_blank" rel="noopener">这篇文章</a>中还提供了其他几种设置方法，也可以参考。</p>]]></content>
      <categories>
        <category>开发实战总结</category>
      </categories>
      <tags>
        <tag>nginx</tag>
        <tag>dns</tag>
      </tags>
  </entry>
  <entry>
    <title>TLS1.3正式更新，为Nginx添加TLS1.3的支持</title>
    <url>//post/nginx-tls1.3-draft26.html</url>
    <content><![CDATA[<h3 id="关于TLS1-3"><a href="#关于TLS1-3" class="headerlink" title="关于TLS1.3"></a>关于TLS1.3</h3><p>在<a href="https://github.com/openssl/openssl/tree/OpenSSL_1_1_1" target="_blank" rel="noopener">OpenSSL的github开源项目</a>中我们可以看到最新的tag为<code>OpenSSL_1_1_1</code>,该版本为<a href="https://github.com/openssl/openssl/blob/OpenSSL_1_1_1/include/openssl/tls1.h#L30" target="_blank" rel="noopener">TLS1.3正式版</a>。</p><blockquote><p>更新：2018/09/12 昨天前OpenSSL_1_1_1发布了，已更新。</p></blockquote><blockquote><p>更多TLS v1.3内容看<a href="https://razeen.me/post/detail-of-tls13.html" target="_blank" rel="noopener">这里</a></p></blockquote><blockquote><p>nginx 更新到v1.15.8</p></blockquote><p>从<a href="https://www.openssl.org/blog/blog/2017/05/04/tlsv1.3/" target="_blank" rel="noopener">OpenSSL的博客</a>中，我们知道TLS1.3与1TLS1.2的主要差异有以下几点：</p><a id="more"></a><ul><li>有新的套件，旧的套件无法用在1.3连接中；</li><li>套件的定义与以往不一样，新的套件不指定证书类型(eg:RSA,DSA,ECDSA)以及秘钥交换机制(eg:DHE,ECDHE) ;</li><li>客户在<code>ClientHello</code>中提供<code>key_share</code>。这对<code>group</code>配置有影响;（这个group是什么，我还没去研究）</li><li>会话直到主要握手完成后才建立;</li><li>不支持重协商;</li><li>更多的握手被加密;</li><li>更多类型的消息可以扩展;</li><li>弃用DSA证书。（DSA貌似现在也没怎么见）</li></ul><h3 id="编译Nginx"><a href="#编译Nginx" class="headerlink" title="编译Nginx"></a>编译Nginx</h3><p><em>我的服务器：CentOS 7.4 64位</em></p><p>其实编译nginx很多人都写过，我这里主要参考<a href="https://imququ.com/post/my-nginx-conf.html" target="_blank" rel="noopener">ququ大神</a>的博客配置的。</p><h4 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装开发工具</span></span><br><span class="line">sudo yum groupinstall -y <span class="string">"Development Tools"</span></span><br><span class="line"><span class="comment"># 安装依赖</span></span><br><span class="line">sudo yum install -y git wget zlib zlib-devel pcre-devel lua-devel</span><br></pre></td></tr></table></figure><h4 id="获取组件"><a href="#获取组件" class="headerlink" title="获取组件"></a>获取组件</h4><p>这部分主要是按照曲曲的配置来的，我就不细说。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 启用CT功能的nginx-ct</span></span><br><span class="line">wget -O nginx-ct.zip -c https://github.com/grahamedgecombe/nginx-ct/archive/v1.3.2.zip</span><br><span class="line">unzip nginx-ct.zip</span><br><span class="line"></span><br><span class="line"><span class="comment"># Google的Brotli 压缩算法，减少流量</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/bagder/libbrotli</span><br><span class="line"><span class="built_in">cd</span> libbrotli</span><br><span class="line">./autogen.sh</span><br><span class="line">./configure</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br><span class="line"><span class="built_in">cd</span>  ../</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取ngx-brotli源码</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/google/ngx_brotli.git</span><br><span class="line"><span class="built_in">cd</span> ngx_brotli</span><br><span class="line"></span><br><span class="line">git submodule update --init </span><br><span class="line"><span class="built_in">cd</span> ../</span><br></pre></td></tr></table></figure><h4 id="OpenSSL"><a href="#OpenSSL" class="headerlink" title="OpenSSL"></a>OpenSSL</h4><p>下载GitHub上最新的pre6版本即可。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://codeload.github.com/openssl/openssl/tar.gz/OpenSSL_1_1_1</span><br><span class="line">tar -zxvf OpenSSL_1_1_1</span><br><span class="line">mv openssl-OpenSSL_1_1_1 openssl</span><br></pre></td></tr></table></figure><h4 id="编译安装Nginx"><a href="#编译安装Nginx" class="headerlink" title="编译安装Nginx"></a>编译安装Nginx</h4><p>获取 Nginx 源码：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget -c https://nginx.org/download/nginx-1.15.8.tar.gz</span><br><span class="line">tar -zxvf nginx-1.15.8.tar.gz</span><br><span class="line"><span class="built_in">cd</span> nginx-1.15.8/</span><br></pre></td></tr></table></figure><p>编译以及安装</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./configure --add-module=../ngx_brotli --add-module=../nginx-ct-1.3.2 --with-openssl=../openssl --with-http_v2_module --with-http_ssl_module --with-http_gzip_static_module</span><br><span class="line"></span><br><span class="line">make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure><p>这一步完成，会给你一些提示，其中一些路径它会打印出来,configure时没指定就会使用默认的，如下。</p><blockquote><p>nginx path prefix: “/usr/local/nginx”</p></blockquote><blockquote><p>nginx binary file: “/usr/local/nginx/sbin/nginx”</p></blockquote><blockquote><p>nginx modules path: “/usr/local/nginx/modules”</p></blockquote><blockquote><p>nginx configuration prefix: “/usr/local/nginx/conf”</p></blockquote><blockquote><p>nginx configuration file: “/usr/local/nginx/conf/nginx.conf”</p></blockquote><blockquote><p>nginx pid file: “/usr/local/nginx/logs/nginx.pid”</p></blockquote><blockquote><p>nginx error log file: “/usr/local/nginx/logs/error.log”</p></blockquote><blockquote><p>nginx http access log file: “/usr/local/nginx/logs/access.log”</p></blockquote><blockquote><p>nginx http client request body temporary files: “client_body_temp”</p></blockquote><blockquote><p>nginx http proxy temporary files: “proxy_temp”</p></blockquote><blockquote><p>nginx http fastcgi temporary files: “fastcgi_temp”</p></blockquote><blockquote><p>nginx http uwsgi temporary files: “uwsgi_temp”</p></blockquote><blockquote><p>nginx http scgi temporary files: “scgi_temp”</p></blockquote><p>完成后可以将nginx加入到path中,或软链进去的。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ln /usr/<span class="built_in">local</span>/nginx/sbin/nginx /usr/<span class="built_in">local</span>/bin/nginx</span><br></pre></td></tr></table></figure><p>查看一下是否安装正确：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ nginx -V</span><br><span class="line">nginx version: nginx/1.15.8</span><br><span class="line">built by gcc 4.8.5 20150623 (Red Hat 4.8.5-36) (GCC)</span><br><span class="line">built with OpenSSL 1.1.1  11 Sep 2018</span><br><span class="line">TLS SNI support enabled</span><br><span class="line">configure arguments: --add-module=../ngx_brotli --add-module=../nginx-ct-1.3.2 --with-openssl=../openssl --with-http_v2_module --with-http_ssl_module --with-http_gzip_static_module</span><br></pre></td></tr></table></figure><p><code>OpenSSL 1.1.1</code>与<code>nginx/1.15.8</code> 看来已经OK了。</p><h4 id="管理脚本与自启"><a href="#管理脚本与自启" class="headerlink" title="管理脚本与自启"></a>管理脚本与自启</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/init.d/nginx</span><br></pre></td></tr></table></figure><p>输入以下内容：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#! /bin/sh</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### BEGIN INIT INFO</span></span><br><span class="line"><span class="comment"># Provides:          nginx</span></span><br><span class="line"><span class="comment"># Required-Start:    $all</span></span><br><span class="line"><span class="comment"># Required-Stop:     $all</span></span><br><span class="line"><span class="comment"># Default-Start:     2 3 4 5</span></span><br><span class="line"><span class="comment"># Default-Stop:      0 1 6</span></span><br><span class="line"><span class="comment"># Short-Description: starts the nginx web server</span></span><br><span class="line"><span class="comment"># Description:       starts nginx using start-stop-daemon</span></span><br><span class="line"><span class="comment">### END INIT INFO</span></span><br><span class="line"></span><br><span class="line">PATH=/usr/<span class="built_in">local</span>/sbin:/usr/<span class="built_in">local</span>/bin:/sbin:/bin:/usr/sbin:/usr/bin</span><br><span class="line">DAEMON=/usr/<span class="built_in">local</span>/nginx/sbin/nginx</span><br><span class="line">NAME=nginx</span><br><span class="line">DESC=nginx</span><br><span class="line"></span><br><span class="line"><span class="built_in">test</span> -x <span class="variable">$DAEMON</span> || <span class="built_in">exit</span> 0</span><br><span class="line"></span><br><span class="line"><span class="comment"># Include nginx defaults if available</span></span><br><span class="line"><span class="keyword">if</span> [ -f /etc/default/nginx ] ; <span class="keyword">then</span></span><br><span class="line">  . /etc/default/nginx</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> -e</span><br><span class="line"></span><br><span class="line">. /lib/lsb/init-functions</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="string">"<span class="variable">$1</span>"</span> <span class="keyword">in</span></span><br><span class="line">  start)</span><br><span class="line">    <span class="built_in">echo</span> -n <span class="string">"Starting <span class="variable">$DESC</span>: "</span></span><br><span class="line">    start-stop-daemon --start --quiet --pidfile /usr/<span class="built_in">local</span>/nginx/logs/<span class="variable">$NAME</span>.pid \</span><br><span class="line">        --<span class="built_in">exec</span> <span class="variable">$DAEMON</span> -- <span class="variable">$DAEMON_OPTS</span> || <span class="literal">true</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"<span class="variable">$NAME</span>."</span></span><br><span class="line">    ;;</span><br><span class="line">  stop)</span><br><span class="line">    <span class="built_in">echo</span> -n <span class="string">"Stopping <span class="variable">$DESC</span>: "</span></span><br><span class="line">    start-stop-daemon --stop --quiet --pidfile /usr/<span class="built_in">local</span>/nginx/logs/<span class="variable">$NAME</span>.pid \</span><br><span class="line">        --<span class="built_in">exec</span> <span class="variable">$DAEMON</span> || <span class="literal">true</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"<span class="variable">$NAME</span>."</span></span><br><span class="line">    ;;</span><br><span class="line">  restart|force-reload)</span><br><span class="line">    <span class="built_in">echo</span> -n <span class="string">"Restarting <span class="variable">$DESC</span>: "</span></span><br><span class="line">    start-stop-daemon --stop --quiet --pidfile \</span><br><span class="line">        /usr/<span class="built_in">local</span>/nginx/logs/<span class="variable">$NAME</span>.pid --<span class="built_in">exec</span> <span class="variable">$DAEMON</span> || <span class="literal">true</span></span><br><span class="line">    sleep 1</span><br><span class="line">    start-stop-daemon --start --quiet --pidfile \</span><br><span class="line">        /usr/<span class="built_in">local</span>/nginx/logs/<span class="variable">$NAME</span>.pid --<span class="built_in">exec</span> <span class="variable">$DAEMON</span> -- <span class="variable">$DAEMON_OPTS</span> || <span class="literal">true</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"<span class="variable">$NAME</span>."</span></span><br><span class="line">    ;;</span><br><span class="line">  reload)</span><br><span class="line">    <span class="built_in">echo</span> -n <span class="string">"Reloading <span class="variable">$DESC</span> configuration: "</span></span><br><span class="line">    start-stop-daemon --stop --signal HUP --quiet --pidfile /usr/<span class="built_in">local</span>/nginx/logs/<span class="variable">$NAME</span>.pid \</span><br><span class="line">        --<span class="built_in">exec</span> <span class="variable">$DAEMON</span> || <span class="literal">true</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"<span class="variable">$NAME</span>."</span></span><br><span class="line">    ;;</span><br><span class="line">  status)</span><br><span class="line">    status_of_proc -p /usr/<span class="built_in">local</span>/nginx/logs/<span class="variable">$NAME</span>.pid <span class="string">"<span class="variable">$DAEMON</span>"</span> nginx &amp;&amp; <span class="built_in">exit</span> 0 || <span class="built_in">exit</span> $?</span><br><span class="line">    ;;</span><br><span class="line">  *)</span><br><span class="line">    N=/etc/init.d/<span class="variable">$NAME</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"Usage: <span class="variable">$N</span> &#123;start|stop|restart|reload|force-reload|status&#125;"</span> &gt;&amp;2</span><br><span class="line">    <span class="built_in">exit</span> 1</span><br><span class="line">    ;;</span><br><span class="line"><span class="keyword">esac</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span> 0</span><br></pre></td></tr></table></figure><p>增加执行权限：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo chmod a+x /etc/init.d/nginx</span><br></pre></td></tr></table></figure><p>现在管理 Nginx 只需使用以下命令即可：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo service nginx start|stop|restart|reload</span><br></pre></td></tr></table></figure><p>如果启动出现错误<code>Starting nginx: /etc/init.d/nginx: line 32: start-stop-daemon: command not found</code>,那是<code>start-stop-daemon</code>工具没有安装，可按照以下方式安装。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget http://developer.axis.com/download/distribution/apps-sys-utils-start-stop-daemon-IR1_9_18-2.tar.gz</span><br><span class="line">tar zxf apps-sys-utils-start-stop-daemon-IR1_9_18-2.tar.gz</span><br><span class="line">mv apps/sys-utils/start-stop-daemon-IR1_9_18-2/ ./</span><br><span class="line">rm -rf apps</span><br><span class="line"><span class="built_in">cd</span> start-stop-daemon-IR1_9_18-2/</span><br><span class="line">cc start-stop-daemon.c -o start-stop-daemon</span><br><span class="line">cp start-stop-daemon /usr/<span class="built_in">local</span>/bin/start-stop-daemon</span><br><span class="line"><span class="built_in">cd</span> ../</span><br></pre></td></tr></table></figure><p>开机自动启动 Nginx，执行以下命令：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo chkconfig nginx on</span><br></pre></td></tr></table></figure><h4 id="Nginx配置"><a href="#Nginx配置" class="headerlink" title="Nginx配置"></a>Nginx配置</h4><p>最后贴以下我的nginx全局配置以及博客配置。</p><p>全局配置<code>vim /usr/local/nginx/conf/nginx.conf</code></p><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="attribute">include</span>       mime.types;</span><br><span class="line">    <span class="attribute">default_type</span>  application/octet-stream;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '</span></span><br><span class="line">    <span class="comment">#                  '$status $body_bytes_sent "$http_referer" '</span></span><br><span class="line">    <span class="comment">#                  '"$http_user_agent" "$http_x_forwarded_for"';</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#access_log  logs/access.log  main;</span></span><br><span class="line"></span><br><span class="line">    <span class="attribute">charset</span> UTF-<span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">sendfile</span>        <span class="literal">on</span>;</span><br><span class="line">    <span class="attribute">tcp_nopush</span>      <span class="literal">on</span>;</span><br><span class="line">    <span class="attribute">tcp_nodelay</span>     <span class="literal">on</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#keepalive_timeout  0;</span></span><br><span class="line">    <span class="attribute">keepalive_timeout</span>  <span class="number">65</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">gzip</span>           <span class="literal">on</span>;</span><br><span class="line">    <span class="attribute">gzip_vary</span>      <span class="literal">on</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">gzip_comp_level</span>    <span class="number">6</span>;</span><br><span class="line">    <span class="attribute">gzip_buffers</span>       <span class="number">16</span> <span class="number">8k</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">gzip_min_length</span>    <span class="number">1000</span>;</span><br><span class="line">    <span class="attribute">gzip_proxied</span>       any;</span><br><span class="line">    <span class="attribute">gzip_disable</span>       <span class="string">"msie6"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">gzip_http_version</span>  <span class="number">1</span>.<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">gzip_types</span>         text/plain text/css application/json application/x-javascript text/xml application/xml application/xml+rss text/javascript application/javascript image/svg+xml;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 如果编译时添加了 ngx_brotli 模块，需要增加 brotli 相关配置</span></span><br><span class="line">    <span class="attribute">brotli</span>             <span class="literal">on</span>;</span><br><span class="line">    <span class="attribute">brotli_comp_level</span>  <span class="number">6</span>;</span><br><span class="line">    <span class="attribute">brotli_types</span>       text/plain text/css application/json application/x-javascript text/xml application/xml application/xml+rss text/javascript application/javascript image/svg+xml;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">include</span>            /www/*/<span class="regexp">*.conf</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>博客配置 <code>vim /www/blog/nginx.conf</code></p><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>                       <span class="number">443</span> ssl default http2 fastopen=<span class="number">3</span> reuseport;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">server_name</span>                  razeen.me www.razeen.me blog.netcj.com;</span><br><span class="line">    <span class="attribute">server_tokens</span>                <span class="literal">off</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">access_log</span>                   /www/blog/logdata/nginx.log;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># ip 黑名单</span></span><br><span class="line">    <span class="attribute">include</span>                      /www/blog/ip.blacklist;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 现在一般证书是内置的。letsencrypt 暂未</span></span><br><span class="line">    <span class="comment"># https://imququ.com/post/certificate-transparency.html#toc-2</span></span><br><span class="line">    <span class="comment"># ssl_ct                       on;</span></span><br><span class="line">    <span class="comment"># ssl_ct_static_scts           /www/blog/scts/rsa/;</span></span><br><span class="line">    <span class="comment"># ssl_ct_static_scts           /www/blog/scts/ecc/;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 中间证书 + 根证书</span></span><br><span class="line">    <span class="comment"># https://imququ.com/post/why-can-not-turn-on-ocsp-stapling.html</span></span><br><span class="line">    <span class="attribute">ssl_trusted_certificate</span>      /www/blog/ca_file.pem;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 站点证书 + 中间证书，私钥</span></span><br><span class="line">    <span class="attribute">ssl_certificate</span>              /root/.acme.sh/netcj.com/fullchain.cer;</span><br><span class="line">    <span class="attribute">ssl_certificate_key</span>          /root/.acme.sh/netcj.com/netcj.com.key;</span><br><span class="line">    <span class="attribute">ssl_certificate</span>              /root/.acme.sh/netcj.com_ecc/fullchain.cer;</span><br><span class="line">    <span class="attribute">ssl_certificate_key</span>          /root/.acme.sh/netcj.com_ecc/netcj.com.key;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># openssl dhparam -out dhparams.pem 2048</span></span><br><span class="line">    <span class="comment"># https://weakdh.org/sysadmin.html</span></span><br><span class="line">    <span class="attribute">ssl_dhparam</span>                  /www/blog/dhparams.pem;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># openssl rand 48 &gt; session_ticket.key</span></span><br><span class="line">    <span class="comment"># 单机部署可以不指定 ssl_session_ticket_key</span></span><br><span class="line">    <span class="comment"># ssl_session_ticket_key     /www/blog/session_ticket.key;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># https://github.com/cloudflare/sslconfig/blob/master/conf</span></span><br><span class="line">    <span class="comment"># ssl_ciphers               EECDH+CHACHA20:EECDH+CHACHA20-draft:EECDH+AES128:RSA+AES128:EECDH+AES256:RSA+AES256:EECDH+3DES:RSA+3DES:!MD5;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 如果启用了 RSA + ECDSA 双证书，Cipher Suite 可以参考以下配置：</span></span><br><span class="line">    <span class="comment"># ssl_ciphers                 EECDH+CHACHA20:EECDH+CHACHA20-draft:EECDH+ECDSA+AES128:EECDH+aRSA+AES128:RSA+AES128:EECDH+ECDSA+AES256:EECDH+aRSA+AES256:RSA+AES256:EECDH+ECDSA+3DES:EECDH+aRSA+3DES:RSA+3DES:!MD5;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># TLS 1.3</span></span><br><span class="line">    <span class="attribute">ssl_ciphers</span>                 TLS13-AES-<span class="number">256</span>-GCM-SHA384:TLS13-CHACHA20-POLY1305-SHA256:TLS13-AES-<span class="number">128</span>-GCM-SHA256:TLS13-AES-<span class="number">128</span>-CCM-<span class="number">8</span>-SHA256:TLS13-AES-<span class="number">128</span>-CCM-SHA256:EECDH+CHACHA20:EECDH+CHACHA20-draft:EECDH+ECDSA+AES128:EECDH+aRSA+AES128:RSA+AES128:EECDH+ECDSA+AES256:EECDH+aRSA+AES256:RSA+AES256:EECDH+ECDSA+3DES:EECDH+aRSA+3DES:RSA+3DES:!MD5;</span><br><span class="line"><span class="attribute">ssl_prefer_server_ciphers</span>    <span class="literal">on</span>;</span><br><span class="line">    <span class="attribute">ssl_protocols</span>                TLSv1 TLSv1.<span class="number">1</span> TLSv1.<span class="number">2</span> TLSv1.<span class="number">3</span>;</span><br><span class="line">    <span class="attribute">ssl_session_cache</span>            shared:SSL:<span class="number">50m</span>;</span><br><span class="line">    <span class="attribute">ssl_session_timeout</span>          <span class="number">1d</span>;</span><br><span class="line">    <span class="attribute">ssl_session_tickets</span>          <span class="literal">on</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># ssl stapling</span></span><br><span class="line">    <span class="attribute">ssl_stapling</span>                 <span class="literal">on</span>;</span><br><span class="line">    <span class="attribute">ssl_stapling_verify</span>          <span class="literal">on</span>;</span><br><span class="line">    <span class="attribute">resolver</span>                     <span class="number">114.114.114.114</span> <span class="number">8.8.8.8</span> valid=<span class="number">300s</span>;</span><br><span class="line">    <span class="attribute">resolver_timeout</span>             <span class="number">10s</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">if</span> (<span class="variable">$request_method</span> !<span class="regexp">~ ^(GET|HEAD|POST|OPTIONS)$</span> ) &#123;</span><br><span class="line">        <span class="attribute">return</span>                   <span class="number">444</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#if ($host != 'razeen.me' ) &#123;</span></span><br><span class="line">    <span class="comment">#   rewrite                  ^/(.*)$  https://razeen.me/$1 permanent;</span></span><br><span class="line">    <span class="comment">#&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># webmaster 站点验证相关</span></span><br><span class="line">    <span class="attribute">location</span> <span class="regexp">~* (google4c90d18e696bdcf8\.html|BingSiteAuth\.xml)$</span> &#123;</span><br><span class="line">        <span class="attribute">root</span>                     /www/blog/static;</span><br><span class="line">        <span class="attribute">expires</span>                  <span class="number">1d</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">location</span><span class="regexp"> ^~</span> /admin/ &#123;</span><br><span class="line">        <span class="attribute">proxy_http_version</span>       <span class="number">1</span>.<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">add_header</span>               Strict-Transport-Security <span class="string">"max-age=31536000; includeSubDomains; preload"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># deny 将完全不允许页面被嵌套，可能会导致一些异常。如果遇到这样的问题，建议改成 SAMEORIGIN</span></span><br><span class="line">        <span class="comment"># https://imququ.com/post/web-security-and-response-header.html#toc-1</span></span><br><span class="line">        <span class="attribute">add_header</span>               X-Frame-Options deny;</span><br><span class="line">        <span class="attribute">add_header</span>               X-Powered-By eiblog/<span class="number">1</span>.<span class="number">3</span>.<span class="number">0</span>;</span><br><span class="line">        <span class="attribute">add_header</span>               X-Content-Type-Options nosniff;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">proxy_set_header</span>         Connection       <span class="string">""</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span>         Host             razeen.me;</span><br><span class="line">        <span class="attribute">proxy_set_header</span>         X-Real_IP        <span class="variable">$remote_addr</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span>         X-Forwarded-For  <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">proxy_pass</span>               http://127.0.0.1:9000;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">location</span> / &#123;</span><br><span class="line">        <span class="attribute">proxy_http_version</span>       <span class="number">1</span>.<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">add_header</span>               Strict-Transport-Security <span class="string">"max-age=31536000; includeSubDomains; preload"</span>;</span><br><span class="line">        <span class="attribute">add_header</span>               X-Frame-Options deny;</span><br><span class="line">        <span class="attribute">add_header</span>               X-Content-Type-Options nosniff;</span><br><span class="line">        <span class="attribute">add_header</span>               Content-Security-Policy <span class="string">"default-src 'none'; script-src 'unsafe-inline' 'unsafe-eval' blob: https:; img-src data: https: https://st.razeen.cn; media-src https://st.razeen.cn; style-src 'unsafe-inline' https:; child-src https:; connect-src 'self' https://translate.googleapis.com; frame-src https://disqus.com https://www.slideshare.net"</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 中间证书证书指纹</span></span><br><span class="line">        <span class="comment"># https://imququ.com/post/http-public-key-pinning.html</span></span><br><span class="line">        <span class="attribute">add_header</span>               Public-Key-Pins <span class="string">'pin-sha256="YLh1dUR9y6Kja30RrAn7JKnbQG/uEtLMkBgFF2Fuihg="; pin-sha256="yz9Exfr7nuNjI2KbGJUzBjJ+jLLBlXm4jMjVcxT9jsw="; pin-sha256="3sWAZ33ibdUXCDLJsVsMf/yCP5WduqMI9lVcNo1vvd0=";  max-age=2592000;'</span>;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">add_header</span>               Cache-Control <span class="literal">no</span>-cache;</span><br><span class="line">        <span class="attribute">add_header</span>               X-Via AQ;</span><br><span class="line">        <span class="attribute">add_header</span>               X-XSS-Protection <span class="string">"1; mode=block"</span>;</span><br><span class="line">        <span class="attribute">add_header</span>               X-Powered-By eiblog/<span class="number">1</span>.<span class="number">3</span>.<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">proxy_ignore_headers</span>     Set-Cookie;</span><br><span class="line">        <span class="attribute">proxy_hide_header</span>        Vary;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">proxy_set_header</span>         Connection       <span class="string">""</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span>         Host             razeen.me;</span><br><span class="line">        <span class="attribute">proxy_set_header</span>         X-Real_IP        <span class="variable">$remote_addr</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span>         X-Forwarded-For  <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">proxy_pass</span>               http://127.0.0.1:9000;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">server_name</span>                  www.razeen.me razeen.me blog.netcj.com;</span><br><span class="line">    <span class="attribute">server_tokens</span>                <span class="literal">off</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">access_log</span>                   /dev/null;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">if</span> (<span class="variable">$request_method</span> !<span class="regexp">~ ^(GET|HEAD|POST|OPTIONS)$</span> ) &#123;</span><br><span class="line">        <span class="attribute">return</span>                   <span class="number">444</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># letsencrypt file verify</span></span><br><span class="line">    <span class="attribute">location</span><span class="regexp"> ^~</span> /.well-known/acme-challenge/ &#123;</span><br><span class="line">        <span class="attribute">alias</span>                    /www/blog/challenges/;</span><br><span class="line">        <span class="attribute">try_files</span>                <span class="variable">$uri</span> =<span class="number">404</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">location</span> / &#123;</span><br><span class="line">        <span class="attribute">rewrite</span>                 <span class="regexp"> ^/(.*)$</span> https://razeen.me/<span class="variable">$1</span> <span class="literal">permanent</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p><a href="https://myssl.com/blog.netcj.com?domain=blog.netcj.com&amp;status=q" target="_blank" rel="noopener">MySSL.com</a>检测A+，整体配置过关。</p><p><img data-src="https://st.razeen.cn/img/image/https/Jietu20180416-014629.png" alt="。"></p><p>再用工具测一下了.</p><p>工具：<a href="https://testssl.sh/" target="_blank" rel="noopener">testssl</a></p><p>安装与测试：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> --depth 1 https://github.com/drwetter/testssl.sh.git</span><br><span class="line"><span class="built_in">cd</span> testssl.sh</span><br><span class="line">./testssl.sh -p https://blog.netcj.com</span><br></pre></td></tr></table></figure><p>结果：</p><p><img data-src="https://st.razeen.cn/img/image/https/Jietu20180416-014706.png" alt></p><p>嗯，到这里就我的博客就支持最新的TLS1.3拉~。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://imququ.com/post/my-nginx-conf.html" target="_blank" rel="noopener">本博客 Nginx 配置之完整篇</a></li><li><a href="https://www.bilimoe.com/draft-22/" target="_blank" rel="noopener">TLS1.3 更新 Draft-26</a></li></ul>]]></content>
      <categories>
        <category>PKI/CA与数字证书</category>
        <category>HTTPS</category>
      </categories>
      <tags>
        <tag>tls1.3</tag>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>Go学习笔记(七) | 理解OAuth 2.0并实现一个客户端</title>
    <url>//post/oauth2-protocol-details.html</url>
    <content><![CDATA[<p>OAuth 2.0是一个关于授权的开放网络标准，主要致力于简化客户端人员开发，同时为Web应用程序、桌面应用程序、移动电话和物联网设备提供特定的授权规范。他的官网在<a href="https://oauth.net/2/" target="_blank" rel="noopener">这里</a>。在<a href="https://tools.ietf.org/html/rfc6749" target="_blank" rel="noopener">RFC6749</a>中有明确协议规范。</p><p>简单来说，我们平时使用的很多第三方登录并获取头像等信息就是用的OAuth 2.0。如我们用QQ登录一些论坛，用google账号登陆facebook，用github账号登陆gitlab等。如下图展示的就是利用QQ登录网易云音乐Web版，其中用到的就是OAuth 2.0。</p><a id="more"></a><p><img data-src="https://st.razeen.cn/img/blog/oauth2-01.png" alt></p><h3 id="理解OAuth-2-0"><a href="#理解OAuth-2-0" class="headerlink" title="理解OAuth 2.0"></a>理解OAuth 2.0</h3><p>在开始编程前，我们先要掌握OAuth 2.0认证的流程是什么样的，下面我们一起走进OAuth 2.0。</p><p><strong><em>下面的情景都以我用QQ登录网易云Web版为例子。</em></strong></p><h4 id="相关名词"><a href="#相关名词" class="headerlink" title="相关名词"></a>相关名词</h4><p>在理解OAuth 2.0前，我们先需要理解下面这几个名词。</p><ul><li><p><code>resource owner</code>： 资源所有者。也就是例子中的我(用户)。</p></li><li><p><code>resource server</code>： 资源服务器，即服务提供商存放用户资源的服务器。例子中就是QQ的资源服务器，存放了我的QQ昵称，QQ头像，性别等等信息。</p></li><li><p><code>client</code>： 客户端，需要得到资源的应用程序。例子中的网易云音乐Web版。</p></li><li><p><code>authorization server</code>：认证服务器，即服务提供商专门用来处理认证的服务器。例子中QQ提供的认证服务器(跳出来让我们扫码登录QQ的这个服务)。</p></li><li><p><code>user-agent</code>：用户代理。我们用来访问客户端的程序，如这里就是浏览器。</p></li></ul><p>总体说来，这种登录流程大概就是这样：</p><p>我<code>(resource owner)</code>需要用QQ<code>(resource server)</code> 在浏览器<code>(user-agent)</code>登录网易云音乐<code>(client)</code>，我们先登录QQ<code>(authorization server)</code>，授权给网易云。然后网易云才能拿着这个授权信息去QQ资源服务器<code>(resource server)</code>获取到我的头像/昵称/性别等信息。</p><p>具体流程我们继续往下看。</p><h4 id="协议流程"><a href="#协议流程" class="headerlink" title="协议流程"></a>协议流程</h4><p>下图来自<a href="https://tools.ietf.org/html/rfc6749" target="_blank" rel="noopener">RFC6749</a>。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+--------+                               +---------------+</span><br><span class="line">|        |--(A)- Authorization Request -&gt;|   Resource    |</span><br><span class="line">|        |                               |     Owner     |</span><br><span class="line">|        |&lt;-(B)-- Authorization Grant ---|               |</span><br><span class="line">|        |                               +---------------+</span><br><span class="line">|        |</span><br><span class="line">|        |                               +---------------+</span><br><span class="line">|        |--(C)-- Authorization Grant --&gt;| Authorization |</span><br><span class="line">| Client |                               |     Server    |</span><br><span class="line">|        |&lt;-(D)----- Access Token -------|               |</span><br><span class="line">|        |                               +---------------+</span><br><span class="line">|        |</span><br><span class="line">|        |                               +---------------+</span><br><span class="line">|        |--(E)----- Access Token ------&gt;|    Resource   |</span><br><span class="line">|        |                               |     Server    |</span><br><span class="line">|        |&lt;-(F)--- Protected Resource ---|               |</span><br><span class="line">+--------+                               +---------------+</span><br><span class="line"></span><br><span class="line">                Figure 1: Abstract Protocol Flow</span><br></pre></td></tr></table></figure><ul><li><p>(A) 客户端请求<code>resource owner</code>授权；</p><p>这种授权可以是直接向<code>resource owner</code>请求，也可以通过<code>authorization server</code>间接请求。例子中，就是跳转到QQ的<code>authorization server</code>，让用户登录QQ。</p></li><li><p>(B) 用户同意给予授权；</p><p>例子中，用户点击同意，重定向回网易云音乐，这是一种授权模式。在RFC中规定了4中授权模式，具体采用哪一种取决于<code>authorization server</code>，下一小节具体介绍。</p></li><li><p>(C) 客户端拿着上一步的授权，向<code>authorization server</code>申请令牌(access_token)；</p></li><li><p>(D) <code>authorization server</code>确认授权无误后，发放令牌(access_token)；</p></li><li><p>(E) 客户端拿着令牌（access_token）到<code>resource server</code>去获取资源;</p><p>例子中，获取QQ头像，昵称等。</p></li><li><p>(F) <code>resource server</code>确认无误，同意向客户端下发受保护的资源。</p></li></ul><p>下面详细说到其中四种授权模式。</p><h4 id="授权模式"><a href="#授权模式" class="headerlink" title="授权模式"></a>授权模式</h4><p>客户端要得到令牌(access_token), 必须需要得到用户的授权，在OAuth 2.0 中定义了四种授权模式：</p><ul><li>授权码模式 (Authorization Code)</li><li>简化模式 (Implicit)</li><li>密码模式 (Resource Owner Password Credentials)</li><li>客户端模式 (Client Credentials)</li></ul><p>每种模式的使用场景与流程都有一定的差别。</p><h5 id="授权码模式-Authorization-Code"><a href="#授权码模式-Authorization-Code" class="headerlink" title="授权码模式 (Authorization Code)"></a>授权码模式 (Authorization Code)</h5><p>授权码模式的授权流程是基于重定向。我们例子中的用QQ登录网易云就是这种模式，流程图如下(来自RFC6749)：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> +----------+</span><br><span class="line">  | Resource |</span><br><span class="line">  |   Owner  |</span><br><span class="line">  |          |</span><br><span class="line">  +----------+</span><br><span class="line">       ^</span><br><span class="line">       |</span><br><span class="line">      (B)</span><br><span class="line">  +----|-----+          Client Identifier      +---------------+</span><br><span class="line">  |         -+----(A)-- &amp; Redirection URI ----&gt;|               |</span><br><span class="line">  |  User-   |                                 | Authorization |</span><br><span class="line">  |  Agent  -+----(B)-- User authenticates ---&gt;|     Server    |</span><br><span class="line">  |          |                                 |               |</span><br><span class="line">  |         -+----(C)-- Authorization Code ---&lt;|               |</span><br><span class="line">  +-|----|---+                                 +---------------+</span><br><span class="line">    |    |                                         ^      v</span><br><span class="line">   (A)  (C)                                        |      |</span><br><span class="line">    |    |                                         |      |</span><br><span class="line">    ^    v                                         |      |</span><br><span class="line">  +---------+                                      |      |</span><br><span class="line">  |         |&gt;---(D)-- Authorization Code ---------&apos;      |</span><br><span class="line">  |  Client |          &amp; Redirection URI                  |</span><br><span class="line">  |         |                                             |</span><br><span class="line">  |         |&lt;---(E)----- Access Token -------------------&apos;</span><br><span class="line">  +---------+       (w/ Optional Refresh Token)</span><br><span class="line"></span><br><span class="line">Note: The lines illustrating steps (A), (B), and (C) are broken into</span><br><span class="line">two parts as they pass through the user-agent.</span><br><span class="line"></span><br><span class="line">                  Figure 3: Authorization Code Flow</span><br></pre></td></tr></table></figure><ul><li>(A) 用户访问客户端，客户端将用户重定向到认证服务器；</li><li>(B) 用户选择是否授权；</li><li>(C) 如果用户同意授权，认证服务器重定向到客户端事先指定的地址，而且带上授权码(code)；</li><li>(D) 客户端收到授权码，带着前面的重定向地址，向认证服务器申请访问令牌；</li><li>(E) 认证服务器核对授权码与重定向地址，确认后向客户端发送访问令牌和更新令牌(可选)。</li></ul><p>1）在A中，客户端申请授权，重定向到认证服务器的URI中需要包含这些参数：</p><table><thead><tr><th>参数名称</th><th>参数含义</th><th>是否必须</th></tr></thead><tbody><tr><td>response_type</td><td>授权类型，此处的值为<code>code</code></td><td>必须</td></tr><tr><td>client_id</td><td>客户端ID，客户端到资源服务器注册的ID</td><td>必须</td></tr><tr><td>redirect_uri</td><td>重定向URI</td><td>可选</td></tr><tr><td>scope</td><td>申请的权限范围，多个逗号隔开</td><td>可选</td></tr><tr><td>state</td><td>客户端的当前状态，可以指定任意值，认证服务器会原封不动的返回这个值</td><td>推荐</td></tr></tbody></table><p>RFC6749中例子如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">GET /authorize?response_type=code&amp;client_id=s6BhdRkqt3&amp;state=xyz</span><br><span class="line">     &amp;redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb HTTP/1.1</span><br><span class="line"> Host: server.example.com</span><br></pre></td></tr></table></figure><p>我们在用QQ登录网易云音乐时实际的地址如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">https://graph.qq.com/oauth2.0/show?<span class="built_in">which</span>=Login</span><br><span class="line">		&amp;display=pc</span><br><span class="line">		&amp;client_id=100495085</span><br><span class="line">		&amp;response_type=code</span><br><span class="line">		&amp;redirect_uri=https://music.163.com/back/qq</span><br><span class="line">		&amp;forcelogin=<span class="literal">true</span></span><br><span class="line">		&amp;state=ichQQlAgNi</span><br><span class="line">		&amp;checkToken=sretfyguihojpr</span><br></pre></td></tr></table></figure><p>我们看到参数基本一致，至于还多几个，有什么用这里就没有去深究了。</p><p>2）在C中，认证服务器返回的URI中，需要包含下面这些参数：</p><table><thead><tr><th>参数名称</th><th>参数含义</th><th>是否必须</th></tr></thead><tbody><tr><td>code</td><td>授权码。认证服务器返回的授权码，生命周期不超过10分钟，而且要求只能使用一次，和A中的<code>client_id</code>,<code>redirect_uri</code>绑定。</td><td>必须</td></tr><tr><td>state</td><td>如果A中请求包含这个参数，资源服务器原封不动的返回。</td><td>可选</td></tr></tbody></table><p>如：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 302 Found</span><br><span class="line">Location: https://client.example.com/cb?code=SplxlOBeZQQYbYS6WxSbIA</span><br><span class="line">          &amp;state=xyz</span><br></pre></td></tr></table></figure><p>3) 在D中客户端向认证服务器申请令牌(access_token)时，需要包含下面这些参数。</p><table><thead><tr><th>参名称</th><th>参数含义</th><th>是否必须</th></tr></thead><tbody><tr><td>grant_type</td><td>授权模式，此处为<code>authorization_code</code>。</td><td>必须</td></tr><tr><td>code</td><td>授权码，C中获取的<code>code</code>。</td><td>必须</td></tr><tr><td>redirect_uri</td><td>重定向URI，需要和A中一致。</td><td>必须</td></tr><tr><td>client_id</td><td>客户端ID，与A中一致。</td><td>必须</td></tr></tbody></table><p>如：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">POST /token HTTP/1.1</span><br><span class="line">Host: server.example.com</span><br><span class="line">Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line"></span><br><span class="line">grant_type=authorization_code&amp;code=SplxlOBeZQQYbYS6WxSbIA</span><br><span class="line">&amp;redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb</span><br></pre></td></tr></table></figure><p>4) 在E中，认证服务器返回的信息中，包含下面参数：</p><table><thead><tr><th>参数名称</th><th>参数含义</th><th>是否必须</th></tr></thead><tbody><tr><td>access_token</td><td>访问令牌</td><td>必须</td></tr><tr><td>token_type</td><td>令牌类型，大小写不敏感。例如 Bearer，MAC。</td><td>必须</td></tr><tr><td>expires_in</td><td>过期时间(s)， 如果不设置也要通过其他方法设置一个。</td><td>推荐</td></tr><tr><td>refresh_token</td><td>更新令牌的token。当令牌过期的时候，可用通过该值刷新token。</td><td>可选</td></tr><tr><td>scope</td><td>权限范围，如果与客户端申请范围一致，可省略。</td><td>可选</td></tr></tbody></table><p>如：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Content-Type: application/json;charset=UTF-8</span><br><span class="line">Cache-Control: no-store</span><br><span class="line">Pragma: no-cache</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"access_token"</span>:<span class="string">"2YotnFZFEjr1zCsicMWpAA"</span>,</span><br><span class="line">  <span class="string">"token_type"</span>:<span class="string">"example"</span>,</span><br><span class="line">  <span class="string">"expires_in"</span>:3600,</span><br><span class="line">  <span class="string">"refresh_token"</span>:<span class="string">"tGzv3JOkF0XG5Qx2TlKWIA"</span>,</span><br><span class="line">  <span class="string">"example_parameter"</span>:<span class="string">"example_value"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5) 如果我们的令牌过期了，需要更新，这里就需要使用<code>refresh_token</code>获取一个新令牌了。此时发起HTTP请求需要的参数有：</p><table><thead><tr><th>参数名称</th><th>参数含义</th><th>是否必须</th></tr></thead><tbody><tr><td>grant_type</td><td>授权类型，此处是<code>refresh_token</code></td><td>必须</td></tr><tr><td>refresh_token</td><td>更新令牌的token。</td><td>必须</td></tr><tr><td>scope</td><td>权限范围。</td><td>可选</td></tr></tbody></table><p>如：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">POST /token HTTP/1.1</span><br><span class="line">Host: server.example.com</span><br><span class="line">Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line"></span><br><span class="line">grant_type=refresh_token&amp;refresh_token=tGzv3JOkF0XG5Qx2TlKWIA</span><br></pre></td></tr></table></figure><p>这就是授权码模式，应该也是我们平常见的较多的模式了。</p><h5 id="简化模式-Implicit"><a href="#简化模式-Implicit" class="headerlink" title="简化模式 (Implicit)"></a>简化模式 (Implicit)</h5><p>简化模式，相当于授权码模式中，C步骤不再通过客户端，直接在浏览器<code>(user-agent)</code>中向认证服务器申请令牌，认证服务器不再返回授权码，所有步骤都在浏览器中完成，最后资源服务器将令牌放在<code>Fragment</code>中，浏览器从中将令牌提取，发送给客户端。</p><p>所以这个令牌对访问者时可见的，而且客户端不需要认证。详细流程如下。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+----------+</span><br><span class="line">| Resource |</span><br><span class="line">|  Owner   |</span><br><span class="line">|          |</span><br><span class="line">+----------+</span><br><span class="line">     ^</span><br><span class="line">     |</span><br><span class="line">    (B)</span><br><span class="line">+----|-----+          Client Identifier     +---------------+</span><br><span class="line">|         -+----(A)-- &amp; Redirection URI ---&gt;|               |</span><br><span class="line">|  User-   |                                | Authorization |</span><br><span class="line">|  Agent  -|----(B)-- User authenticates --&gt;|     Server    |</span><br><span class="line">|          |                                |               |</span><br><span class="line">|          |&lt;---(C)--- Redirection URI ----&lt;|               |</span><br><span class="line">|          |          with Access Token     +---------------+</span><br><span class="line">|          |            in Fragment</span><br><span class="line">|          |                                +---------------+</span><br><span class="line">|          |----(D)--- Redirection URI ----&gt;|   Web-Hosted  |</span><br><span class="line">|          |          without Fragment      |     Client    |</span><br><span class="line">|          |                                |    Resource   |</span><br><span class="line">|     (F)  |&lt;---(E)------- Script ---------&lt;|               |</span><br><span class="line">|          |                                +---------------+</span><br><span class="line">+-|--------+</span><br><span class="line">  |    |</span><br><span class="line"> (A)  (G) Access Token</span><br><span class="line">  |    |</span><br><span class="line">  ^    v</span><br><span class="line">+---------+</span><br><span class="line">|         |</span><br><span class="line">|  Client |</span><br><span class="line">|         |</span><br><span class="line">+---------+</span><br></pre></td></tr></table></figure><ul><li>(A) 客户端将用户导向认证服务器， 携带客户端ID及重定向URI；</li><li>(B) 用户是否授权；</li><li>(C) 用户同意授权后，认证服务器重定向到A中指定的URI，并且在URI的<code>Fragment</code>中包含了访问令牌；</li><li>(D) 浏览器向资源服务器发出请求，该请求中不包含C中的<code>Fragment</code>值；</li><li>(E) 资源服务器返回一个网页，其中包含了可以提取C中<code>Fragment</code>里面访问令牌的脚本；</li><li>(F) 浏览器执行E中获得的脚本，提取令牌；</li><li>(G) 浏览器将令牌发送给客户端。</li></ul><p>1）在A步骤中，客户端发送请求，需要包含这些参数：</p><table><thead><tr><th>参数名称</th><th>参数含义</th><th>是否必须</th></tr></thead><tbody><tr><td>response_type</td><td>授权类型，此处值为<code>token</code>。</td><td>必须</td></tr><tr><td>client_id</td><td>客户端的ID。</td><td>必须</td></tr><tr><td>redirect_uri</td><td>重定向的URI。</td><td>可选</td></tr><tr><td>scope</td><td>权限范围。</td><td>可选</td></tr><tr><td>state</td><td>客户端的当前状态。指定后服务器会原封不动返回。</td><td>推荐</td></tr></tbody></table><p>如：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">GET /authorize?response_type=token&amp;client_id=s6BhdRkqt3&amp;state=xyz</span><br><span class="line">    &amp;redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb HTTP/1.1</span><br><span class="line">Host: server.example.com</span><br></pre></td></tr></table></figure><p>2) 在C中，认证服务器返回的URI中，参数主要有：</p><table><thead><tr><th>参数名称</th><th>参数含义</th><th>是否必须</th></tr></thead><tbody><tr><td>access_token</td><td>访问令牌。</td><td>必须</td></tr><tr><td>token_type</td><td>令牌类型。</td><td>必须</td></tr><tr><td>expires_in</td><td>过期时间。</td><td>推荐</td></tr><tr><td>scope</td><td>权限范围。</td><td>可选</td></tr><tr><td>state</td><td>客户端访问时如果指定了，原封不动返回。</td><td>可选</td></tr></tbody></table><p>如：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 302 Found</span><br><span class="line">Location: http://example.com/cb<span class="comment">#access_token=2YotnFZFEjr1zCsicMWpAA</span></span><br><span class="line">          &amp;state=xyz&amp;token_type=example&amp;expires_in=3600</span><br></pre></td></tr></table></figure><p>我们可以看到C中返回的是一个重定向，而重定向的这个网址的<code>Fragment</code>部分包含了令牌。</p><p>D步骤中就是访问这个重定向指定的URI，而且不带<code>Fragment</code>部分，服务器会返回从<code>Fragment</code>中提取令牌的脚本，最后浏览器运行脚本获取到令牌发送给客户端。</p><h5 id="密码模式-Resource-Owner-Password-Credentials"><a href="#密码模式-Resource-Owner-Password-Credentials" class="headerlink" title="密码模式 (Resource Owner Password Credentials)"></a>密码模式 (Resource Owner Password Credentials)</h5><p>密码模式就是用户直接将用户名密码提供给客户端，客户端使用这些信息到认证服务器请求授权。具体流程如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+----------+</span><br><span class="line">| Resource |</span><br><span class="line">|  Owner   |</span><br><span class="line">|          |</span><br><span class="line">+----------+</span><br><span class="line">     v</span><br><span class="line">     |    Resource Owner</span><br><span class="line">    (A) Password Credentials</span><br><span class="line">     |</span><br><span class="line">     v</span><br><span class="line">+---------+                                  +---------------+</span><br><span class="line">|         |&gt;--(B)---- Resource Owner -------&gt;|               |</span><br><span class="line">|         |         Password Credentials     | Authorization |</span><br><span class="line">| Client  |                                  |     Server    |</span><br><span class="line">|         |&lt;--(C)---- Access Token ---------&lt;|               |</span><br><span class="line">|         |    (w/ Optional Refresh Token)   |               |</span><br><span class="line">+---------+                                  +---------------+</span><br><span class="line"></span><br><span class="line">       Figure 5: Resource Owner Password Credentials Flow</span><br></pre></td></tr></table></figure><ul><li>(A) 资源所有者提供用户名密码给客户端；</li><li>(B) 客户端拿着用户名密码去认证服务器请求令牌；</li><li>(C) 认证服务器确认后，返回令牌；</li></ul><p>1) 在B中客户端发送的请求中，需要包含这些参数：</p><table><thead><tr><th>参数名称</th><th>参数含义</th><th>是否必须</th></tr></thead><tbody><tr><td>grant_type</td><td>授权类型，此处值为<code>password</code>。</td><td>必须</td></tr><tr><td>username</td><td>用户名。</td><td>必须</td></tr><tr><td>password</td><td>用户的密码。</td><td>必须</td></tr><tr><td>scope</td><td>权限范围。</td><td>可选</td></tr></tbody></table><p>如：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">POST /token HTTP/1.1</span><br><span class="line">Host: server.example.com</span><br><span class="line">Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line"></span><br><span class="line">grant_type=password&amp;username=johndoe&amp;password=A3ddj3w</span><br></pre></td></tr></table></figure><p>3) 在C中，认证服务器返回访问令牌。如：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Content-Type: application/json;charset=UTF-8</span><br><span class="line">Cache-Control: no-store</span><br><span class="line">Pragma: no-cache</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"access_token"</span>:<span class="string">"2YotnFZFEjr1zCsicMWpAA"</span>,</span><br><span class="line">  <span class="string">"token_type"</span>:<span class="string">"example"</span>,</span><br><span class="line">  <span class="string">"expires_in"</span>:3600,</span><br><span class="line">  <span class="string">"refresh_token"</span>:<span class="string">"tGzv3JOkF0XG5Qx2TlKWIA"</span>,</span><br><span class="line">  <span class="string">"example_parameter"</span>:<span class="string">"example_value"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="客户端模式-Client-Credentials"><a href="#客户端模式-Client-Credentials" class="headerlink" title="客户端模式 (Client Credentials)"></a>客户端模式 (Client Credentials)</h5><p>客户端模式，其实就是客户端直接向认证服务器请求令牌。而用户直接在客户端注册即可，一般用于后端 API 的相关操作。其流程如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">+---------+                                  +---------------+</span><br><span class="line">|         |                                  |               |</span><br><span class="line">|         |&gt;--(A)- Client Authentication ---&gt;| Authorization |</span><br><span class="line">| Client  |                                  |     Server    |</span><br><span class="line">|         |&lt;--(B)---- Access Token ---------&lt;|               |</span><br><span class="line">|         |                                  |               |</span><br><span class="line">+---------+                                  +---------------+</span><br><span class="line"></span><br><span class="line">                Figure 6: Client Credentials Flow</span><br></pre></td></tr></table></figure><ul><li>(A) 客户端发起身份认证，请求访问令牌；</li><li>(B) 认证服务器确认无误，返回访问令牌。</li></ul><p>1) 在A中，客户端发起请求的参数有：</p><table><thead><tr><th>参数名称</th><th>参数含义</th><th>是否必须</th></tr></thead><tbody><tr><td>grant_type</td><td>授权类型，此处值为<code>client_credentials</code>。</td><td>必须</td></tr><tr><td>scope</td><td>权限范围。</td><td>可选</td></tr></tbody></table><p>如：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">POST /token HTTP/1.1</span><br><span class="line">Host: server.example.com</span><br><span class="line">Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line"></span><br><span class="line">grant_type=client_credentials</span><br></pre></td></tr></table></figure><p>2） 认证服务器认证后，发放访问令牌，如：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Content-Type: application/json;charset=UTF-8</span><br><span class="line">Cache-Control: no-store</span><br><span class="line">Pragma: no-cache</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"access_token"</span>:<span class="string">"2YotnFZFEjr1zCsicMWpAA"</span>,</span><br><span class="line">  <span class="string">"token_type"</span>:<span class="string">"example"</span>,</span><br><span class="line">  <span class="string">"expires_in"</span>:3600,</span><br><span class="line">  <span class="string">"example_parameter"</span>:<span class="string">"example_value"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现OAuth-2-0"><a href="#实现OAuth-2-0" class="headerlink" title="实现OAuth 2.0"></a>实现OAuth 2.0</h3><p>上面我们一起了解了OAuth 2.0的流程，现在我们开始实现OAuth 2.0。</p><p>首先，我需要一个使用场景，大概是这样的。</p><blockquote><p>我有一个需要登录的应用（web app)。<br>用户可以选择使用github登录。<br>登录后，显示一个简单的欢迎页面。</p></blockquote><p>有了这个场景后，我们开始设计（这里我们实现的是第一种授权码模式）。</p><h4 id="登录页面"><a href="#登录页面" class="headerlink" title="登录页面"></a>登录页面</h4><p>在这里，我们充当的角色就是<code>client</code>,我们需要一个简单的页面，让用户选择使用<code>github</code>登录。</p><p>这是一个简单的html页面，<code>public/index.html</code>页面。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"https://github.com/login/oauth/authorize?client_id=89ac6f58f15f658d8dd5&amp;redirect_uri=http://localhost:8080/oauth/redirect"</span>&gt;</span></span><br><span class="line">    Login with github</span><br><span class="line">  <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>也就是当用户点击<code>Login with github</code>会访问</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">https://github.com/login/oauth/authorize?</span><br><span class="line">		client_id=89ac6f58f15f658d8dd5</span><br><span class="line">		&amp;redirect_uri=http://localhost:8080/oauth/redirect</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li><p><code>https://github.com/login/oauth/authorize</code> 是GitHub的OAuth网关地址。</p></li><li><p><code>client_id=89ac6f58f15f658d8dd5</code> 这个是我申请的客户端ID，</p><p>需要到<a href="https://github.com/settings/applications/new" target="_blank" rel="noopener">https://github.com/settings/applications/new</a>注册。</p><p>注册过程很简单，但要注意，最后一栏<code>Authorization callback URL</code>是和下面<code>redirect_uri</code>一致。</p><p>如：</p><p><img data-src="https://st.razeen.cn/img/blog/Jietu20190208-230400.png" alt></p><p>成功后你会获的<code>Client ID</code>与<code>Client Secret</code>, 前者就是这里的<code>client_id</code>，两者在后面的编码中需要用到。</p></li><li><p><code>redirect_uri=http://localhost:8080/oauth/redirect</code> 当用户确认，获取权限后重定向到的该地址。</p></li></ul><p>然后我们写个<code>mian.go</code>, 启动一个简单的服务。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fs := http.FileServer(http.Dir(<span class="string">"public"</span>))</span><br><span class="line">	http.Handle(<span class="string">"/"</span>, fs)</span><br><span class="line"></span><br><span class="line">	http.ListenAndServe(<span class="string">":8080"</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写到这里，我们代码已经能跑起了，如果你点击<code>Login with github</code>我们会看到如下的授权页面。</p><p><img data-src="https://st.razeen.cn/img/blog/Jietu20190208-232606.png" alt></p><p>当我们确定过后，会重定向到我们指定的地址，而且带上<code>code</code>,如：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http://localhost:8080/oauth/redirect?code=260f17a7308f2c566725</span><br></pre></td></tr></table></figure><p>此时我们需要做的是，拿着该code去请求访问令牌(access_token)，对应授权码模式中的D步骤。</p><h4 id="重定向路由"><a href="#重定向路由" class="headerlink" title="重定向路由"></a>重定向路由</h4><p>现在我们有<code>code</code>了，我们需要去请求令牌。接下来我们就需要向<code>https://github.com/login/oauth/access_token</code>发送POST请求获取访问令牌(access_token)。</p><blockquote><p>关于更多GitHub重定向URI的信息你可以看<a href="https://developer.github.com/apps/building-oauth-apps/authorizing-oauth-apps/#2-users-are-redirected-back-to-your-site-by-github" target="_blank" rel="noopener">这里</a>。</p></blockquote><p>现在，让我们将<code>/oauth/redirect</code>路由补全，在该步骤中请求访问令牌(access_token)。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"encoding/json"</span></span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"log"</span></span><br><span class="line">	<span class="string">"net/http"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 你在注册时得到的</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	clientID     = <span class="string">"你的客户端ID"</span></span><br><span class="line">	clientSecret = <span class="string">"你的客户端密钥"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> httpClient = http.Client&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> OAuthAccessResponse <span class="keyword">struct</span> &#123;</span><br><span class="line">	AccessToken <span class="keyword">string</span> <span class="string">`json:"access_token"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fs := http.FileServer(http.Dir(<span class="string">"public"</span>))</span><br><span class="line">	http.Handle(<span class="string">"/"</span>, fs)</span><br><span class="line">	http.HandleFunc(<span class="string">"/oauth/redirect"</span>, HandleOAuthRedirect)</span><br><span class="line"></span><br><span class="line">	http.ListenAndServe(<span class="string">":8080"</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// HandleOAuthRedirect doc</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HandleOAuthRedirect</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 首先，我们从URI中解析出code参数</span></span><br><span class="line">	<span class="comment">// 如: http://localhost:8080/oauth/redirect?code=260f17a7308f2c566725</span></span><br><span class="line">	err := r.ParseForm()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Printf(<span class="string">"could not parse query: %v"</span>, err)</span><br><span class="line">		w.WriteHeader(http.StatusBadRequest)</span><br><span class="line">	&#125;</span><br><span class="line">	code := r.FormValue(<span class="string">"code"</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 接下来，我们通过 clientID,clientSecret,code 获取授权密钥</span></span><br><span class="line">	<span class="comment">// 前者是我们在注册时得到的，后者是用户确认后，重定向到该路由，从中获取到的。</span></span><br><span class="line">	reqURL := fmt.Sprintf(<span class="string">"https://github.com/login/oauth/access_token?client_id=%s&amp;client_secret=%s&amp;code=%s"</span>,</span><br><span class="line">		clientID, clientSecret, code)</span><br><span class="line">	req, err := http.NewRequest(http.MethodPost, reqURL, <span class="literal">nil</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Printf(<span class="string">"could not create HTTP request: %v"</span>, err)</span><br><span class="line">		w.WriteHeader(http.StatusBadRequest)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 设置我们期待返回的格式为json</span></span><br><span class="line">	req.Header.Set(<span class="string">"accept"</span>, <span class="string">"application/json"</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 发送http请求</span></span><br><span class="line">	res, err := httpClient.Do(req)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Printf(<span class="string">"could not send HTTP request: %v"</span>, err)</span><br><span class="line">		w.WriteHeader(http.StatusInternalServerError)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> res.Body.Close()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 解析</span></span><br><span class="line">	<span class="keyword">var</span> t OAuthAccessResponse</span><br><span class="line">	<span class="keyword">if</span> err := json.NewDecoder(res.Body).Decode(&amp;t); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Printf(<span class="string">"could not parse JSON response: %v"</span>, err)</span><br><span class="line">		w.WriteHeader(http.StatusBadRequest)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 最后获取到access_token后，我们重定向到欢迎页面，也就是表示用户登录成功，同属获取一些用户的基本展示信息</span></span><br><span class="line">	w.Header().Set(<span class="string">"Location"</span>, <span class="string">"/welcome.html?access_token="</span>+t.AccessToken)</span><br><span class="line">	w.WriteHeader(http.StatusFound)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="欢迎页面"><a href="#欢迎页面" class="headerlink" title="欢迎页面"></a>欢迎页面</h4><p>上面我们拿到了访问令牌，同时，我们重定向到了欢迎页面。接下来，我们就在欢迎页中获取用户的GitHub名称作为展示。</p><p>添加<code>public/welcome.html</code>页面。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">title</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line">	// 获取access_token</span><br><span class="line">	const query = window.location.search.substring(1)</span><br><span class="line">	const token = query.split('access_token=')[1]</span><br><span class="line"></span><br><span class="line">	// 访问资源服务器地址，获取相关资源</span><br><span class="line">	fetch('https://api.github.com/user', &#123;</span><br><span class="line">			headers: &#123;</span><br><span class="line">                // 将token放在Header中</span><br><span class="line">				Authorization: 'token ' + token</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;)</span><br><span class="line">		// 解析返回的JSON</span><br><span class="line">		.then(res =&gt; res.json())</span><br><span class="line">		.then(res =&gt; &#123;</span><br><span class="line">            // 这里我们能得到很多信息</span><br><span class="line">			// 具体看这里 https://developer.github.com/v3/users/#get-the-authenticated-user</span><br><span class="line">			// 这里我们就只展示一下用户名了</span><br><span class="line">			const nameNode = document.createTextNode(`Welcome, $&#123;res.name&#125;`)</span><br><span class="line">			document.body.appendChild(nameNode)</span><br><span class="line">		&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>到这里，我们再次运行程序，点击<code>Login with github</code>，同意后我们可以看到类似<code>Welcome, Razeen</code>的信息，此时我们已经完成整个OAuth 2.0的流程了。</p><blockquote><p>获得授权之后，我们能访问的API不仅仅有这些，更多的请看<a href="https://developer.github.com/v3/" target="_blank" rel="noopener">这里</a>。</p></blockquote><p><em>源码在<a href="https://github.com/razeencheng/demo-go/tree/master/oauth2" target="_blank" rel="noopener">这里</a>。</em></p><h3 id="关于安全"><a href="#关于安全" class="headerlink" title="关于安全"></a>关于安全</h3><ol><li><p>这里我们将访问令牌直接放在了URI中，这么做其实是不安全的。更好的做法是我们创建一个会话session，将cooike发送给用户即可。</p></li><li><p>在前面OAuth 2.0的解释中，我们知道在请求权限的过程中，我们可以加上<code>state</code>字段，如</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">https://github.com/login/oauth/authorize？</span><br><span class="line">		client_id=89ac6f58f15f658d8dd5</span><br><span class="line">		&amp;redirect_uri=http://localhost:8080/oauth/redirect</span><br><span class="line">		&amp;state=xxxxx</span><br></pre></td></tr></table></figure><p>而服务器会原封不动的返回该state。这样我们可以将该字段设置一些随机值，如果资源服务器返回的<code>state</code>值与我们设置的不同，我们认为该请求不是来自正确的资源服务器，应该拒绝。</p></li></ol><p><strong>参考</strong></p><ul><li><p><a href="https://tools.ietf.org/html/rfc6749" target="_blank" rel="noopener">FRC6749</a></p></li><li><p><a href="https://www.sohamkamani.com/blog/golang/2018-06-24-oauth-with-golang/" target="_blank" rel="noopener">Implementing OAuth 2.0 with Go(Golang)</a></p></li><li><p><a href="https://deepzz.com/post/what-is-oauth2-protocol.html" target="_blank" rel="noopener">10 分钟理解什么是 OAuth 2.0 协议</a></p></li><li><p><a href="http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html" target="_blank" rel="noopener">理解OAuth 2.0</a></p></li></ul>]]></content>
      <categories>
        <category>Go学习笔记</category>
        <category>Go实战</category>
      </categories>
      <tags>
        <tag>golang</tag>
        <tag>oauth</tag>
      </tags>
  </entry>
  <entry>
    <title>记一次 PostgreSQL LIKE 索引优化，联合字段 LIKE 查询优化。</title>
    <url>//post/pg-like-index-optimize.html</url>
    <content><![CDATA[<p>由于最近我司业务量上涨，数据量剧增，数据库查询速度明显变慢，单次查询居然达到1800ms以上，急需优化。待查阅一番后，我知道了LIKE查询正确的索引使用姿势，特别是一些符合字段索引。</p><a id="more"></a><p>模糊查询的使用场景实在太多了，正确使用索引实在是太重要了。或许一个关键的优化就能为你节省更多的资源，带来更好的用户体验。</p><p>少啰嗦，我们看实例。</p><p><em>由于未经我司同意，数据不能用真实了，下面数据是我盗来的😢</em></p><p>首先，我们这里有一张存了一百万条信息的<code>users</code>表。<br></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">                                    Table "public.users"</span><br><span class="line">Column      |            Type             |                     Modifiers</span><br><span class="line"><span class="comment">------------+-----------------------------+----------------------------------------------------</span></span><br><span class="line"> id         | integer                     | not null default nextval('users_id_seq'::regclass)</span><br><span class="line"> username   | character varying           |</span><br><span class="line"> first_name | character varying           |</span><br><span class="line"> last_name  | character varying           |</span><br></pre></td></tr></table></figure><p></p><h3 id="普通查询"><a href="#普通查询" class="headerlink" title="普通查询"></a>普通查询</h3><p>在不添加任何索引的情况下，我们查询一次。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">&gt; EXPLAIN ANALYSE SELECT COUNT(*) FROM users WHERE username ILIKE '%foo%';</span><br><span class="line">                                                  QUERY PLAN</span><br><span class="line"><span class="comment">--------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"> Aggregate  (cost=21927.24..21927.25 rows=1 width=0) (actual time=737.523..737.523 rows=1 loops=1)</span><br><span class="line">   -&gt;  Seq Scan on users  (cost=0.00..21927.00 rows=96 width=0) (actual time=737.520..737.520 rows=0 loops=1)</span><br><span class="line">         Filter: ((username)::text ~~* '%foo%'::text)</span><br><span class="line">         Rows Removed by Filter: 1000000</span><br><span class="line"> Planning time: 0.373 ms</span><br><span class="line"> Execution time: 737.593 ms</span><br><span class="line">(6 rows)</span><br><span class="line"></span><br><span class="line">Time: 738.404 ms</span><br></pre></td></tr></table></figure><p>结果，如大家所想一样，顺序扫描，很慢。</p><h3 id="btree-索引"><a href="#btree-索引" class="headerlink" title="btree 索引"></a>btree 索引</h3><p>很多童鞋会想到，那就加个索引呗。我们知道，pg里面一般默认都是btree索引，我们加一个试试。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">&gt; CREATE INDEX idx_users_username ON users (username);</span><br><span class="line">Time: 15987.751 ms</span><br></pre></td></tr></table></figure><p>查询一下：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">&gt; EXPLAIN ANALYSE SELECT COUNT(*) FROM users WHERE username ILIKE '%foo%';</span><br><span class="line"></span><br><span class="line">                                                  QUERY PLAN</span><br><span class="line"><span class="comment">--------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"> Aggregate  (cost=21927.24..21927.25 rows=1 width=0) (actual time=752.271..752.271 rows=1 loops=1)</span><br><span class="line">   -&gt;  Seq Scan on users  (cost=0.00..21927.00 rows=96 width=0) (actual time=752.268..752.268 rows=0 loops=1)</span><br><span class="line">         Filter: ((username)::text ~~* '%foo%'::text)</span><br><span class="line">         Rows Removed by Filter: 1000000</span><br><span class="line"> Planning time: 0.599 ms</span><br><span class="line"> Execution time: 752.318 ms</span><br><span class="line">(6 rows)</span><br><span class="line"></span><br><span class="line">Time: 753.251 ms</span><br></pre></td></tr></table></figure><p>emm, 好家伙，居然还是顺序扫描。 这是由于一般的索引只能优化 <code>LIKE foo%</code>这类的向后的模糊查询。所以btree索引这里也达不到优化的效果。</p><h3 id="gin-索引-amp-pg-trgm-模块"><a href="#gin-索引-amp-pg-trgm-模块" class="headerlink" title="gin 索引 &amp; pg_trgm 模块"></a>gin 索引 &amp; pg_trgm 模块</h3><blockquote><p>pg_trgm模块提供函数和操作符测定字母，数字，文本基于三元模型匹配的相似性， 还有支持快速搜索相似字符串的索引操作符类。</p></blockquote><blockquote><p>这里提到了一个三元模型，可能有童鞋不理解，其实很简单。打个比方<code>foo</code>的三元模型的集合为<code>{&quot; f&quot;,&quot; fo&quot;,&quot;foo&quot;,&quot;oo &quot;}</code>, <code>foo|bar</code>的三元模型的集合为<code>{&quot; f&quot;,&quot; fo&quot;,&quot;foo&quot;,&quot;oo &quot;,&quot; b&quot;,&quot; ba&quot;,&quot;bar&quot;,&quot;ar &quot;}</code>。也就是说将字符串拆解成三个字符一组，每个字符串被认为有两个空格前缀和一个空格后缀。</p></blockquote><p>Postgres使用trigram将字符串分解成更小的单元便于有效地索引它们。pg_trgm模块支持GIST或GIN索引，从9.1开始，这些索引支持LIKE/ILIKE查询。</p><p>要使用pg_trgm模块，首先要启用该扩展，然后使用<code>gin_trgm_ops</code>创建索引。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">&gt; CREATE EXTENSION pg_trgm;</span><br><span class="line">Time: 42.206 ms</span><br><span class="line"></span><br><span class="line">&gt; CREATE INDEX trgm_idx_users_username ON users USING gin (username gin_trgm_ops);</span><br><span class="line">Time: 7082.474 ms</span><br></pre></td></tr></table></figure><p>我们再次分析查询</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">&gt; EXPLAIN ANALYSE SELECT COUNT(*) FROM users WHERE username ILIKE '%foo%';</span><br><span class="line"></span><br><span class="line">                                                               QUERY PLAN</span><br><span class="line"><span class="comment">----------------------------------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"> Aggregate  (cost=369.12..369.13 rows=1 width=0) (actual time=0.030..0.030 rows=1 loops=1)</span><br><span class="line">   -&gt;  Bitmap Heap Scan on users  (cost=12.75..368.88 rows=96 width=0) (actual time=0.026..0.026 rows=0 loops=1)</span><br><span class="line">         Recheck Cond: ((username)::text ~~* '%foo%'::text)</span><br><span class="line">         -&gt;  Bitmap Index Scan on trgm_idx_users_username  (cost=0.00..12.72 rows=96 width=0) (actual time=0.024..0.024 rows=0 loops=1)</span><br><span class="line">               Index Cond: ((username)::text ~~* '%foo%'::text)</span><br><span class="line"> Planning time: 0.636 ms</span><br><span class="line"> Execution time: 0.095 ms</span><br><span class="line">(7 rows)</span><br><span class="line"></span><br><span class="line">Time: 2.333 ms</span><br></pre></td></tr></table></figure><p>哇，2.33ms!!!</p><p>从查询过程上看，索引已经起作用了。这将我们的查询直接提高了两个数量级，作用很大。我在我司使用该索引后，查询从1800ms提升到了10ms左右,也算是效果惊人了。</p><blockquote><p>这里出现了个”Bitmap Heap Scan”,这是什么呢？<br>pg里面常见到的对表扫描的计划有这四种：</p><ul><li>Seq Scan</li><li>Index Scan</li><li>Bitmap Heap Scan</li><li>Index Only Scan</li></ul><p>前面两个你也许一看就懂。<br>第一个无非是按照表的记录顺序从头到尾依次检索扫描，全表扫描，代价大；<br>第二个先扫描索引，从索引找到数据位置，再准备获取数据，索引扫描，快，I/O少；<br>第三个一次性将满足条件的索引项全部取出，并在内存中进行排序, 然后根据取出的索引项访问表数据。一般需要合并索引访问的结果子集时会用到这种方式。<br>第四个就是查询的字段直接就在索引中了，直接扫描索引即可。</p></blockquote><h3 id="联合字段LIKE查询"><a href="#联合字段LIKE查询" class="headerlink" title="联合字段LIKE查询"></a>联合字段LIKE查询</h3><p>有时候，我们可能需要联合多个字段来查询数据。如，我们需要搜索一位可能叫<code>John Do</code>的人,这时候就需要我们将<code>first_name</code>与<code>last_name</code>联合作为条件查询了。</p><p>一般我们首先想到的是，在<code>first_name</code>与<code>last_name</code>都加上索引。那么可行么？我们先试一下。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">&gt; CREATE INDEX trgm_idx_users_first ON users USING gin (first_name gin_trgm_ops);</span><br><span class="line">Time: 4577.637 ms</span><br><span class="line">&gt; CREATE INDEX trgm_idx_users_last ON users USING gin (last_name gin_trgm_ops);</span><br><span class="line">Time: 4770.507 ms</span><br></pre></td></tr></table></figure><p>查询</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">&gt; SELECT COUNT(*) FROM users WHERE first_name || ' ' || last_name ILIKE '%foo%'</span><br><span class="line"></span><br><span class="line">                                                    QUERY PLAN</span><br><span class="line"><span class="comment">-------------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"> Aggregate  (cost=27027.00..27027.01 rows=1 width=0) (actual time=1025.543..1025.544 rows=1 loops=1)</span><br><span class="line">   -&gt;  Seq Scan on users  (cost=0.00..26927.00 rows=40000 width=0) (actual time=1025.539..1025.539 rows=0 loops=1)</span><br><span class="line">         Filter: ((((first_name)::text || ' '::text) || (last_name)::text) ~~* '%foo%'::text)</span><br><span class="line">         Rows Removed by Filter: 1000000</span><br><span class="line"> Planning time: 0.273 ms</span><br><span class="line"> Execution time: 1025.591 ms</span><br><span class="line">(6 rows)</span><br><span class="line"></span><br><span class="line">Time: 1027.547 ms</span><br></pre></td></tr></table></figure><p>看来还是没有用到索引，由于查询的时候使用的是联合的字段，单独的索引并不起作用。那么我们可以考虑将字段联合起来，添加一个索引。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> index_users_full_name <span class="keyword">ON</span> <span class="keyword">users</span> <span class="keyword">using</span> gin ((first_name || <span class="string">' '</span> || last_name) gin_trgm_ops);</span><br></pre></td></tr></table></figure><p>我们再次尝试查询。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&gt; EXPLAIN ANALYSE SELECT COUNT(*) FROM users WHERE first_name || ' ' || last_name ILIKE '%foo%';</span><br><span class="line"></span><br><span class="line">                                                                QUERY PLAN</span><br><span class="line"><span class="comment">------------------------------------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"> Aggregate  (cost=10605.00..10605.01 rows=1 width=0) (actual time=0.020..0.020 rows=1 loops=1)</span><br><span class="line">   -&gt;  Bitmap Heap Scan on users  (cost=378.01..10505.00 rows=40000 width=0) (actual time=0.018..0.018 rows=0 loops=1)</span><br><span class="line">         Recheck Cond: ((((first_name)::text || ' '::text) || (last_name)::text) ~~* '%foo%'::text)</span><br><span class="line">         -&gt;  Bitmap Index Scan on index_users_full_name  (cost=0.00..368.01 rows=40000 width=0) (actual time=0.016..0.016 rows=0 loops=1)</span><br><span class="line">               Index Cond: ((((first_name)::text || ' '::text) || (last_name)::text) ~~* '%foo%'::text)</span><br><span class="line"> Planning time: 0.338 ms</span><br><span class="line"> Execution time: 0.080 ms</span><br><span class="line">(7 rows)</span><br><span class="line"></span><br><span class="line">Time: 0.975 ms</span><br></pre></td></tr></table></figure><p>喔😯，相当的快。使用了<code>Bitmap Index</code>扫描的，看来索引很有效。</p><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>勇敢上文，我们一起了解了一下pg里利用<code>pg_trgm</code>模块来建立索引优化模糊查询。其实pg里买还有更多好用实用的功能，期待与大家一起探索～。</p><p><strong>本文参考</strong></p><ul><li><p><a href="https://niallburkley.com/blog/index-columns-for-like-in-postgres/" target="_blank" rel="noopener">Index Columns for LIKE in PostgreSQL</a>.</p></li><li><p><a href="http://www.postgres.cn/docs/10/pgtrgm.html" target="_blank" rel="noopener">pg_trgm</a></p></li></ul>]]></content>
      <categories>
        <category>开发实战总结</category>
      </categories>
      <tags>
        <tag>postgres</tag>
        <tag>like</tag>
        <tag>index</tag>
      </tags>
  </entry>
  <entry>
    <title>日常 Postgres 数据库点滴记录</title>
    <url>//post/postgres-daily.html</url>
    <content><![CDATA[<p>Desc:Postgres数据库日常使用，插入更新，复制表，一些使用习惯。</p><p>由于经常接触数据库，但又停留在比较浅的层次，暂且没有时间也没必要去系统了解，这篇博客权当记录一些自己常用到的pg数据库语句，持续更新~</p><a id="more"></a><h3 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h3><h4 id="插入更新"><a href="#插入更新" class="headerlink" title="插入更新"></a>插入更新</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> the_table (<span class="keyword">id</span>, column_1, column_2) </span><br><span class="line"><span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="string">'A'</span>, <span class="string">'X'</span>), (<span class="number">2</span>, <span class="string">'B'</span>, <span class="string">'Y'</span>), (<span class="number">3</span>, <span class="string">'C'</span>, <span class="string">'Z'</span>)</span><br><span class="line"><span class="keyword">ON</span> CONFLICT (<span class="keyword">id</span>) <span class="keyword">DO</span> <span class="keyword">UPDATE</span> </span><br><span class="line">  <span class="keyword">SET</span> column_1 = excluded.column_1, </span><br><span class="line">  column_2 = excluded.column_2;</span><br></pre></td></tr></table></figure><h4 id="复制表"><a href="#复制表" class="headerlink" title="复制表"></a>复制表</h4><p>我们首先创建了一张表<code>user</code></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span>  <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>  <span class="string">"user"</span> (</span><br><span class="line">  <span class="keyword">id</span> <span class="built_in">SERIAL</span> PRIMARY <span class="keyword">KEY</span>,</span><br><span class="line">  <span class="keyword">name</span>  <span class="built_in">TEXT</span> <span class="keyword">UNIQUE</span>,</span><br><span class="line">  age <span class="built_in">INTEGER</span>,</span><br><span class="line">  sex <span class="built_in">BOOLEAN</span>,</span><br><span class="line">  create_at <span class="built_in">TIMESTAMP</span> <span class="keyword">DEFAULT</span>  <span class="keyword">CURRENT_TIMESTAMP</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>我们查看其<code>DDL</code></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="string">"user"</span></span><br><span class="line">(</span><br><span class="line">	<span class="keyword">id</span> <span class="built_in">serial</span> <span class="keyword">not</span> <span class="literal">null</span></span><br><span class="line">		<span class="keyword">constraint</span> user_pkey</span><br><span class="line">			primary <span class="keyword">key</span>,</span><br><span class="line">	<span class="keyword">name</span> <span class="built_in">text</span></span><br><span class="line">		<span class="keyword">constraint</span> user_name_key</span><br><span class="line">			<span class="keyword">unique</span>,</span><br><span class="line">	age <span class="built_in">integer</span>,</span><br><span class="line">	sex <span class="built_in">boolean</span>,</span><br><span class="line">	create_at <span class="built_in">timestamp</span> <span class="keyword">default</span> <span class="keyword">now</span>()</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>我们插入一些数据</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">"user"</span> (<span class="keyword">name</span>, age, sex) <span class="keyword">VALUES</span> (<span class="string">'xiaoming'</span>,<span class="number">12</span>,<span class="literal">TRUE</span>),(<span class="string">'xiaohua'</span>,<span class="number">18</span>,<span class="literal">FALSE</span> );</span><br></pre></td></tr></table></figure><p>我们利用<code>CREATE TABLE AS</code>复制。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> user2 <span class="keyword">AS</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="string">"user"</span>;</span><br></pre></td></tr></table></figure><p>查看表数据</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span>  * <span class="keyword">FROM</span> user2;</span><br><span class="line"><span class="comment">-- 1	xiaoming	12	true	2018-05-17 09:48:51.823616</span></span><br><span class="line"><span class="comment">-- 2	xiaohua		18	false	2018-05-17 09:48:51.823616</span></span><br></pre></td></tr></table></figure><p>查看表<code>DDL</code></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> user2</span><br><span class="line">(</span><br><span class="line">	<span class="keyword">id</span> <span class="built_in">integer</span>,</span><br><span class="line">	<span class="keyword">name</span> <span class="built_in">text</span>,</span><br><span class="line">	age <span class="built_in">integer</span>,</span><br><span class="line">	sex <span class="built_in">boolean</span>,</span><br><span class="line">	create_at <span class="built_in">timestamp</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>接着，我们用<code>CREATE TABLE LIKE</code>复制。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span>  user3 (<span class="keyword">LIKE</span> <span class="string">"user"</span> <span class="keyword">including</span> <span class="keyword">constraints</span> <span class="keyword">including</span> <span class="keyword">indexes</span> <span class="keyword">including</span> comments <span class="keyword">including</span> <span class="keyword">defaults</span>);</span><br></pre></td></tr></table></figure><p>我们查看表数据</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span>  * <span class="keyword">FROM</span> user3;</span><br><span class="line"><span class="comment">--</span></span><br></pre></td></tr></table></figure><p>查看<code>DDL</code></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> user3</span><br><span class="line">(</span><br><span class="line">	<span class="keyword">id</span> <span class="built_in">integer</span> <span class="keyword">default</span> <span class="keyword">nextval</span>(<span class="string">'user_id_seq'</span>::regclass) <span class="keyword">not</span> <span class="literal">null</span></span><br><span class="line">		<span class="keyword">constraint</span> user3_pkey</span><br><span class="line">			primary <span class="keyword">key</span>,</span><br><span class="line">	<span class="keyword">name</span> <span class="built_in">text</span></span><br><span class="line">		<span class="keyword">constraint</span> user3_name_key</span><br><span class="line">			<span class="keyword">unique</span>,</span><br><span class="line">	age <span class="built_in">integer</span>,</span><br><span class="line">	sex <span class="built_in">boolean</span>,</span><br><span class="line">	create_at <span class="built_in">timestamp</span> <span class="keyword">default</span> <span class="keyword">now</span>()</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>从这个操作中你知道<code>CREATE TABLE AS</code> 与<code>CREATE TABLE LIKE</code>的区别了么？</p><h5 id="CREATE-TABLE-AS"><a href="#CREATE-TABLE-AS" class="headerlink" title="CREATE TABLE AS"></a>CREATE TABLE AS</h5><p><code>CREATE TABLE AS</code>复制出来的表，所有约束、注释和序列都没有被拷贝，只是简单的字段拷贝,同时数据也能拷贝过来了。</p><h5 id="CREATE-TABLE-LIKE"><a href="#CREATE-TABLE-LIKE" class="headerlink" title="CREATE TABLE LIKE"></a>CREATE TABLE LIKE</h5><p><code>CREATE TABLE LIKE</code> 复制的表，里面没有数据，但是你可以指定复制标的约束，索引，注释，序列。其中</p><ol><li>including constraints ：复制约束</li><li>including indexes ：复制索引</li><li>including comments：复制注释</li><li>including defaults：复制序列</li></ol><p><strong>我们向user3中插入一些数据</strong>：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">"user3"</span> (<span class="keyword">name</span>, age, sex) <span class="keyword">VALUES</span> (<span class="string">'xiaoxiao'</span>,<span class="number">12</span>,<span class="literal">TRUE</span>),(<span class="string">'dada'</span>,<span class="number">18</span>,<span class="literal">FALSE</span> );</span><br><span class="line"><span class="keyword">SELECT</span>  * <span class="keyword">FROM</span> user3;</span><br><span class="line"><span class="comment">-- 3	xiaoming	12	true	2018-05-17 10:06:06.637708</span></span><br><span class="line"><span class="comment">-- 4	xiaohua	18	false	2018-05-17 10:06:06.637708</span></span><br><span class="line"><span class="comment">-- 6	xiaoxiao	12	true	2018-05-17 10:06:21.236574</span></span><br><span class="line"><span class="comment">-- 7	dada	18	false	2018-05-17 10:06:21.236574</span></span><br></pre></td></tr></table></figure><p>嗯，数据<code>id</code>从3开始的，这就意味着序列是接着“user”继续的。</p><h4 id="查看表大小"><a href="#查看表大小" class="headerlink" title="查看表大小"></a>查看表大小</h4><h5 id="查看一个表"><a href="#查看一个表" class="headerlink" title="查看一个表"></a>查看一个表</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> pg_size_pretty(pg_relation_size(<span class="string">'table_name'</span>));</span><br></pre></td></tr></table></figure><h5 id="查出所有表并按大小排序"><a href="#查出所有表并按大小排序" class="headerlink" title="查出所有表并按大小排序"></a>查出所有表并按大小排序</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">table_schema || <span class="string">'.'</span> || table_name </span><br><span class="line"><span class="keyword">AS</span> table_full_name, pg_size_pretty(pg_total_relation_size(<span class="string">'"'</span> ||table_schema || <span class="string">'"."'</span> || table_name || <span class="string">'"'</span>)) <span class="keyword">AS</span> <span class="keyword">size</span></span><br><span class="line"><span class="keyword">FROM</span> </span><br><span class="line">information_schema.tables</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span></span><br><span class="line">    pg_total_relation_size(<span class="string">'"'</span> || table_schema || <span class="string">'"."'</span> || table_name || <span class="string">'"'</span>)</span><br><span class="line"><span class="keyword">DESC</span> <span class="keyword">limit</span> <span class="number">20</span></span><br></pre></td></tr></table></figure><h5 id="查出所有表按大小排序并分离data与index"><a href="#查出所有表按大小排序并分离data与index" class="headerlink" title="查出所有表按大小排序并分离data与index"></a>查出所有表按大小排序并分离data与index</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    table_name,</span><br><span class="line">    pg_size_pretty(table_size) <span class="keyword">AS</span> table_size,</span><br><span class="line">    pg_size_pretty(indexes_size) <span class="keyword">AS</span> indexes_size,</span><br><span class="line">    pg_size_pretty(total_size) <span class="keyword">AS</span> total_size</span><br><span class="line"><span class="keyword">FROM</span> (</span><br><span class="line">    <span class="keyword">SELECT</span></span><br><span class="line">        table_name,</span><br><span class="line">        pg_table_size(table_name) <span class="keyword">AS</span> table_size,</span><br><span class="line">        pg_indexes_size(table_name) <span class="keyword">AS</span> indexes_size,</span><br><span class="line">        pg_total_relation_size(table_name) <span class="keyword">AS</span> total_size</span><br><span class="line">    <span class="keyword">FROM</span> (</span><br><span class="line">        <span class="keyword">SELECT</span> (<span class="string">'"'</span> || table_schema || <span class="string">'"."'</span> || table_name || <span class="string">'"'</span>) <span class="keyword">AS</span> table_name</span><br><span class="line">        <span class="keyword">FROM</span> information_schema.tables</span><br><span class="line">    ) <span class="keyword">AS</span> all_tables</span><br><span class="line">    <span class="keyword">ORDER</span> <span class="keyword">BY</span> total_size <span class="keyword">DESC</span></span><br><span class="line">) <span class="keyword">AS</span> pretty_sizes</span><br></pre></td></tr></table></figure><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><h4 id="比较操作符"><a href="#比较操作符" class="headerlink" title="比较操作符"></a>比较操作符</h4><table><thead><tr><th>操作符</th><th>描述</th></tr></thead><tbody><tr><td>&lt;</td><td>小于</td></tr><tr><td>&gt;</td><td>大于</td></tr><tr><td>&lt;=</td><td>小于等于</td></tr><tr><td>&gt;=</td><td>大于等于</td></tr><tr><td>=</td><td>等于</td></tr><tr><td>&lt;&gt; or !=</td><td>不等于</td></tr></tbody></table><p><em>注意</em></p><p>!=操作符在分析器阶段被转换成&lt;&gt;。不能把!=和&lt;&gt;操作符实现为做不同的事。</p><p>比较操作符可以用于所有可以比较的数据类型。所有比较操作符都是双目操作符，它们返回boolean类型；类似于1 &lt; 2 &lt; 3的表达式是非法的（因为没有&lt;操作符可以比较一个布尔值和3）。</p><ul><li><a href="http://www.postgres.cn/docs/9.3.4/functions-comparison.html" target="_blank" rel="noopener">link</a></li></ul><h3 id="习惯"><a href="#习惯" class="headerlink" title="习惯"></a>习惯</h3><ul><li>虽然<code>SELECT *</code>对于即席查询很有用，但我们普遍认为在生产代码中这是很糟糕的风格，因为给表增加一个列就改变了结果。</li><li>在一些数据库系统里，包括老版本的PostgreSQL，<code>DISTINCT</code>的实现自动对行进行排序，因此ORDER BY是多余的。但是这一点并不是 SQL 标准的要求，并且目前的PostgreSQL并不保证<code>DISTINCT</code>会导致行被排序。</li></ul><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="http://www.postgres.cn/docs/9.5/" target="_blank" rel="noopener">PostgreSQL 9.5.3 中文手册</a></li></ul><ul><li><p><a href="https://blog.csdn.net/wlwlwlwl015/article/details/52493197" target="_blank" rel="noopener">PostgreSQL 动态表复制(CREATE TABLE…LIKE)</a></p></li><li><p><a href="https://blog.csdn.net/kmust20093211/article/details/47616345" target="_blank" rel="noopener">postgresql 查看单个表大小</a></p><p>​</p></li></ul>]]></content>
      <categories>
        <category>开发实战总结</category>
      </categories>
      <tags>
        <tag>postgres</tag>
        <tag>sql</tag>
      </tags>
  </entry>
  <entry>
    <title>宝宝入幼儿园全程记录（2021年上海托幼入园政策解读）</title>
    <url>//post/shanghai-kindergarten-policy-2021.html</url>
    <content><![CDATA[<p>一转眼宝宝都3岁多了，9月份就要进入幼儿园了，在这里记录一下托班进入幼儿园的全过程。其中包括了今年的相关政策解读，与实际操作记录。</p><a id="more"></a><h2 id="全程记录"><a href="#全程记录" class="headerlink" title="全程记录"></a>全程记录</h2><p>背景：外地，居住证积分满120。</p><ul><li><p>2021/06/20 领取通知书。由于我要考试，奶奶带去的，听说有小朋友一些吃点心，跳舞，叠衣服等活动。最后拿到通知，以及需要体验和办银行卡的相关说明。现在就等开学啦~</p></li><li><p>2021/06/18 收到录取短信通知，终于放心了, 内容大概如下：</p><p>【浦东学前教育】xxx家长您好，请您于2021年06月20日 10:00-10:45，前往xxx幼儿园xx路xx弄xx号。上海市浦东新区xxx幼儿园xx部领取新生录取通知书，小班新生家长会时间将由幼儿园另行通知。</p></li><li><p>2021/05/16 幼儿园面试。面试过程如下：</p><ul><li><p>准备文件</p><ul><li>入园信息登记表</li><li>孩子出生证明复印和原件</li><li>孩子户口本复印和原件</li><li>租赁备案复印和原件</li><li>孩子居住证复印（居住登记也可) 和原件</li><li>主要监护人的居住证复印和原件</li><li>主要监护人的积分通知单</li><li>主要监护人的社保缴纳证明</li></ul></li><li><p>面试提问（主要是问宝宝一些问题）</p><ul><li>你叫什么名字？</li><li>你多大啦？</li><li>我这里有什么颜色, 什么颜色？（老师一个个指着桌子上的玩具）</li><li>我这有什么水果呀？最喜欢吃什么？不喜欢吃什么？为什么不喜欢呢？</li><li>这是什么动物呀？</li><li>我这里有些积木，你搭一个老师这样的形状试试？</li><li>你会唱歌吗？唱个两只老虎好不好？</li></ul></li><li><p>问家长宝宝的习惯</p><ul><li>有没有过敏体质？对什么过敏？</li><li>吃饭会自己吃么？上厕所之类的</li></ul></li><li><p>算分（根据积分、居住证年限、社保年限 打一个分，规则如下表）</p></li></ul></li></ul><table><thead><tr><th>记分来源</th><th>记分规则</th></tr></thead><tbody><tr><td>积分是满120</td><td>40分</td></tr><tr><td>居住证年限</td><td>每满一个月算一分（最高36分）</td></tr><tr><td>社保缴纳年限</td><td>每满一个月一分（最高36分）</td></tr></tbody></table><ul><li><p>2021/05/08 <a href="https://xqzs.pdedu.sh.cn" target="_blank" rel="noopener">区级平台</a>预约。利用上次注册的账号登录，经过一系列申明确认，最后可以看到上次登记的宝宝信息，根据步骤完善即可。其中选幼儿园可能需要提前做一下功课，然后就是预约面试时间，下载登记表。</p><p><img data-src="https://st.razeen.cn/img/baobao/baobao-02.png" alt></p></li></ul><ul><li><p>2021/04/23 <a href="https://shrydj.edu.sh.cn" target="_blank" rel="noopener">市级平台</a>登记。主要包括注册、登记两个过程，如下图。</p><p><img data-src="https://st.razeen.cn/img/baobao/baobao-01.png" alt></p></li></ul><ul><li>2021/04/19 托班园长对今年的入园政策解读，内容如第二部分。</li></ul><h2 id="托幼入园政策解读"><a href="#托幼入园政策解读" class="headerlink" title="托幼入园政策解读"></a>托幼入园政策解读</h2><p>上周六宝宝托班的园长讲解了一下今年的入园政策，我将内容整理了一下，分享出来。</p><h3 id="主要改动"><a href="#主要改动" class="headerlink" title="主要改动"></a>主要改动</h3><p><img data-src="https://st.razeen.cn/img/20210420000013_image-20210419235904873.png" alt="主要改动"></p><h3 id="幼儿园招生时间表"><a href="#幼儿园招生时间表" class="headerlink" title="幼儿园招生时间表"></a>幼儿园招生时间表</h3><p>主要分为四个阶段</p><ol><li>信息登记：市级平台 4月23日-4月30日</li><li>网上预约：区级平台 5月08日-5月13日</li><li>现场验证：<ol><li>第一批：5月15、16、22、23日</li><li>第二批：6月12、13日</li></ol></li><li>录取通知： 6月18日</li></ol><h3 id="政策解读"><a href="#政策解读" class="headerlink" title="政策解读"></a>政策解读</h3><ul><li>政策原文：<a href="https://edu.sh.gov.cn/cmsres/59/59f9b3a6f99345b69b1adab3bef4878e/194bf5c1bda2c29bde5825d1d1cce7e2.pdf" target="_blank" rel="noopener">上海市教育委员会关于做好2021年本市学前教育阶段适龄幼儿入园工作的通知</a>。</li><li>政策问答：<a href="https://edu.sh.gov.cn/cmsres/09/09c840a111e54e4892f2bf457fd49f15/bdca31e3c26de6f3434ee8f237e5d306.pdf" target="_blank" rel="noopener">2021年上海市适龄幼儿入园工作政策问答</a></li><li>各区政策：<a href="https://shrydj.edu.sh.cn/views/common/contact.html" target="_blank" rel="noopener">本市各区幼儿入园招生政策、联系单位、咨询电话及咨询时间一览表</a></li><li>浦东政策：<a href="http://www.pudong.gov.cn/shpd//Upfiles/FileAttach/733c990d-3fbc-bef1-ac54-dedd4e045a8b/%e5%85%b3%e4%ba%8e%e5%8d%b0%e5%8f%91%e3%80%8a%e6%b5%a6%e4%b8%9c%e6%96%b0%e5%8c%ba%e6%95%99%e8%82%b2%e5%b1%80%e5%85%b3%e4%ba%8e2021%e5%b9%b4%e6%9c%ac%e5%8c%ba%e5%ad%a6%e5%89%8d%e6%95%99%e8%82%b2%e9%98%b6%e6%ae%b5%e9%80%82%e9%be%84%e5%b9%bc%e5%84%bf%e5%85%a5%e5%9b%ad%e5%b7%a5%e4%bd%9c%e7%9a%84%e5%ae%9e%e6%96%bd%e6%84%8f%e8%a7%81%e3%80%8b%e7%9a%84%e9%80%9a%e7%9f%a5.pdf" target="_blank" rel="noopener">关于印发《浦东新区教育局关于2021年本区学前教育阶段适龄幼儿入园工作的实施意见》的通知</a></li></ul><h4 id="信息登记"><a href="#信息登记" class="headerlink" title="信息登记"></a>信息登记</h4><p>信息登记主要注意几点：</p><ol><li>凡入园必须进行登记；</li><li>信息登记及登记顺序均与幼儿是否录取无关（根据政策进行安排）；</li><li>登记先后顺序与录取顺序无关；</li><li><p>登记时间别弄错了，4月23日-4月30日，网址<a href="https://shrydj.edu.sh.cn" target="_blank" rel="noopener">shrydj.edu.sh.cn</a>；</p><p>本次入园的年龄段为：出生日期在 2017/09/01-2018/08/31.<br>幼儿园托班，中大班插班转园以及外籍人员子女学校幼儿不在本次入园信息登记的范围。</p><p>登记后会获取到一个<strong>登记编号</strong>和登记表，这是进入区级入园报名的凭证。</p></li></ol><p><strong>登记条件</strong></p><p>要登记需要（幼儿或家长）有下面的证件之一，没有是无法登记的。</p><ol><li>本市户籍：身份证</li><li>非本市户籍：<ol><li>居住证 或 居住登记凭证；</li><li>港澳具名来往内地通信证 或 港澳居住证；</li><li>台湾居民来往大陆通信证 或 台湾居住证；</li></ol></li><li>外籍： 护照</li></ol><p><strong>信息确认</strong></p><p>登记的时候，会把本市系统里有的信息提供出来，家长确认或修改、补充。</p><p>这里有点比较重要就是：提交后<strong>无法系统内修改</strong>，修改必须有正当理由，而且需要提交书面申请，审核通过后才能改。</p><p>且<br>报名衍生阶段修改的，可以凭证明，在幼儿园进行修改；<br>报名验证结束后要改的，要在区的指定地点登记，然后修改。</p><h4 id="网上预约-浦东新区"><a href="#网上预约-浦东新区" class="headerlink" title="网上预约 (浦东新区)"></a>网上预约 (浦东新区)</h4><p>预约时间：5月8日-5月13日<br>预约地址(浦东新区)：<a href="https://xqzs.pdedu.sh.cn" target="_blank" rel="noopener">xqzs.pdedu.sh.cn</a>.</p><p>家长凭借市里登记拿到的编号，到这个网站预约，获取《2021年浦东新区幼儿入园报名验证预约登记表》，该表作为入园报名的登记凭证。</p><p><strong>预约要求</strong></p><p>可以在地段园所或区招生园里面预约一所，只能预约一所。</p><ol><li>地段园所按照招生地段进行电脑自动分配；</li><li>全区招生园所由家长根据实际情况自行选择；</li><li>一旦选择了区级招生园就不能再选地段园了。</li></ol><p>这里的信息千万不要出错，修改起来也是比较麻烦的，需要正当理由，书面证明且通过审核。</p><h4 id="现场验证（分两批）"><a href="#现场验证（分两批）" class="headerlink" title="现场验证（分两批）"></a>现场验证（分两批）</h4><p><strong>验证时间</strong></p><p>第一批： 5月15、16、22、23日<br>第二批： 6月12、13日</p><p><strong>验证要求</strong></p><ol><li>按照预约验证时间，凭《2021年浦东新区幼儿入园报名验证预约登记表》进行现场验证。</li><li>带好入园需要的相关证件或证明材料原件以及复印件。</li></ol><p><strong>“随申办市民云”</strong>或<strong>“上海一网通办”</strong>中的电子证件照与纸质证件可等同效力使用；</p><p>预约好了，下载打印报名验证预约登记表。</p><p>这里也是，预约确认成功后，无法自动修改信息。</p><p>还需注意：<br>没有通过第一批验证或者面谈的，可以根据第一批报名验证和录取的情况，按照“本区户籍优先，同类排序靠后”的原则进行区域统筹，并根据统筹结果进行第二批现场验证。<br>现场验证：电子证照具有同等效力。</p><p>招生入园条件：</p><ol><li><p>本区户籍、人户一致：按户籍地址<strong>对口入园</strong>；</p></li><li><p>本市户籍、人户分离：按房产证<strong>就近入园</strong>；</p><ul><li>有房产证：产权人须为幼儿父母或者其本人。（全部或者共同产权）</li></ul></li><li><p>父母一方《上海市居住证》满标准积分；<br><strong>注意</strong>：居住证的居住地址在本区（幼儿园招生对口区域）</p><ul><li>有房产证：产权人须为幼儿父母或其本人。（全部或共同产权）参照本市户籍、人户分离幼儿，按房产证地址<strong>就近入园</strong>；</li><li>无房产证：凭本区合法居住证明，根据实际居住地址，<strong>统筹入园</strong>。<br><strong>注意</strong>：承租人或买受人须是幼儿父母；</li></ul></li></ol><ol start="4"><li><p>动迁户适龄幼儿</p><ul><li>动迁安置地配套幼儿园已具备招生条件：可凭动迁协议书安置地址<strong>就近入园</strong>。</li><li>动迁安置地配套幼儿园不具备招生条件：可凭动迁证安置地址<strong>统筹入园</strong>。</li><li>租赁房屋居住的：凭本区合法居住证书，根据实际居住地址，<strong>统筹入园</strong>。</li></ul></li><li><p>本市外区户籍,在本区无房产适龄幼儿：</p><ul><li>凭本区合法居住证书，居住实际居住地址，<strong>统筹入园</strong>。</li></ul></li><li><p>其余符合条件的来户人员随迁子女：</p><ul><li>幼儿本人：持有效内《上海市居住证》或《居住登记凭证》</li><li>幼儿父或母：<br>持有效期内《上海市居住证》<br>一年内参加本市职工社会保险满6个月（2020/7/1-2021/6/30），不含补缴、因疫情防控需要允许补缴的除外）<br>连续3年在本区街道社会事务中心办妥灵活就业登记（从首次登记日至2021/6/30）</li><li>居住证地址：<br>应与其父母保持一致，且居住地址在本区幼儿园招生对口区域。</li><li>有房产证的：<br>产权人须是幼儿父母或本人（全部或共有产权），按产权证地址，<strong>统筹入园</strong>；</li><li>无房产证的：<br>在规定时间内，凭本区合法居住证明，更具各公/民办幼儿园第一批报名验证情况，<strong>统筹安排至尚有余额的公办幼儿园或民办三级幼儿园</strong>。</li></ul></li></ol><ol start="7"><li>香港、澳门、台湾适龄儿童：<br>根据实际居住地址，<strong>统筹入园</strong>。</li></ol><ol start="8"><li>外籍幼儿<br>根据实际居住地址，<strong>统筹入园</strong>。<br>外国护照（要有中国外国人许可页，且有效签证）+《境外人员住宿登记表》。</li></ol><ol start="9"><li>特殊幼儿<br>须持有本市户籍：可到一下幼儿园报名：<ul><li>特教幼儿园：<br>爱心幼儿园</li><li>普特融合幼儿园：<br>上南三村幼儿园特教班、爱心幼儿园特教班、海音幼儿园特教班、致立学校特教班。</li></ul></li></ol><ol start="10"><li>其他符合入园条件的幼儿：<br>除以上情况外，其他符合在本区入园的育儿，视实际情况<strong>统筹入园</strong>。</li></ol><p><strong>现场验证需要文件</strong></p><p><strong>就近入园</strong>的请带好：</p><ol><li>2021年上海市适龄幼儿入园信息登记表；</li><li>孩子出生证原件、复印件；</li><li>孩子的户口本原件、复印件（需要户口本首页到幼儿页面正反面的全部内容，并将复印件按照页面顺序排好）；</li><li>正规的动迁安置协议书原件、复印件以及动迁至我园地段的相关证件，监护人户籍证书原件以及复印件；</li><li>房产证原件、复印件（复印第一页到产权人页的全部内容）；</li><li>公租房或廉租房租赁证书原件、复印件，经适房产证原件、复印件（复印要求同房产证）；</li><li>父母一方的上海市居住证和满积分通知书原件、复印件，孩子有效期内的上海市居住证或居住凭证原件、复印件；</li></ol><p><strong>统筹安排</strong>的请带好：</p><ol><li>2021年上海市适龄幼儿入园信息登记表；</li><li>孩子出生证原件、复印件；</li><li>孩子的户口本原件、复印件（复印要求同上）；</li><li>地段内房产证原件、复印件（复印要求同上），人户分离证明；</li><li>地段内《上海市居住房屋租赁合同登记备案通知书》原件、复印件；</li><li>孩子有效期内的上海市居住证或居住凭证原件、复印件及网上有效期查询结果页打印件；</li><li>父母一方上海市居住证满积分原件、复印件以及网上查询结果打印页；</li><li>父母一方在有效期内的上海市居住证原件、复印件及网上查询的结果打印页；</li><li>社保缴金证明原件、复印件（一年内参加本市职工社会保险满6个月：2020/7/01-2021/6/30，不含补缴）</li><li>灵活就业证原件、复印件（联系3年：从首次登记日起至2021/6/30）</li></ol><p>⚠️ 请家长按照目录顺序排列所有复印件。</p><h4 id="录取通知"><a href="#录取通知" class="headerlink" title="录取通知"></a>录取通知</h4><p>6月18起：家长可以登陆浦东新区的适龄幼儿入园报名系统，查看录取结果。</p><p>6月30日前：各类各级幼儿园完成幼儿录取工作，发放录取通知书。</p><p>9月10日前：各级各类幼儿园完成新生注册报到及幼儿信息上报工作。</p><h3 id="其他入园前准备工作"><a href="#其他入园前准备工作" class="headerlink" title="其他入园前准备工作"></a>其他入园前准备工作</h3><h4 id="宝宝心理准备"><a href="#宝宝心理准备" class="headerlink" title="宝宝心理准备"></a>宝宝心理准备</h4><ul><li style="list-style:none"><input type="checkbox">要让宝宝对幼儿园有好的印象，告诉宝宝幼儿园同学一起玩，老师有爱心等等；</li><li style="list-style:none"><input type="checkbox">带宝宝去幼儿园熟悉，参观；</li><li style="list-style:none"><input type="checkbox">减少与家中依赖人员交流，与其他孩子交流，与其他家长交流，在家中给孩子一个独立空间，减轻对熟悉人的依恋；</li><li style="list-style:none"><input type="checkbox">让孩子期待幼儿园，老师和同学都可以一起玩，不能告诉孩子“家里不乖，给你送给老师管管”之类的话。</li></ul><h4 id="宝宝生理准备"><a href="#宝宝生理准备" class="headerlink" title="宝宝生理准备"></a>宝宝生理准备</h4><ul><li style="list-style:none"><input type="checkbox">自理（吃饭，擦屁屁等）</li><li style="list-style:none"><input type="checkbox">日常生活用语（让孩子自己表达自己的意愿）</li></ul><h4 id="宝宝的生活衔接"><a href="#宝宝的生活衔接" class="headerlink" title="宝宝的生活衔接"></a>宝宝的生活衔接</h4><p>调整作息时间<br>主要包括起床和午睡的时间等；</p><p>这里有一个幼儿园的活动安排表，可以供参考。</p><table><thead><tr><th>时间</th><th>内容安排</th><th>备注</th></tr></thead><tbody><tr><td>7:45 - 8:15</td><td>自然角观察护理/个别交谈</td><td></td></tr><tr><td>8:15 - 9:15</td><td>自主游戏与生活</td><td>8:40 - 9:00 插入式点心<br>9:00 - 9:15 学习活动</td></tr><tr><td>9:15 - 9:50</td><td>学习/自由活动/运动</td><td></td></tr><tr><td>9:50 - 10:30</td><td>学习/自由活动/运动</td><td></td></tr><tr><td>10:30 - 11:00</td><td>自由运动/餐前准备</td><td></td></tr><tr><td>11:00 - 11:30</td><td>午餐</td><td></td></tr><tr><td>11:30 - 14:50</td><td>自由活动/午睡等</td><td>11:30 - 12:00 餐后散步/集体游戏等</td></tr><tr><td>14:50 - 15:10</td><td>生活活动/运动</td><td></td></tr><tr><td>15:10 - 15:30</td><td>点心</td><td></td></tr><tr><td>15:30 - 16:00</td><td>个别化学习活动</td><td></td></tr><tr><td>16:00</td><td>整理/离园</td><td>-</td></tr></tbody></table><h4 id="家长准备"><a href="#家长准备" class="headerlink" title="家长准备"></a>家长准备</h4><ul><li style="list-style:none"><input type="checkbox">调整心态，鼓励宝宝自己的事情自己做；</li><li style="list-style:none"><input type="checkbox">信任老师；</li><li style="list-style:none"><input type="checkbox">孩子衣物准备（容易穿的，活动的衣服，替换的衣服）；</li><li style="list-style:none"><input type="checkbox">实事求是介绍孩子情况给老师（过敏体质？性格怎么样？）。</li></ul><h4 id="幼儿园面试"><a href="#幼儿园面试" class="headerlink" title="幼儿园面试"></a>幼儿园面试</h4><p>最后提了一下幼儿园面试的大概内容（针对宝宝）：</p><ul><li style="list-style:none"><input type="checkbox">会说家长名字</li><li style="list-style:none"><input type="checkbox">会说家里地址</li><li style="list-style:none"><input type="checkbox">会认颜色</li><li style="list-style:none"><input type="checkbox">日常的东西的指认</li><li style="list-style:none"><input type="checkbox">会数数，数量关联</li><li style="list-style:none"><input type="checkbox">可以适当才艺展示（唱歌/跳舞？）</li></ul><p>大致内容就是这么多，结合上面的政策，可以评估宝宝可以报名的学校。</p>]]></content>
      <categories>
        <category>生活记实</category>
        <category>宝宝成长</category>
      </categories>
      <tags>
        <tag>幼儿园</tag>
        <tag>宝宝</tag>
      </tags>
  </entry>
  <entry>
    <title>2021 上海人才引进落户全程记录</title>
    <url>//post/shanghai-settltment-record.html</url>
    <content><![CDATA[<p>来上海五年多了，终于落户了。后面小孩子上学相对要简单一些了，身为老父亲的我稍稍松了口气。</p><p>今年上海落户政策放松了不少，趁着这波机会，我司帮忙提出了落户申请。 从公司提出申请到拿到户口卡，整个过程持续约3个月。</p><p>这篇博客记录一下整个人才引进落户的过程，供各位童鞋参考。</p><a id="more"></a><h3 id="04-06-成功提交申请"><a href="#04-06-成功提交申请" class="headerlink" title="04.06 成功提交申请"></a>04.06 成功提交申请</h3><p>第一步，人事在人社系统中提交人才引进落户申请。</p><p>这一步要准备各种材料，提交给人才服务中心，人才服务中心会有专人审核，不通过会在系统内提示哪些地方有问题，修改确认后再提交，再审核，反复直到全部材料符合要求。</p><p>其中，主要材料如下。</p><p><img data-src="https://st.razeen.cn/img/20210701223502-image-20210701223459754.png" alt="image-20210701223459754"></p><p>当然，除了这些材料外，还要填写很多相关的信息，其中有一项是写个人的业绩，这项需要好好写一下，突出个人的能力，为公司、社会带来的价值，这样才能突出自己是个不可或缺的 “人才”。</p><p>在提交这些材料的过程中，被打回来多次，下面是一些原因，可供参考。</p><p><img data-src="https://st.razeen.cn/img/20210701234222-image-20210701234216329.png" alt="image-20210701224106417"></p><p><img data-src="https://st.razeen.cn/img/20210701234247-image-20210701234245017.png" alt="image-20210701234245017"></p><p><img data-src="https://st.razeen.cn/img/20210701234309-image-20210701234307437.png" alt="image-20210701234307437"></p><p><img data-src="https://st.razeen.cn/img/20210701234332-image-20210701234328114.png" alt="image-20210701234328114"></p><p>反复提交，确认，修改，4月6号这天终于提交显示没问题了，中间辛苦人事小姐姐反复确认~</p><p>之后就是等待预受理了。</p><h3 id="04-14-预受理通过，出具调档函"><a href="#04-14-预受理通过，出具调档函" class="headerlink" title="04.14 预受理通过，出具调档函"></a>04.14 预受理通过，出具调档函</h3><p>经过一个多星期的等待， 在 “上海人社” App中可以查看到进度状态有了，显示预受理通过。</p><p><img data-src="https://st.razeen.cn/img/20210701233207-image-20210701233150193.png" alt="image-20210701233150193"></p><p>当然，人事的系统也是可以看到的：</p><p><img data-src="https://st.razeen.cn/img/20210702000021-image-20210701224759593.png" alt="image-20210701224759593"></p><p>这时，人事是可以下载到调档函的。收到调档函后，联系老家亲戚帮忙彩色打印好，带着身份证复印件，就去老家的人才中心调档案了。</p><h3 id="04-21-档案调出"><a href="#04-21-档案调出" class="headerlink" title="04.21 档案调出"></a>04.21 档案调出</h3><p>提交调档函后，打电话回家确认了几次。人才中心告诉我，在4月21号档案通过机要寄出。</p><h3 id="04-30-档案核实完成"><a href="#04-30-档案核实完成" class="headerlink" title="04.30 档案核实完成"></a>04.30 档案核实完成</h3><p>4月30号，人社App状态更新，继续等待。</p><p><img data-src="https://st.razeen.cn/img/20210701233229-image-20210701233223329.png" alt="image-20210701233223329"></p><h3 id="05-07-网上受理通过"><a href="#05-07-网上受理通过" class="headerlink" title="05.07 网上受理通过"></a>05.07 网上受理通过</h3><p>5月7号，网上状态再次更新，提示需要准备材料到现场提交了。</p><p><img data-src="https://st.razeen.cn/img/20210701233250-image-20210701233245451.png" alt="image-20210701233245451"></p><p>在这中间还出了点小插曲，我的毕业证和学位证原件不见了，回学校补办了一下，还写了篇博客<a href="https://razeencheng.com/post/fill-do-degree-graduation-certificate.html">《记录学位证、毕业证补办过程》</a>记录了一下。</p><h3 id="05-28-现场提交材料"><a href="#05-28-现场提交材料" class="headerlink" title="05.28 现场提交材料"></a>05.28 现场提交材料</h3><p>5月28号，带着网上提交的全部材料，和人事小姐姐一起到现场提交了。原来还担心补办的学位证和原来提交不一致，会有问题，还好最后并不影响。</p><h3 id="06-01-现场受理通过"><a href="#06-01-现场受理通过" class="headerlink" title="06.01 现场受理通过"></a>06.01 现场受理通过</h3><p>6月1号，正值儿童节，人事通知我，现场受理通过了。App上稍微延迟一点，也查到了。</p><p><img data-src="https://st.razeen.cn/img/20210701233305-image-20210701233304279.png" alt="image-20210701233304279"></p><p>接着就是区里和市里审核了，静静等待。</p><h3 id="06-09-审核中"><a href="#06-09-审核中" class="headerlink" title="06.09 审核中"></a>06.09 审核中</h3><p>6月9号，人社App显示审核中，继续等待。</p><p><img data-src="https://st.razeen.cn/img/20210701233404-image-20210701233327062.png" alt="image-20210701233327062"></p><h3 id="06-15-公示中"><a href="#06-15-公示中" class="headerlink" title="06.15 公示中"></a>06.15 公示中</h3><p>6月15日早上，一起办理的同事告诉我，在人社的官网看到我两的名字在这一批的公示名单中了，激动。</p><p>此时App状态还没有更新。</p><p>6月16号，App状态才改变，继续等待。</p><p><img data-src="https://st.razeen.cn/img/20210701233354-image-20210701233352525.png" alt="image-20210701233352525"></p><h3 id="06-21-公示结束"><a href="#06-21-公示结束" class="headerlink" title="06.21 公示结束"></a>06.21 公示结束</h3><p>6月21号，人事告知公示结束了，等3-5天就可以到 上海公安公众号 或随申办 查查看准迁信息了。</p><p>人社App上的信息也是一天后才更新。</p><p><img data-src="https://st.razeen.cn/img/20210701233421-image-20210701233419232.png" alt="image-20210701233419232"></p><h3 id="06-24-查询到准迁信息"><a href="#06-24-查询到准迁信息" class="headerlink" title="06.24 查询到准迁信息"></a>06.24 查询到准迁信息</h3><p>6月24号，在随申办 “落户审批查询” 中查询到准迁信息。</p><p><img data-src="https://st.razeen.cn/img/20210701235906-image-20210701231855480.png" alt="image-20210701231855480"></p><h3 id="06-25-办理准迁证"><a href="#06-25-办理准迁证" class="headerlink" title="06.25 办理准迁证"></a>06.25 办理准迁证</h3><p>6月25日，带着身份证，户口本，结婚证，宝宝的出生证书，到居住街道的派出所 户籍窗口 办好了 准迁证。全程30分钟不到。</p><p><img data-src="https://st.razeen.cn/img/20210701235832-image-20210701231830638.png" alt="image-20210701231830638"></p><h3 id="06-29-办理迁移证"><a href="#06-29-办理迁移证" class="headerlink" title="06.29 办理迁移证"></a>06.29 办理迁移证</h3><p>回老家，拿着 准迁证，身份证，户口本，以及人口登记表 到户籍所在派出所办理迁移证。其中，人口登记表还是在村里，办理的时候没拿，联系亲戚后补过去的。</p><p><img data-src="https://st.razeen.cn/img/20210701235954-image-20210701232421182.png" alt="image-20210701232421182"></p><h3 id="06-30-办理户口-身份证"><a href="#06-30-办理户口-身份证" class="headerlink" title="06.30 办理户口/身份证"></a>06.30 办理户口/身份证</h3><p>回到上海，拿着 迁移证，户口本，原身份证，宝宝出生证书，带着宝宝一起到 户籍窗口 办理迁入。</p><p>需要注意的是，办理新身份证要提前拍照，可以到派出所拍，也可以自己到联网公安的照相馆拍，我就是在后者拍的，效果要好点。</p><p>办理的时候，需要填写两张表，一张“进沪人员‘社区公共户’申请表” 和 一张 “生育状态承诺书”， 按要求填好之后，继续办理。</p><p>最后，当场拿到户口卡。身份证邮寄7个工作日到，现场拿15个工作日到, 原身份证直接给没收了。。。</p><p><img data-src="https://st.razeen.cn/img/20210701235938-image-20210701233006758.png" alt="image-20210701233006758"></p><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>到这里，整个人才引进落户过程结束了。</p><p>说实话，拿到户口卡后，第一感觉不是开心，反而更多一点焦虑。 户口卡是三年有效期的，只有买房了才能拿到户口本。再看看当下的收入与上海的房价，肩上顿觉有一座大山，呼吸艰难。</p><p>但，已经向前迈了一步，不是么。坚持努力，多思考，相信未来还是很美好的。总之，一起加油，为了更美好的明天。</p>]]></content>
      <categories>
        <category>生活记实</category>
      </categories>
      <tags>
        <tag>落户</tag>
      </tags>
  </entry>
  <entry>
    <title>Go学习笔记(八) | 使用 os/exec 执行命令</title>
    <url>//post/simple-use-go-exec-command.html</url>
    <content><![CDATA[<p>用Go去调用一些外部的命令其实很愉快的，这遍文章就总结一下我自己日常用的比较多的几种方法。</p><h3 id="关于Unix标准输入输出"><a href="#关于Unix标准输入输出" class="headerlink" title="关于Unix标准输入输出"></a>关于Unix标准输入输出</h3><p>在具体聊<code>os/exec</code>的使用前，了解一下shell的标准输出是很有必要的。</p><p>我们平常会用到或看到这样的命令：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ls xxx 1&gt;out.txt 2&gt;&amp;1</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> nohup xxx 2&gt;&amp;1 &amp;</span></span><br></pre></td></tr></table></figure><p>你知道这里<code>1,2</code>含义么？</p><p>其实这里的<code>1,2</code>指的就是Unix文件描述符。文件描述符其实就一数字，每一个文件描述符代表的都是一个文件。如果你打开100个文件，你就会获取到100个文件描述符。</p><p>这里需要注意的一点就是，在Unix中<a href="https://en.wikipedia.org/wiki/Everything_is_a_file" target="_blank" rel="noopener"><strong>一切皆文件</strong></a>。当然，这里我们不必去深究，我们需要知道的是<code>1，2</code>代表的是标准输出<code>stdout</code>与标准错误输出<code>stderr</code>。还有<code>0</code>代表标准输入<code>stdin</code>。</p><p>在<code>os/exec</code>中就用到了<code>Stdin</code>,<code>Stdout</code>,<code>Stderr</code>，这些基本Unix知识或能帮助我们更好理解这些参数。</p><h3 id="os-exec"><a href="#os-exec" class="headerlink" title="os/exec"></a>os/exec</h3><p><code>os/exec</code>包内容并不多，我们大概过一下。</p><ol><li><p><a href="https://godoc.org/os/exec#LookPath" target="_blank" rel="noopener">LookPath(file string) (string, error)</a></p><p>寻找可执行文件路径，如果你指定的可执行文件在<code>$PATH</code>中，就会返回这个可执行文件的相对/绝对路径；如果你指定的是一个文件路径，他就是去判断文件是否可读取/执行，返回的是一样的路径。</p><p>在我们需要使用一些外部命令/可执行文件的时候，我们可以先使用该函数判断一下该命令/可执行文件是否有效。</p></li><li><p><a href="https://godoc.org/os/exec#Command" target="_blank" rel="noopener">Command(name string, arg …string) *Cmd</a></p><p>使用你输入的参数，返回Cmd指针，可用于执行Cmd的方法。</p><p>这里<code>name</code>就是我们的命令/可执行文件，后面的参数可以一个一个输入。</p></li><li><p><a href="https://godoc.org/os/exec#CommandContext" target="_blank" rel="noopener">CommandContext(ctx context.Context, name string, arg …string) *Cmd</a></p><p>和上面功能一样，不过我们可以用上下文做一些超时等控制。</p></li><li><p>之后几个就是Cmd的一些方法。</p><ul><li><p><a href="https://godoc.org/os/exec#Cmd.CombinedOutput" target="_blank" rel="noopener">(c *Cmd) CombinedOutput() ([]byte, error)</a> 将标准输出，错误输出一起返回；</p></li><li><p><a href="https://godoc.org/os/exec#Cmd.Output" target="_blank" rel="noopener">(c *Cmd) Output() ([]byte, error)</a> 输出标准输出，错误从error返回；</p></li><li><p><a href="https://godoc.org/os/exec#Cmd.Run" target="_blank" rel="noopener">(c *Cmd) Run() error</a> 执行任务，等待执行完成；</p></li><li><p><a href="https://godoc.org/os/exec#Cmd.Start" target="_blank" rel="noopener">(c *Cmd) Start() error</a>， <a href="https://godoc.org/os/exec#Cmd.Wait" target="_blank" rel="noopener">(c *Cmd) Wait() error</a> 前者执行任务，不等待完成，用后者等待，并释放资源；</p></li><li><p><a href="https://godoc.org/os/exec#Cmd.StderrPipe" target="_blank" rel="noopener">(c *Cmd) StderrPipe() (io.ReadCloser, error)</a></p><p><a href="https://godoc.org/os/exec#Cmd.StdinPipe" target="_blank" rel="noopener">(c *Cmd) StdinPipe() (io.WriteCloser, error)</a></p><p><a href="https://godoc.org/os/exec#Cmd.StdoutPipe" target="_blank" rel="noopener">(c *Cmd) StdoutPipe() (io.ReadCloser, error)</a></p><p>这三个功能类似，就是提供一个标准输入/输出/错误输出的管道，我们可用这些管道中去输入输出。</p></li></ul></li></ol><p>其实读完，结合官方的一些example，使用很简单，下面具体写几个场景。</p><p><em>注</em></p><ol><li><p>本文全部的Demo在<a href="https://github.com/razeencheng/demo-go/tree/master/os-exec" target="_blank" rel="noopener">这里</a>。</p></li><li><p><code>./testcmd/testcmd</code>是我用Go写的一个简单的可执行文件，可以根据指定的参数 输出/延时输出/输出错误，方便我们演示。如下</p></li></ol><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> (</span><br><span class="line">		start <span class="keyword">bool</span></span><br><span class="line">		e     <span class="keyword">bool</span></span><br><span class="line">	)</span><br><span class="line"></span><br><span class="line">	flag.BoolVar(&amp;start, <span class="string">"s"</span>, <span class="literal">false</span>, <span class="string">"start output"</span>)</span><br><span class="line">	flag.BoolVar(&amp;e, <span class="string">"e"</span>, <span class="literal">false</span>, <span class="string">"output err"</span>)</span><br><span class="line">	flag.Parse()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> start &#123;</span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">5</span>; i &gt; <span class="number">0</span>; i-- &#123;</span><br><span class="line">			fmt.Fprintln(os.Stdout, <span class="string">"test cmd output"</span>, i)</span><br><span class="line">			time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> e &#123;</span><br><span class="line">		fmt.Fprintln(os.Stderr, <span class="string">"a err occur"</span>)</span><br><span class="line">		os.Exit(<span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Fprintln(os.Stdout, <span class="string">"test cmd stdout"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="简单执行"><a href="#简单执行" class="headerlink" title="简单执行"></a>简单执行</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 简单执行</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test1</span><span class="params">()</span></span> &#123;</span><br><span class="line">	cmd := exec.Command(<span class="string">"./testcmd/testcmd"</span>, <span class="string">"-s"</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 使用CombinedOutput 将stdout stderr合并输出</span></span><br><span class="line">	out, err := cmd.CombinedOutput()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Printf(<span class="string">"test1 failed %s\n"</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	log.Println(<span class="string">"test1 output "</span>, <span class="keyword">string</span>(out))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Run Test 1</span><br><span class="line">2019/06/06 18:02:39 test1 output  test cmd output 5</span><br><span class="line">test cmd output 4</span><br><span class="line">test cmd output 3</span><br><span class="line">test cmd output 2</span><br><span class="line">test cmd output 1</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>整个过程等待5秒，所有结果一次输出。</p><h3 id="分离标准输出与错误输出"><a href="#分离标准输出与错误输出" class="headerlink" title="分离标准输出与错误输出"></a>分离标准输出与错误输出</h3><p>将错误分开输出，同时开了两个协成，同步的接收命令的输出内容。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 	stdout &amp; stderr 分开输出</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test2</span><span class="params">()</span></span> &#123;</span><br><span class="line">	cmd := exec.Command(<span class="string">"./testcmd/testcmd"</span>, <span class="string">"-s"</span>, <span class="string">"-e"</span>)</span><br><span class="line">	stdout, _ := cmd.StdoutPipe()</span><br><span class="line">	stderr, _ := cmd.StderrPipe()</span><br><span class="line">	cmd.Start()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">1024</span>)</span><br><span class="line">			n, err := stderr.Read(buf)</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> n &gt; <span class="number">0</span> &#123;</span><br><span class="line">				log.Printf(<span class="string">"read err %s"</span>, <span class="keyword">string</span>(buf[:n]))</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				log.Printf(<span class="string">"read err %v"</span>, err)</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">1024</span>)</span><br><span class="line">			n, err := stdout.Read(buf)</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> n &gt; <span class="number">0</span> &#123;</span><br><span class="line">				log.Printf(<span class="string">"read out %s"</span>, <span class="keyword">string</span>(buf[:n]))</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				log.Printf(<span class="string">"read out %v"</span>, err)</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	err := cmd.Wait()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Printf(<span class="string">"cmd wait %v"</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Run Test 2</span><br><span class="line">2019/06/06 18:02:39 read out test cmd output 5</span><br><span class="line">2019/06/06 18:02:40 read out test cmd output 4</span><br><span class="line">2019/06/06 18:02:41 read out test cmd output 3</span><br><span class="line">2019/06/06 18:02:42 read out test cmd output 2</span><br><span class="line">2019/06/06 18:02:43 read out test cmd output 1</span><br><span class="line">2019/06/06 18:02:44 read err a err occur</span><br><span class="line">2019/06/06 18:02:44 cmd wait exit status 1</span><br></pre></td></tr></table></figure><h3 id="按行读取输出内容"><a href="#按行读取输出内容" class="headerlink" title="按行读取输出内容"></a>按行读取输出内容</h3><p>使用<code>bufio</code>按行读取输出内容。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 按行读输出的内容</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test3</span><span class="params">()</span></span> &#123;</span><br><span class="line">	cmd := exec.Command(<span class="string">"./testcmd/testcmd"</span>, <span class="string">"-s"</span>, <span class="string">"-e"</span>)</span><br><span class="line">	stdout, _ := cmd.StdoutPipe()</span><br><span class="line">	stderr, _ := cmd.StderrPipe()</span><br><span class="line">	oReader := bufio.NewReader(stdout)</span><br><span class="line">	eReader := bufio.NewReader(stderr)</span><br><span class="line"></span><br><span class="line">	cmd.Start()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			line, err := oReader.ReadString(<span class="string">'\n'</span>)</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> line != <span class="string">""</span> &#123;</span><br><span class="line">				log.Printf(<span class="string">"read line %s"</span>, line)</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> || line == <span class="string">""</span> &#123;</span><br><span class="line">				log.Printf(<span class="string">"read line err %v"</span>, err)</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			line, err := eReader.ReadString(<span class="string">'\n'</span>)</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> line != <span class="string">""</span> &#123;</span><br><span class="line">				log.Printf(<span class="string">"read err %s"</span>, line)</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> || line == <span class="string">""</span> &#123;</span><br><span class="line">				log.Printf(<span class="string">"read err %v"</span>, err)</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	err := cmd.Wait()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Printf(<span class="string">"cmd wait %v"</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Run Test 3</span><br><span class="line">2019/06/06 18:06:44 read line test cmd output 5</span><br><span class="line">2019/06/06 18:06:45 read line test cmd output 4</span><br><span class="line">2019/06/06 18:06:46 read line test cmd output 3</span><br><span class="line">2019/06/06 18:06:47 read line test cmd output 2</span><br><span class="line">2019/06/06 18:06:48 read line test cmd output 1</span><br><span class="line">2019/06/06 18:06:49 read err a err occur</span><br><span class="line">2019/06/06 18:06:49 cmd wait exit status 1</span><br></pre></td></tr></table></figure><h3 id="设置执行超时时间"><a href="#设置执行超时时间" class="headerlink" title="设置执行超时时间"></a>设置执行超时时间</h3><p>有时候我们要控制命令的执行时间，这是就可以使用上下文去控制了。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过上下文控制超时</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test4</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	ctx, calcel := context.WithTimeout(context.Background(), <span class="number">2</span>*time.Second)</span><br><span class="line">	<span class="keyword">defer</span> calcel()</span><br><span class="line"></span><br><span class="line">	cmd := exec.CommandContext(ctx, <span class="string">"./testcmd/testcmd"</span>, <span class="string">"-s"</span>, <span class="string">"-e"</span>)</span><br><span class="line"></span><br><span class="line">	stdout, _ := cmd.StdoutPipe()</span><br><span class="line">	stderr, _ := cmd.StderrPipe()</span><br><span class="line">	oReader := bufio.NewReader(stdout)</span><br><span class="line">	eReader := bufio.NewReader(stderr)</span><br><span class="line"></span><br><span class="line">	cmd.Start()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			line, err := oReader.ReadString(<span class="string">'\n'</span>)</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> line != <span class="string">""</span> &#123;</span><br><span class="line">				log.Printf(<span class="string">"read line %s"</span>, line)</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> || line == <span class="string">""</span> &#123;</span><br><span class="line">				log.Printf(<span class="string">"read line err %v"</span>, err)</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			line, err := eReader.ReadString(<span class="string">'\n'</span>)</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> line != <span class="string">""</span> &#123;</span><br><span class="line">				log.Printf(<span class="string">"read err %s"</span>, line)</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> || line == <span class="string">""</span> &#123;</span><br><span class="line">				log.Printf(<span class="string">"read err %v"</span>, err)</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	err := cmd.Wait()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Printf(<span class="string">"cmd wait %v"</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Run Test 4</span><br><span class="line">2019/06/06 18:06:49 read line err EOF</span><br><span class="line">2019/06/06 18:06:49 read err EOF</span><br><span class="line">2019/06/06 18:06:49 read line test cmd output 5</span><br><span class="line">2019/06/06 18:06:50 read line test cmd output 4</span><br><span class="line">2019/06/06 18:06:51 read line err EOF</span><br><span class="line">2019/06/06 18:06:51 read err EOF</span><br><span class="line">2019/06/06 18:06:51 cmd wait signal: killed</span><br></pre></td></tr></table></figure><h3 id="持续输入指令，交互模式"><a href="#持续输入指令，交互模式" class="headerlink" title="持续输入指令，交互模式"></a>持续输入指令，交互模式</h3><p>有很多命令支持交互模式，我们进入之后就可以持续的输入一些命令，同时获取输出。如<code>openssl</code>命令。</p><p>下面我们需要进入交换模式，执行输入三个命令，并获取输出。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 持续输入</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test5</span><span class="params">()</span></span> &#123;</span><br><span class="line">	cmd := exec.Command(<span class="string">"openssl"</span>)</span><br><span class="line"></span><br><span class="line">	stdout, _ := cmd.StdoutPipe()</span><br><span class="line">	stderr, _ := cmd.StderrPipe()</span><br><span class="line"></span><br><span class="line">	stdin, _ := cmd.StdinPipe()</span><br><span class="line"></span><br><span class="line">	cmd.Start()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 读</span></span><br><span class="line">	<span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">	wg.Add(<span class="number">3</span>)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">defer</span> wg.Done()</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">1024</span>)</span><br><span class="line">			n, err := stderr.Read(buf)</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> n &gt; <span class="number">0</span> &#123;</span><br><span class="line">				fmt.Println(<span class="keyword">string</span>(buf[:n]))</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				log.Printf(<span class="string">"read err %v"</span>, err)</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">defer</span> wg.Done()</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">1024</span>)</span><br><span class="line">			n, err := stdout.Read(buf)</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> n &gt; <span class="number">0</span> &#123;</span><br><span class="line">				fmt.Println(<span class="keyword">string</span>(buf[:n]))</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				log.Printf(<span class="string">"read out %v"</span>, err)</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 写</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		stdin.Write([]<span class="keyword">byte</span>(<span class="string">"version\n\n"</span>))</span><br><span class="line">		stdin.Write([]<span class="keyword">byte</span>(<span class="string">"ciphers -v\n\n"</span>))</span><br><span class="line">		stdin.Write([]<span class="keyword">byte</span>(<span class="string">"s_client -connect razeencheng.com:443"</span>))</span><br><span class="line">		stdin.Close()</span><br><span class="line">		wg.Done()</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	wg.Wait()</span><br><span class="line">	err := cmd.Wait()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Printf(<span class="string">"cmd wait %v"</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里，我们就用到了<code>stdin</code>标准输入了。输出如下：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Run Test 5</span><br><span class="line"><span class="meta">OpenSSL&gt;</span><span class="bash"> LibreSSL 2.6.5</span></span><br><span class="line"><span class="meta">OpenSSL&gt;</span><span class="bash"> OpenSSL&gt;</span></span><br><span class="line">ECDHE-RSA-AES256-GCM-SHA384 TLSv1.2 Kx=ECDH     Au=RSA  Enc=AESGCM(256) Mac=AEAD</span><br><span class="line">ECDHE-ECDSA-AES256-GCM-SHA384 TLSv1.2 Kx=ECDH     Au=ECDSA Enc=AESGCM(256) Mac=AEAD</span><br><span class="line">ECDHE-RSA-AES256-SHA384 TLSv1.2 Kx=ECDH     Au=RSA  Enc=AES(256)  Mac=SHA384</span><br><span class="line">ECDHE-ECDSA-AES256-SHA384 TLSv1.2 Kx=ECDH     Au=ECDSA Enc=AES(256)  Mac=SHA384</span><br><span class="line">ECDHE-RSA-AES256-SHA    SSLv3 Kx=ECDH     Au=RSA  Enc=AES(256)  Mac=SHA1</span><br><span class="line">ECDHE-ECDSA-AES256-SHA  SSLv3 Kx=ECDH     Au=ECDSA Enc=AES(256)  Mac=SHA1</span><br><span class="line">DHE-RSA-AES256-GCM-SHA384 TLSv1.2 Kx=DH       Au=RSA  Enc=AESGCM(256) Mac=AEAD</span><br><span class="line">DHE-RSA-AES256-SHA256   TLSv1.2 Kx=DH       Au=RSA  Enc=AES(256)  Mac=SHA256</span><br><span class="line">DES-CBC-SHA             SSLv3 Kx=RSA      Au=RSA  Enc=DES(56)   Mac=SHA1</span><br><span class="line">...</span><br><span class="line"><span class="meta">OpenSSL&gt;</span><span class="bash"> OpenSSL&gt;</span></span><br><span class="line">4466583148:error:14004410:SSL routines:CONNECT_CR_SRVR_HELLO:sslv3 alert handshake failure:/BuildRoot/Library/Caches/com.apple.xbs/Sources/libressl/libressl-22.260.1/libressl-2.6/ssl/ssl_pkt.c:1205:SSL alert number 40</span><br><span class="line">4466583148:error:140040E5:SSL routines:CONNECT_CR_SRVR_HELLO:ssl handshake failure:/BuildRoot/Library/Caches/com.apple.xbs/Sources/libressl/libressl-22.260.1/libressl-2.6/ssl/ssl_pkt.c:585:</span><br><span class="line"></span><br><span class="line">CONNECTED(00000005)</span><br><span class="line">---</span><br><span class="line">no peer certificate available</span><br><span class="line">---</span><br><span class="line">No client certificate CA names sent</span><br><span class="line">---</span><br><span class="line">SSL handshake has read 7 bytes and written 0 bytes</span><br><span class="line">---</span><br><span class="line">New, (NONE), Cipher is (NONE)</span><br><span class="line">Secure Renegotiation IS NOT supported</span><br><span class="line">Compression: NONE</span><br><span class="line">Expansion: NONE</span><br><span class="line">No ALPN negotiated</span><br><span class="line">SSL-Session:</span><br><span class="line">    Protocol  : TLSv1.2</span><br><span class="line">    Cipher    : 0000</span><br><span class="line">    Session-ID:</span><br><span class="line">    Session-ID-ctx:</span><br><span class="line">    Master-Key:</span><br><span class="line">    Start Time: 1559815613</span><br><span class="line">    Timeout   : 7200 (sec)</span><br><span class="line">    Verify return code: 0 (ok)</span><br><span class="line">---</span><br></pre></td></tr></table></figure><p>—END—</p>]]></content>
      <categories>
        <category>Go学习笔记</category>
        <category>Go基础</category>
      </categories>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>SSH 免密登陆, SSH Config 配置</title>
    <url>//post/ssh-tips.html</url>
    <content><![CDATA[<p>最近又在捣腾捣腾自己的博客,作死的将阿里云磁盘重置了一下。需要重新配置一个SSH登陆的秘钥，发现忘了该怎么开始，这里整理下一些日常用的SSH相关姿势==。</p><h3 id="SSH是什么"><a href="#SSH是什么" class="headerlink" title="SSH是什么"></a>SSH是什么</h3><p>SSH <em>(Secure Shell)</em> 简单来说就是一种用于计算机之间加密登陆的网络协议。使用SSH协议登陆到另外一台计算机，能有效的保证远程管理过程中的数据安全。</p><a id="more"></a><h3 id="SSH免密登陆"><a href="#SSH免密登陆" class="headerlink" title="SSH免密登陆"></a>SSH免密登陆</h3><h4 id="生成RSA秘钥对"><a href="#生成RSA秘钥对" class="headerlink" title="生成RSA秘钥对"></a>生成RSA秘钥对</h4><p>SSH相关的秘钥一般都存放在<code>~/.ssh</code>目录下面。如果你和我一样<code>~/.ssh</code>目录存在以下的两个文件:</p><ul><li>id_rsa</li><li>id_rsa.pub</li></ul><p>这就说明RSA秘钥对已经有个这个步骤你可以直接跳过。如果没有，继续。<br></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ssh-keygen</span><br><span class="line">Generating public/private rsa key pair.</span><br><span class="line">Enter file <span class="keyword">in</span> <span class="built_in">which</span> to save the key (/Users/xxxx/.ssh/id_rsa):  <span class="comment"># 回车即可</span></span><br><span class="line"><span class="comment"># 如果没有~/.ssh目录 这里会显示Created directory '/root/.ssh'.</span></span><br><span class="line">Enter passphrase (empty <span class="keyword">for</span> no passphrase): <span class="comment"># 输入秘钥密码或回车(如果设置密码以后每次使用私钥都需要输入该密码)</span></span><br><span class="line">Enter same passphrase again: <span class="comment"># 和上一步相同，输入秘钥密码或回车。</span></span><br><span class="line">Your identification has been saved <span class="keyword">in</span> /root/.ssh/id_rsa. <span class="comment"># 私钥文件</span></span><br><span class="line">Your public key has been saved <span class="keyword">in</span> /root/.ssh/id_rsa.pub. <span class="comment"># 公钥文件</span></span><br><span class="line">The key fingerprint is:</span><br><span class="line">SHA256:xxxxxxxxxxxxxxxxxx xxx@xxx.local</span><br><span class="line">The key<span class="string">'s randomart image is:</span></span><br><span class="line"><span class="string">+---[RSA 2048]----+</span></span><br><span class="line"><span class="string">|      .....      |</span></span><br><span class="line"><span class="string">+----[SHA256]-----+</span></span><br></pre></td></tr></table></figure><p></p><p>到这里，秘钥对已经生成。</p><h4 id="在服务器安装授权秘钥"><a href="#在服务器安装授权秘钥" class="headerlink" title="在服务器安装授权秘钥"></a>在服务器安装授权秘钥</h4><p>1.根据公钥生成授权秘钥。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cat ~/.ssh/id_rsa.pub &gt;&gt; authorized_keys</span><br></pre></td></tr></table></figure><p>2.上传授权秘钥到服务器。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ scp authorized_keys root@razeen.me:~ </span><br><span class="line">root@razeen.me<span class="string">'s password:</span></span><br><span class="line"><span class="string">authorized_keys             100%  748    21.5KB/s   00:00</span></span><br></pre></td></tr></table></figure><ol start="3"><li>登陆服务器，配置authorized_keys。</li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ssh root@razeen.me</span><br><span class="line">root@razeen.me&apos;s password:</span><br><span class="line"></span><br><span class="line"># 登陆上去后 我们可以看到刚刚上传的文件</span><br><span class="line">[root@xxxx ~]$ ls</span><br><span class="line">authorized_keys</span><br><span class="line"></span><br><span class="line"># 新建 ~/.ssh目录,将authorized_keys放到该目录下。</span><br><span class="line">[root@xxxx ~]$ mkdir .ssh</span><br><span class="line">[root@xxxx ~]$ mv authorized_keys .ssh/</span><br><span class="line"></span><br><span class="line"># 给秘钥授权</span><br><span class="line">[root@xxxx ~]$ chmod 600 .ssh/authorized_keys</span><br><span class="line">[root@xxxx ~]$ chmod 700 .ssh/</span><br></pre></td></tr></table></figure><p>4.设置SSH，打开密钥登录功能。</p><p>相关的SSH设置，在<code>/etc/ssh/sshd_config</code>文件内。<br></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@xxxx ~]<span class="variable">$vi</span> /etc/ssh/sshd_config</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将下面两行放出</span></span><br><span class="line">RSAAuthentication yes  <span class="comment"># Centos8中过时</span></span><br><span class="line">PubkeyAuthentication yes</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果你和我一样 不想用密码登陆 将这一行改为no</span></span><br><span class="line">PasswordAuthentication no</span><br></pre></td></tr></table></figure><p></p><p>修改完后，保存文件，重启SSH服务。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@xxxx ~]$ service sshd restart</span><br></pre></td></tr></table></figure><p>最后，验证一下。如果和我一样直接登陆成功，恭喜你免密登陆成功了。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ssh root@razeen.me</span><br><span class="line">Last login: Tue Sep 26 21:05:48 2017 from 218.82.26.206</span><br><span class="line"></span><br><span class="line">Welcome to aliyun Elastic Compute Service!</span><br><span class="line"></span><br><span class="line">[root@xxxx ~]<span class="comment">#</span></span><br></pre></td></tr></table></figure><h3 id="修改SSH端口"><a href="#修改SSH端口" class="headerlink" title="修改SSH端口"></a>修改SSH端口</h3><h4 id="修改SSH配置文件"><a href="#修改SSH配置文件" class="headerlink" title="修改SSH配置文件"></a>修改SSH配置文件</h4><p>我们常用的SSH端口是22,为了提高安全性，你可以将其修改到一个不常用的端口。</p><p>同样是修改<code>/etc/ssh/sshd_config</code>文件。<br>我们能看到</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ vi /etc/ssh/sshd_config</span><br><span class="line"></span><br><span class="line">#</span><br><span class="line">#Port 22   </span><br><span class="line">#ListenAddress 0.0.0.0</span><br><span class="line">#ListenAddress ::</span><br><span class="line"></span><br><span class="line"># 例如 修改后</span><br><span class="line">Port 54321</span><br></pre></td></tr></table></figure><p>将Port注释删掉，修改22为你想要的端口号，注意不要与常用的端口后冲突。</p><p>然后重启SSH服务。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ service sshd restart</span><br></pre></td></tr></table></figure><blockquote><p>CentOS8 在你执行上面命令启动会报错，需要申明端口类型。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; semanage port -a -t ssh_port_t -p tcp 54321</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h4 id="放行端口"><a href="#放行端口" class="headerlink" title="放行端口"></a>放行端口</h4><p>当然这还不够,还需放行刚刚修改的SSH端口。</p><h5 id="修改安全组"><a href="#修改安全组" class="headerlink" title="修改安全组"></a>修改安全组</h5><p>我用的阿里云只需要在在安全组规则中的公网入网方向添加该端口范围即可，如下图所示：<br><img data-src="https://st.razeen.cn/img/blog/ssh_change_port.png" alt></p><h5 id="iptable-放行"><a href="#iptable-放行" class="headerlink" title="iptable 放行"></a>iptable 放行</h5><p>如果你用的其他的也许还需修改iptable. 操作如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vi /etc/sysconfig/iptables</span><br><span class="line"></span><br><span class="line"># 默认如下：</span><br><span class="line">-A INPUT -m state --state NEW -m tcp -p tcp --dport 22 -j ACCEPT</span><br><span class="line"></span><br><span class="line"># 修改22为你的SSH端口</span><br><span class="line">-A INPUT -m state --state NEW -m tcp -p tcp --dport 54321 -j ACCEPT</span><br></pre></td></tr></table></figure><h5 id="firewall-放行"><a href="#firewall-放行" class="headerlink" title="firewall 放行"></a>firewall 放行</h5><p>如果你是Centos8, 开启了firewall，那可能需要修改firewall。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 放行端口</span></span><br><span class="line">firewall-cmd --zone=public --add-port=54321/tcp --permanent </span><br><span class="line"><span class="comment"># 重启</span></span><br><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure><p>到这里，端口就愉快的修改完成了。 你可以这么登陆<code>ssh -P 54321 root@xxx</code>,如果你还觉得麻烦，下面还有更简单的方法。</p><h3 id="SSH相关技巧"><a href="#SSH相关技巧" class="headerlink" title="SSH相关技巧"></a>SSH相关技巧</h3><h4 id="别名登陆"><a href="#别名登陆" class="headerlink" title="别名登陆"></a>别名登陆</h4><p>你还在为每次SSH, 要输入长长的用户名而烦恼吗？</p><p>你还在为每次SSH, 要带这长长的参数而烦恼吗？</p><p>你还在为每次SCP, 依然要带这长长的参数而烦恼吗？</p><p>你还在犹豫什么, 别名登陆给你解决烦恼。</p><p>首先你需要在你的<code>~/.ssh</code>目录下添加文件名为<code>config</code>的文件,文件内容如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># config</span><br><span class="line">Host razeen                      # 别名</span><br><span class="line">    HostName razeen.me           # 主机地址 （可以是IP)</span><br><span class="line">    User root                    # 用户名</span><br><span class="line">    Port 54321                   # ssh端口</span><br><span class="line">    # IdentityFile ~/.ssh/id_rsa # 认证文件</span><br></pre></td></tr></table></figure><p>接下来你直接使用<code>$ ssh razeen</code>就可以登陆服务器了,使用<code>scp file.xxx razeen:/xxx/xxx</code>就可你将本地的<code>file.xxx</code>文件拷到服务器<code>/xxx/xxx</code>目录下, 是不是方便了很多。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>[1] <a href="https://deepzz.com/post/how-to-setup-ssh-config.html#toc_4" target="_blank" rel="noopener">https://deepzz.com/post/how-to-setup-ssh-config.html#toc_4</a></p>]]></content>
      <categories>
        <category>Linux 点滴</category>
      </categories>
      <tags>
        <tag>ssh</tag>
      </tags>
  </entry>
  <entry>
    <title>搭建证书透明度(certificate-transparency)日志服务之从入门到放弃</title>
    <url>//post/ssl-build-certificate-transparency.html</url>
    <content><![CDATA[<p>最近在搭建证书透明度日志服务，折腾了几天，最后结果是 “测试完美通关，部署各种出错”。So, 先暂停一段时间，写篇博客记录一下这几天傻傻折腾的过程。</p><p><em>注</em> 后面<code>certificate-transparency</code> 简写为CT。</p><a id="more"></a><h3 id="CT是什么？"><a href="#CT是什么？" class="headerlink" title="CT是什么？"></a>CT是什么？</h3><p>从中文翻译就可看出，证书透明嘛，就是让证书透明化。</p><p>至于各中细节，<a href="https://imququ.com/post/certificate-transparency.html#toc-0" target="_blank" rel="noopener">屈屈有篇博客</a>写的蛮详细的，我就不赘述了。</p><p>当然，<a href="https://www.certificate-transparency.org/what-is-ct" target="_blank" rel="noopener">官方</a>也有更详细的文档说明。</p><h3 id="搭建CT日志服务"><a href="#搭建CT日志服务" class="headerlink" title="搭建CT日志服务"></a>搭建CT日志服务</h3><h4 id="1）Before-搭建"><a href="#1）Before-搭建" class="headerlink" title="1）Before 搭建"></a>1）Before 搭建</h4><p>看完上面的博客或文档，我们知道CT系统的组成有这么三个部分：</p><p>​ 1）Certificate Logs；2）Certificate Monitors；3）Certificate Auditors。</p><p>而我们这里搭建的就是第一部分 Certificate Logs ，也就是我说的CT日志服务。</p><p><a href="https://github.com/google/certificate-transparency" target="_blank" rel="noopener">CT的开源项目</a>除了包含了CT日志服务(ct-server)，还有一个日志的只读服务(ct-mirror)以及一些日志的管理维护日志服务。这里我们主要搭建的是ct-server，当然也会用到一些工具。</p><p>在<a href="https://github.com/google/certificate-transparency/blob/master/docs/Deployment.md" target="_blank" rel="noopener">Deploying a CT Log</a>指明了两种搭建方法，这里我用docker搭建，docker-compose编排。</p><p>其中主要需要的相关服务：</p><ul><li>ct-server (CT日志的主体服务)</li><li>prom (监控服务)</li><li>etcd (数据同步服务)</li></ul><p>就像官方的部署图</p><p><img data-src="https://st.razeen.cn/img/202102/ct/SystemDiagram.png" alt></p><p>拟部署CT三台日志服务，三台etcd组成集群，负载的负载均衡就是后话了。</p><h4 id="2）编译代码"><a href="#2）编译代码" class="headerlink" title="2）编译代码"></a>2）编译代码</h4><p>在构建之前，我们先需要编译代码。这里就得注意一下编译的环境了。由于一开始傻傻的文档都没看，直接在我的Mac(os x 10.13)上编译，结果各种C库问题。</p><p>在文档中已经明确指出：</p><p>The supported platforms are:</p><ul><li><strong>Linux</strong>: tested on Ubuntu 14.04; other variants (Fedora 22, CentOS 7) may require tweaking of <a href="https://github.com/google/certificate-transparency#build-troubleshooting" target="_blank" rel="noopener">compiler options</a>.</li><li><strong>OS X</strong>: version 10.10</li><li><strong>FreeBSD</strong>: version 10.*</li></ul><p>我这里采用的是Ubuntu14.04平台，在docker内编译，Dockerfile如下:</p><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">14.04</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装基本环境</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apt-get update \</span></span><br><span class="line"><span class="bash">        &amp;&amp; apt-get upgrade -y \</span></span><br><span class="line"><span class="bash">        &amp;&amp; apt-get install --no-install-recommends --no-install-suggests -y \</span></span><br><span class="line"><span class="bash">                autoconf \</span></span><br><span class="line"><span class="bash">                automake \</span></span><br><span class="line"><span class="bash">                libtool \</span></span><br><span class="line"><span class="bash">                shtool \</span></span><br><span class="line"><span class="bash">                clang \</span></span><br><span class="line"><span class="bash">                git \</span></span><br><span class="line"><span class="bash">                make \</span></span><br><span class="line"><span class="bash">                tcl \</span></span><br><span class="line"><span class="bash">                pkg-config \</span></span><br><span class="line"><span class="bash">                python \</span></span><br><span class="line"><span class="bash">                curl \</span></span><br><span class="line"><span class="bash">                ca-certificates</span></span><br><span class="line">                </span><br><span class="line"><span class="comment"># 由于depot_tools资源在墙外，docker内下载很慢，我就直接下的COPY进去了</span></span><br><span class="line"><span class="comment"># git clone https://chromium.googlesource.com/chromium/tools/depot_tools.git</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> depot_tools /root/depot_tools</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 由于ubuntu上的cmake版本还停留在 需要手动升级下cmake，同上的原因，我也就copy进来了</span></span><br><span class="line"><span class="comment"># curl http://www.cmake.org/files/v3.4/cmake-3.4.1.tar.gz</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> cmake-3.4.1 /root/cmake-3.4.1</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash">  apt-get install -y build-essential \</span></span><br><span class="line"><span class="bash">        &amp;&amp; <span class="built_in">cd</span> /root/cmake-3.4.1 \</span></span><br><span class="line"><span class="bash">        &amp;&amp; ./configure \</span></span><br><span class="line"><span class="bash">        &amp;&amp; make \</span></span><br><span class="line"><span class="bash">        &amp;&amp; apt-get install -y checkinstall \</span></span><br><span class="line"><span class="bash">        &amp;&amp; checkinstall \</span></span><br><span class="line"><span class="bash">        &amp;&amp; make install \</span></span><br><span class="line"><span class="bash">        &amp;&amp; cmake --version </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /root</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:/root/depot_tools \</span></span><br><span class="line"><span class="bash">        &amp;&amp; <span class="built_in">export</span> CXX=clang++ CC=clang  \</span></span><br><span class="line"><span class="bash">        &amp;&amp; mkdir ct &amp;&amp; <span class="built_in">cd</span> ct \</span></span><br><span class="line"><span class="bash">        &amp;&amp; gclient config --name=<span class="string">"certificate-transparency"</span> https://github.com/google/certificate-transparency.git@master \</span></span><br><span class="line"><span class="bash">        &amp;&amp; gclient sync --<span class="built_in">disable</span>-syntax-validation \</span></span><br><span class="line"><span class="bash">        &amp;&amp; make -C certificate-transparency check</span></span><br></pre></td></tr></table></figure><p>直接<code>docker build -t ctlog .</code></p><p>然后你就可以去喝杯茶了。不出意外，大概1个小时左右，你会看到</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Testsuite summary <span class="keyword">for</span> certificate-transparency 0.9</span><br><span class="line">============================================================================</span><br><span class="line"><span class="comment"># TOTAL: 41</span></span><br><span class="line"><span class="comment"># PASS:  41</span></span><br><span class="line"><span class="comment"># SKIP:  0</span></span><br><span class="line"><span class="comment"># XFAIL: 0</span></span><br><span class="line"><span class="comment"># FAIL:  0</span></span><br><span class="line"><span class="comment"># XPASS: 0</span></span><br><span class="line"><span class="comment"># ERROR: 0</span></span><br><span class="line">============================================================================</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>之后，我们进docker将编译好的文件映射出来即可。</p><p>将<code>ct/certificate-transparency</code> 文件夹拷出后，我们大概可以看到：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># certificate-transparency git:(master) tree</span></span><br><span class="line">.</span><br><span class="line">├── AUTHORS</span><br><span class="line">├── Dockerfile</span><br><span class="line">├── ...</span><br><span class="line">├── cloud</span><br><span class="line">│   ├── etcd</span><br><span class="line">│   │   └── Dockerfile</span><br><span class="line">│   └── prometheus</span><br><span class="line">│       ├── Dockerfile</span><br><span class="line">│       └── prometheus.conf</span><br><span class="line">├── cpp</span><br><span class="line">│   ├── server</span><br><span class="line">│   │   ├── ct-mirror</span><br><span class="line">│   │   ├── ct-server</span><br><span class="line">│   ├── tools</span><br><span class="line">│   │   ├── ct-clustertool</span><br><span class="line">│   │   └── prepare_etcd.sh</span><br><span class="line">└── ...</span><br></pre></td></tr></table></figure><p>这里的<code>ct-server</code>就是我们要的可执行文件了。除了该文件外，我们还需要一些工具，脚本，如：etcd初始化脚本<code>prepare_etcd.sh</code>和CT集群工具<code>ct-clustertool</code>。到这里，我们的编译工作就完成了。</p><h4 id="3）构建与编排"><a href="#3）构建与编排" class="headerlink" title="3）构建与编排"></a>3）构建与编排</h4><p>文档上说的很清楚，编排之前我们还需要一些文件，至于具体需要哪些，我们结合ct-server参数做一个大概了解。</p><ol><li>必须参数<ul><li><code>--key=&lt;pemfile&gt;</code> 秘钥PEM文件，ct日志服务用来加密和签名的。无需密码保护。</li><li><code>--trusted_cert_file=&lt;pemfile&gt;</code> 可信CA PEM文件，你的日志可接收的可信CA。</li><li><code>--leveldb_db=&lt;file&gt;.ldb</code> 日志文件数据库。</li><li><code>--etcd_servers=&lt;host&gt;:&lt;port&gt;,&lt;host&gt;:&lt;port&gt;,...</code> etcd服务。</li><li><code>--server=&lt;hostname&gt;</code> 主机名。（可解析 可路由）</li><li><code>--port=&lt;port&gt;</code> 端口。</li></ul></li><li>可选参数<ul><li><code>-log_dir=&lt;dir&gt;</code> 日志文件夹</li><li><code>--v=&lt;num&gt;</code> 日志输出等级 （像debug一样）</li><li><code>--monitoring=&lt;prometheus|gcm&gt;</code> 监控</li><li><code>--tree_signing_frequency_seconds=&lt;secs&gt;</code> STH树的刷新时间 &lt;&lt; MMD</li><li><code>--guard_window_seconds=&lt;secs&gt;</code> 表示在对日志的新条目进行排序之前要拖延多长时间.</li><li><code>--etcd_delete_concurrency=&lt;num&gt;</code> 表示可以同时删除多少个etcd条目。</li><li><code>--num_http_server_threads=&lt;num&gt;</code> 表示有多少线程用于服务传入的HTTP请求。</li></ul></li></ol><p>从参数可以看出，我们需要</p><p><strong>私钥</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># openssl 生成</span></span><br><span class="line">openssl ecparam -name prime256v1 &gt; privkey.pem <span class="comment"># 生成参数文件</span></span><br><span class="line">openssl ecparam -<span class="keyword">in</span> privkey.pem -genkey -noout &gt;&gt; privkey.pem <span class="comment"># 生成key</span></span><br><span class="line">openssl ec -<span class="keyword">in</span> privkey.pem -noout -text <span class="comment"># 查看key</span></span><br><span class="line">openssl ec -<span class="keyword">in</span> privkey.pem -pubout -out pubkey.pem <span class="comment"># 生成公钥</span></span><br></pre></td></tr></table></figure><p><strong>CA证书</strong></p><p>文档上提供的是从Ubuntn的根证书库拿证书，我们也这么做，不过如果你想向Google提交你的日志服务，你还需要内置一章<a href="https://www.chromium.org/Home/chromium-security/certificate-transparency/log-policy" target="_blank" rel="noopener">Google的测试证书</a>，供Google测试使用。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install -qy ca-certificates</span><br><span class="line">sudo update-ca-certificates</span><br><span class="line">cat /etc/ssl/certs/* &gt; ca-roots.pem</span><br></pre></td></tr></table></figure><p><strong>etcd</strong></p><p>etcd我用的<code>quay.io/coreos/etcd:v3.2.0</code>镜像，用DISCOVERY模式。</p><p><strong>prometheus</strong></p><p>刚开始我也用的是最新版本的prometheus，但当我启动后，发现ct_server中<code>/mertic</code>获取到的数据居然无法兼容，我最后还是用了<code>v1.0.0</code>版。</p><p>在这些都开始后我们就开始构建镜像，编排docker了，相关的Dockerfile及文件我都上传到了我的<a href>GitHub</a>,其中为了方便操作，我用<code>Makefile</code>编排了一下。</p><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">CURRENT_DIR=`pwd`</span><br><span class="line"></span><br><span class="line"><span class="section">help:</span></span><br><span class="line">	@echo <span class="string">"docker build help..."</span></span><br><span class="line">	@docker build -f Dockerfile-help -t ct_help .</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用于日志的key</span></span><br><span class="line"><span class="section">pre_key:</span></span><br><span class="line">	@openssl ecparam -name prime256v1 &gt; server-key.pem  &amp;&amp; \</span><br><span class="line">	    openssl ecparam -in server-key.pem -genkey -noout &gt;&gt; server-key.pem  &amp;&amp; \</span><br><span class="line">	    openssl ec -in server-key.pem -noout -text  &amp;&amp; \</span><br><span class="line">	    openssl ec -in server-key.pem -pubout -out server-pub.pem </span><br><span class="line"></span><br><span class="line"><span class="comment"># 根证书</span></span><br><span class="line"><span class="section">pre_cacerts:</span></span><br><span class="line">	@docker run --rm -v <span class="variable">$(CURRENT_DIR)</span>:/tmp -it ct_help bash -c '\</span><br><span class="line">	    cat /etc/ssl/certs/* /tmp/google_test.pem &gt; /tmp/ca-cert.pem'</span><br><span class="line"></span><br><span class="line"><span class="section">prom:  </span></span><br><span class="line">	@echo <span class="string">"docker build promtheus..."</span></span><br><span class="line">	@docker build -f Dockerfile-prom -t ct_prom .</span><br><span class="line">	</span><br><span class="line"><span class="section">ct_log:</span></span><br><span class="line">	@echo <span class="string">"docker build ct log..."</span></span><br><span class="line">	@docker build -f Dockerfile-log -t ct_log .</span><br><span class="line"></span><br><span class="line"><span class="section">etcd:</span></span><br><span class="line">	@echo <span class="string">"docker build etcd ..."</span></span><br><span class="line">	@docker build -f Dockerfile-etcd -t ct_etcd .</span><br><span class="line">	</span><br><span class="line"><span class="section">up:</span></span><br><span class="line">	@<span class="keyword">export</span> ETCD_DISCOVERY=`curl -s -w <span class="string">"\n"</span> 'https://discovery.etcd.io/new?size=3'` &amp;&amp; \</span><br><span class="line">	    printf <span class="string">"\033[92m[%-14s]\033[0m %s\n"</span> <span class="string">"etcd discovery"</span> $$ETCD_DISCOVERY &amp;&amp; \</span><br><span class="line">	    docker-compose up -d</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动后需要初始化etcd内的内容</span></span><br><span class="line"><span class="section">init_etcd:</span></span><br><span class="line">	@docker run --rm -v <span class="variable">$(CURRENT_DIR)</span>:/tmp \</span><br><span class="line">	    --add-host <span class="string">"etcdhost:192.168.11.65"</span> -t ct_help bash -c '\</span><br><span class="line">	    cd /tmp &amp;&amp; ./prepare_etcd.sh etcdhost 14001 server-key.pem'</span><br><span class="line"></span><br><span class="line"><span class="comment"># 停止</span></span><br><span class="line"><span class="section">down:</span></span><br><span class="line">	@docker-compose down</span><br><span class="line">	</span><br><span class="line"><span class="comment"># 清除日志文件</span></span><br><span class="line"><span class="section">clean_data:</span></span><br><span class="line">	@rm -rf /mnt/data/ct</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试</span></span><br><span class="line"><span class="section">test:</span></span><br><span class="line">	curl -s 127.0.0.1:18081/ct/v1/get-sth </span><br><span class="line">	<span class="comment">#</span></span><br><span class="line">	curl -s 127.0.0.1:18082/ct/v1/get-sth </span><br><span class="line">	<span class="comment">#</span></span><br><span class="line">	curl -s 127.0.0.1:18083/ct/v1/get-sth </span><br><span class="line"></span><br><span class="line"><span class="section">submit:</span></span><br><span class="line">	@docker run --rm -v <span class="variable">$(CURRENT_DIR)</span>:/tmp \</span><br><span class="line">	    --add-host <span class="string">"host:192.168.11.65"</span> -t ct_help bash -c '\</span><br><span class="line">	    cd /tmp &amp;&amp; ./ct-submit host:18081 &lt; test_full_chain.pem &gt; test.sct'</span><br><span class="line"></span><br><span class="line"><span class="section">check_etcd:</span></span><br><span class="line">	curl -s -L http://127.0.0.1:14001/health</span><br><span class="line">	<span class="comment">#</span></span><br><span class="line">	curl -s -L http://127.0.0.1:14002/health</span><br><span class="line">	<span class="comment">#</span></span><br><span class="line">	curl -s -L http://127.0.0.1:14003/health</span><br><span class="line"></span><br><span class="line"><span class="section">pre: help pre_key pre_cacerts</span></span><br><span class="line"></span><br><span class="line"><span class="section">build: prom ct_log etcd</span></span><br><span class="line"></span><br><span class="line"><span class="section">run: up init_etcd</span></span><br></pre></td></tr></table></figure><p>只需要简单的<code>make pre build run</code>你就可以搭建起一个CT日志服务了，不过在此之前不要忘了将<code>Makefile</code>,<code>prometheus.yaml</code>,<code>docker-compose.yaml</code>中的IP改成你的哦。</p><h4 id="4）部署与测试"><a href="#4）部署与测试" class="headerlink" title="4）部署与测试"></a>4）部署与测试</h4><p>其实按照上面操作你已经搭建起了一个CT日志服务。</p><ul><li><code>make pre</code> 准备了一个后面需要的Ubuntu docker，生成秘钥以及根证书。</li><li><code>make build</code> 将需要的容器构建。</li><li><code>make run</code>就是启动以及向ETCD写入一些日志相关的Key以及CT集群的一些初始化工作，具体内容可看<code>prepare_etcd.sh</code>脚本。</li></ul><p>在这之后，<code>make test</code>我们可以看到：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ curl -s 127.0.0.1:18081/ct/v1/get-sth</span><br><span class="line">&#123; <span class="string">"tree_size"</span>: 0, <span class="string">"timestamp"</span>: 1515742224849, <span class="string">"sha256_root_hash"</span>: <span class="string">"47DEQpj8HBSa+\/TImW+5JCeuQeRkm5NMpJWZG3hSuFU="</span>, <span class="string">"tree_head_signature"</span>: <span class="string">"BAMARzBFAiEAimYSepMbRdR5cTCo9OwW3m3w7fQPIuO1L0LPC+7NaUgCIGNcLLwehMMckj\/\/tGAJfEFPOYiWTGuM+jno87XK6RwT"</span> &#125;<span class="comment">#</span></span><br><span class="line">$ curl -s 127.0.0.1:18082/ct/v1/get-sth</span><br><span class="line">&#123; <span class="string">"tree_size"</span>: 0, <span class="string">"timestamp"</span>: 1515742224849, <span class="string">"sha256_root_hash"</span>: <span class="string">"47DEQpj8HBSa+\/TImW+5JCeuQeRkm5NMpJWZG3hSuFU="</span>, <span class="string">"tree_head_signature"</span>: <span class="string">"BAMARzBFAiEAimYSepMbRdR5cTCo9OwW3m3w7fQPIuO1L0LPC+7NaUgCIGNcLLwehMMckj\/\/tGAJfEFPOYiWTGuM+jno87XK6RwT"</span> &#125;<span class="comment">#</span></span><br><span class="line">$ curl -s 127.0.0.1:18083/ct/v1/get-sth</span><br><span class="line">&#123; <span class="string">"tree_size"</span>: 0, <span class="string">"timestamp"</span>: 1515742224849, <span class="string">"sha256_root_hash"</span>: <span class="string">"47DEQpj8HBSa+\/TImW+5JCeuQeRkm5NMpJWZG3hSuFU="</span>, <span class="string">"tree_head_signature"</span>: <span class="string">"BAMARzBFAiEAimYSepMbRdR5cTCo9OwW3m3w7fQPIuO1L0LPC+7NaUgCIGNcLLwehMMckj\/\/tGAJfEFPOYiWTGuM+jno87XK6RwT"</span> &#125;%</span><br></pre></td></tr></table></figure><p>说明第一棵大小为0，时间戳为1515742224849的树已经建好了，CT等着我们去提交了。</p><p>接下来，我们提交一张证书测试一下。</p><p><code>make submit</code> 提交了一张我已经准备好的证书，返回的SCT写入到了test.sct文件。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ xxd test.sct</span><br><span class="line">00000000: 00e8 03a0 42ca d5c6 8b75 dd99 7618 a739  ....B....u..v..9</span><br><span class="line">00000010: b365 a64b 1bc3 4fa3 6f10 1169 dd0b 4c48  .e.K..O.o..i..LH</span><br><span class="line">00000020: 9400 0001 60e9 4672 9f00 0004 0300 4830  ....`.Fr......H0</span><br><span class="line">00000030: 4602 2100 a6c2 3520 9cd0 c5cc 9549 7db3  F.!...5 .....I&#125;.</span><br><span class="line">00000040: 97a1 702a c2f9 8c7c 566d 3f2a 0124 a5c6  ..p*...|Vm?*.$..</span><br><span class="line">00000050: edfa 709a 0221 00da 9fb9 b301 6bf1 873f  ..p..!......k..?</span><br><span class="line">00000060: bc75 7c5a f25c 13f7 f3ad dddd ec5a 017b  .u|Z.\.......Z.&#123;</span><br><span class="line">00000070: 25de 4de2 452f 44                        %.M.E/D</span><br></pre></td></tr></table></figure><p>我们的一张证书已经成功提交到自己CT日志服务。大概在40s之后，也就是<code>--tree_signing_frequency_seconds</code>加上<code>--guard_window_seconds</code>的时间过后，一个新树就生成了。再次<code>make test</code></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ curl -s 127.0.0.1:18081/ct/v1/get-sth</span><br><span class="line">&#123; <span class="string">"tree_size"</span>: 1, <span class="string">"timestamp"</span>: 1515742344849, <span class="string">"sha256_root_hash"</span>: <span class="string">"pI7dv4Bi3dyBvx83s13fuWbNwGQQmafY344Wyf0m7OI="</span>, <span class="string">"tree_head_signature"</span>: <span class="string">"BAMASDBGAiEAmVi6bsH3+NMxaiapBXA80Ygolc1kGLgPAhSMUEXcCzoCIQDdB4YdxH08lmeIZ8DDttjPtm5NtZV8CCNZ1+xyT0d05A=="</span> &#125;<span class="comment">#</span></span><br><span class="line">$ curl -s 127.0.0.1:18082/ct/v1/get-sth</span><br><span class="line">&#123; <span class="string">"tree_size"</span>: 1, <span class="string">"timestamp"</span>: 1515742344849, <span class="string">"sha256_root_hash"</span>: <span class="string">"pI7dv4Bi3dyBvx83s13fuWbNwGQQmafY344Wyf0m7OI="</span>, <span class="string">"tree_head_signature"</span>: <span class="string">"BAMASDBGAiEAmVi6bsH3+NMxaiapBXA80Ygolc1kGLgPAhSMUEXcCzoCIQDdB4YdxH08lmeIZ8DDttjPtm5NtZV8CCNZ1+xyT0d05A=="</span> &#125;<span class="comment">#</span></span><br><span class="line">$ curl -s 127.0.0.1:18083/ct/v1/get-sth</span><br><span class="line">&#123; <span class="string">"tree_size"</span>: 1, <span class="string">"timestamp"</span>: 1515742344849, <span class="string">"sha256_root_hash"</span>: <span class="string">"pI7dv4Bi3dyBvx83s13fuWbNwGQQmafY344Wyf0m7OI="</span>, <span class="string">"tree_head_signature"</span>: <span class="string">"BAMASDBGAiEAmVi6bsH3+NMxaiapBXA80Ygolc1kGLgPAhSMUEXcCzoCIQDdB4YdxH08lmeIZ8DDttjPtm5NtZV8CCNZ1+xyT0d05A=="</span> &#125;%</span><br></pre></td></tr></table></figure><p>这颗 Merkle树已经包含了我提交的证书。</p><p>哦，还漏了一点，我们可以从prometheus看到所有的服务，也可以制造一些数据报表，设置报警规则等。</p><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>一切似乎进展的很顺利，但，当我上云时，问题出现了。</p><p>三台机器，私网全部流量互通，每个机器一个CT已经etcd服务，节点三多跑一个Prometheus服务。当我将一切搭建好后，向其中一个节点提交日志，我们会发现除主简单外，其他两个节点日志打印错误如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">I1228 09:30:09.295418     8 fetcher.cc:225] error fetching entries at index 0: UNKNOWN:</span><br><span class="line">I1228 09:30:09.295658    10 fetcher.cc:225] error fetching entries at index 0: UNKNOWN:</span><br><span class="line">I1228 09:30:09.332808    13 fetcher.cc:225] error fetching entries at index 0: UNKNOWN:</span><br><span class="line">I1228 09:30:09.333170    14 fetcher.cc:225] error fetching entries at index 0: UNKNOWN:</span><br><span class="line">I1228 09:30:09.333434    12 fetcher.cc:225] error fetching entries at index 0: UNKNOWN:</span><br><span class="line">I1228 09:30:09.333684     9 fetcher.cc:225] error fetching entries at index 0: UNKNOWN:</span><br><span class="line">I1228 09:30:09.333931    11 fetcher.cc:225] error fetching entries at index 0: UNKNOWN:</span><br><span class="line">I1228 09:30:09.334175    15 fetcher.cc:225] error fetching entries at index 0: UNKNOWN:</span><br><span class="line">I1228 09:30:09.334420     8 fetcher.cc:225] error fetching entries at index 0: UNKNOWN:</span><br><span class="line">I1228 09:30:09.334666    10 fetcher.cc:225] error fetching entries at index 0: UNKNOWN:</span><br><span class="line">I1228 09:30:09.334946    13 fetcher.cc:225] error fetching entries at index 0: UNKNOWN:</span><br></pre></td></tr></table></figure><p>同时，这两个节点CPU用量会飙升。</p><p>当然，在CT项目的Issues里我们发现了有人遇到了<a href="https://github.com/google/certificate-transparency/issues/1091" target="_blank" rel="noopener">几乎同样的问题</a>。在最后一句大神的回复中，我们或了解到，他们正在开发一个通用的透明化项目<a href="https://github.com/google/trillian" target="_blank" rel="noopener">Trillian</a>，当然该项目不仅仅可以用于证书透明化。借助于Merkle树的快速查询，不可修改等特性未来或许我们会在更多地方看到他。</p><p>这让我想到区块链，想到前几天图大发的一个推</p><p><img data-src="https://st.razeen.cn/img/202102/ct/IMG_4388.jpg" alt></p><p>emmmmm… 扯远了，到这里全部的搭建过程完成了，最后虽未成功，但发现了一个新的方向~</p><p>当然，如果你解决了这个问题，或者发现了我的错误，还望不吝指教~</p>]]></content>
      <categories>
        <category>PKI/CA与数字证书</category>
      </categories>
      <tags>
        <tag>ssl</tag>
        <tag>sth</tag>
        <tag>ct</tag>
      </tags>
  </entry>
  <entry>
    <title>数字证书分类及怎么区分各类数字证书</title>
    <url>//post/ssl-category.html</url>
    <content><![CDATA[<p>在刚开始接触数字证书的时候，我们经常会听到“服务器证书”，“客户端证书”，“邮件证书”等等相关的数字证书名字，这就是数字证书的一种按照用途分类的分类方式。那么数字证书到底有多少类？又是怎么去区分的呢？</p><a id="more"></a><h3 id="几张证书"><a href="#几张证书" class="headerlink" title="几张证书"></a>几张证书</h3><p>下面是我截图的几张证书信息，你知道他们是干什么的，该怎么分类么？<br><img data-src="https://st.razeen.cn/img/202102/https/ssl_category/ssl_category_001.jpg" alt><br><img data-src="https://st.razeen.cn/img/202102/https/ssl_category/ssl_category_002.jpg" alt><br><img data-src="https://st.razeen.cn/img/202102/https/ssl_category/ssl_category_003.jpg" alt></p><p>这里有六张证书：</p><ul><li>1.我的服务器证书；</li><li>2.一张中间证书；</li><li>3.VerSign Class 3 CA证书；</li><li>4.一张邮件证书；</li><li>5.我的iOS app软件签名证书；</li><li>6.我的iOS 推送服务证书。<br>这里你可以看到，我是按照证书的用途分别来介绍这几张证书的，这就是证书分类的一种方式。通常，数字证书可分为两大类：根据持有者分类和根据秘钥分类。</li></ul><h3 id="根据证书持有者分类"><a href="#根据证书持有者分类" class="headerlink" title="根据证书持有者分类"></a>根据证书持有者分类</h3><h4 id="1-根据证书持有者是否为CA进行分类"><a href="#1-根据证书持有者是否为CA进行分类" class="headerlink" title="1.根据证书持有者是否为CA进行分类"></a>1.根据证书持有者是否为CA进行分类</h4><p>根据证书持有者是否为CA，可以将证书分为两类：CA证书和用户证书。CA证书可以为用户或者其他CA签发证书，用户证书则不可以。<br><br>X.509证书格式中通过扩展项BasicConstrains来区分这两类证书。当其中的cA项为TRUE时表示为CA证书，为FALSE时表示用户证书。<br></p><blockquote><p>BasicConstrains扩展项格式用ASN.1描叙如下：<br></p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">BasicConstrains := SEQUENCE &#123;</span><br><span class="line">    cA                  BOOLEAN DEFAULT FALSE</span><br><span class="line">    pathLenConstraint   INTEGER(0..MAX) OPTIONAL    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上图中的证书2，3都是CA证书，查看第二章证书的<a href="http://www.lapo.it/asn1js/#308204A030820388A003020102021025815D93D5C9B8A65E7F367C01D3C3D2300D06092A864886F70D01010B05003081CA310B300906035504061302555331173015060355040A130E566572695369676E2C20496E632E311F301D060355040B1316566572695369676E205472757374204E6574776F726B313A3038060355040B1331286329203230303620566572695369676E2C20496E632E202D20466F7220617574686F72697A656420757365206F6E6C79314530430603550403133C566572695369676E20436C6173732033205075626C6963205072696D6172792043657274696669636174696F6E20417574686F72697479202D204735301E170D3136313231333030303030305A170D3236313231323233353935395A30819B310B300906035504061302434E31253023060355040A131C54727573744173696120546563686E6F6C6F676965732C20496E632E311F301D060355040B131653796D616E746563205472757374204E6574776F726B311D301B060355040B1314446F6D61696E2056616C6964617465642053534C312530230603550403131C547275737441736961204543432044562053534C204341202D2047373059301306072A8648CE3D020106082A8648CE3D03010703420004A5BFB66979DE7B17CECF2585B33AE7D717EB012DCF30ADDC510BE0D37FE54C36E24480E95C98398920A39C47026C13AC57162BEFF9FCE9B33E2247A46A35559BA38201783082017430120603551D130101FF040830060101FF020100302F0603551D1F042830263024A022A020861E687474703A2F2F732E73796D63622E636F6D2F706361332D67352E63726C300E0603551D0F0101FF040403020106302E06082B0601050507010104223020301E06082B060105050730018612687474703A2F2F732E73796D63642E636F6D30610603551D20045A30583056060667810C010201304C302306082B06010505070201161768747470733A2F2F642E73796D63622E636F6D2F637073302506082B0601050507020230191A1768747470733A2F2F642E73796D63622E636F6D2F727061301D0603551D250416301406082B0601050507030106082B06010505070302302B0603551D1104243022A420301E311C301A0603550403131353594D432D4543432D43412D703235362D3431301D0603551D0E04160414DC0E7AAA6FBDD41E0F43485EB3AC6971A83F1D05301F0603551D230418301680147FD365A7C2DDECBBF03009F34339FA02AF333133300D06092A864886F70D01010B050003820101003A7B5F077DF9565E6E345A4E72BEB2CA5E87C08FFAC5BD4A665BFBD5132320EE99019A2CB7F3C69EF46206D043F116401BF15C2F061392E5DA1D5E9646764FC2DF50441393AAC5DBBC494D1D3E2D110634265FE1224BE876FC0E1646CF50B38D7772847636132BE81D4CDE5C2088F3BE755FD2CC74CB018FA46DD93F5090C9AA9D26411E9491AAE02BBE512BFF8058DD99F1E3784BCFD251BE2045B9792622F268B0140FCA1B0549D5640E6AE09691BE1C6A7988025F337BCF78CD6A8AF47D9A029B2331A98533E83F1F35FE075B91A9333AD54AA7BFE6BE7E9E06A554412F3B8C507029D3D5DE0F7BA5B2F627A79FF27DAEDAB1F2B264534191E1F1D2BED5BB" target="_blank" rel="noopener">ANS.1结构</a>我们可以看到</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">OBJECT IDENTIFIER2.5.29.19basicConstraints(X.509 extension)</span><br><span class="line">BOOLEAN     <span class="literal">true</span></span><br><span class="line">OCTET STRING(1 elem)</span><br><span class="line">    SEQUENCE(2 elem)</span><br><span class="line">    BOOLEAN     <span class="literal">true</span>  <span class="comment"># 说明这是一章CA证书</span></span><br><span class="line">    INTEGER     0</span><br></pre></td></tr></table></figure><p>其他几张就是用户证书，可以看到证书1的<a href="http://www.lapo.it/asn1js/#3082043E308203E4A003020102021072F7550E6D99672AD1EC250538F4D602300A06082A8648CE3D04030230819B310B300906035504061302434E31253023060355040A131C54727573744173696120546563686E6F6C6F676965732C20496E632E311F301D060355040B131653796D616E746563205472757374204E6574776F726B311D301B060355040B1314446F6D61696E2056616C6964617465642053534C312530230603550403131C547275737441736961204543432044562053534C204341202D204737301E170D3137303932353030303030305A170D3138303932353233353935395A30143112301006035504030C0972617A65656E2E6D653059301306072A8648CE3D020106082A8648CE3D03010703420004BC577FD5DF058EF84F92C7F26D4632418DF2D5C1D3C2BDB3B278664EC1788CF7FBDCFCA252B3C93E6519E9E379257C9AEB6181305C15DCA049C0B1FB3FBEAB05A382028E3082028A30230603551D11041C301A820972617A65656E2E6D65820D7777772E72617A65656E2E6D6530090603551D130402300030610603551D20045A30583056060667810C010201304C302306082B06010505070201161768747470733A2F2F642E73796D63622E636F6D2F637073302506082B0601050507020230190C1768747470733A2F2F642E73796D63622E636F6D2F727061301F0603551D23041830168014DC0E7AAA6FBDD41E0F43485EB3AC6971A83F1D05300E0603551D0F0101FF040403020780301D0603551D250416301406082B0601050507030106082B0601050507030230819B06082B0601050507010104818E30818B303C06082B060105050730018630687474703A2F2F747275737461736961322D6F6373702E6469676974616C6365727476616C69646174696F6E2E636F6D304B06082B06010505073002863F687474703A2F2F747275737461736961322D6169612E6469676974616C6365727476616C69646174696F6E2E636F6D2F74727573746173696167372E63727430820105060A2B06010401D6790204020481F60481F300F1007700DDEB1D2B7A0D4FA6208B81AD8168707E2E8E9D01D55C888D3D11C4CDB6ECBECC0000015EB9D15B030000040300483046022100F5296FF8FA0B27E80D75FE2BDE0432B7956AC093BEF4D2A48D9C8BBDA35043C7022100AD65A850481236AF6E52E182A594FB5730605416D98B82454217C6F38E3C4091007600A4B90990B418581487BB13A2CC67700A3C359804F91BDFB8E377CD0EC80DDC100000015EB9D15B3B000004030047304502207701DBC14AB10493A1FE14D0896D15FC817A607477624DE8923566614FF1E3A3022100F37E29AE5A8505080A8EB12B4CB6704E83C44FBAA3A9114E363D83C5E9A50FF6300A06082A8648CE3D040302034800304502201FEAEA1D6E586AF9181B46C34B608B9E9E5E4139EC6675FD27743FFFFE39DD22022100CD391D9357DF33E8DA5667D71288C4759BDCDBCAB56A4F07C9FC496FCF16E322" target="_blank" rel="noopener">ASN.1结构</a></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">OBJECT IDENTIFIER2.5.29.19basicConstraints(X.509 extension)</span><br><span class="line">OCTET STRING(1 elem)</span><br><span class="line">    SEQUENCE(0 elem)</span><br></pre></td></tr></table></figure><h4 id="2-按照证书持有者类型进行分类"><a href="#2-按照证书持有者类型进行分类" class="headerlink" title="2.按照证书持有者类型进行分类"></a>2.按照证书持有者类型进行分类</h4><p>根据证书的持有者类型，通常将证书分为几类:个人证书、单位证书和系统证书等。<br></p><p>个人证书是CA系统给个人签发的证书，代表个人身份。证书之中需要包括个人信息（如姓名、身份证、E-mail、电话等）和个人的公钥。就像上图4，5，6三张证书。<br></p><p>单位证书是CA系统给机构或者组织等签发的证书，代表单位身份。证书中需要包含单位信息 （如名称、组织机构代码、E-mail、联系人等）和单位的公钥。这类证书在一些公司或机构的站点很容易看到，如GitHub的证书，在证书中我们可以看到一些其组织公司的信息。<br></p><p>系统证书是CA系统给系统软件或设备系统签发的证书，又代表系统的省份。证书中需要包含系统的信息（如IP地址，域名等）和系统公钥。系统证书又包括Web服务器证书、域控制器证书、VPN设备证书、OCSP服务器证书、时间戳服务器证书等。证书1就是一张系统证书（Web服务器证书）<br></p><p>X.509格式本身并不支持这种分类，通常通过在Subject中增加DN(Distinct Name)项区分，如可以增加OU=PERSON表示个人证书，OU=UNIT表示单位证书等。为保持证书内容的统一性，扩展项KeyUsage、ExtKeyUsage必须设置合适的值。</p><h3 id="根据秘钥分类"><a href="#根据秘钥分类" class="headerlink" title="根据秘钥分类"></a>根据秘钥分类</h3><h4 id="1-根据密钥对产生方式进行分类"><a href="#1-根据密钥对产生方式进行分类" class="headerlink" title="1.根据密钥对产生方式进行分类"></a>1.根据密钥对产生方式进行分类</h4><p>根据秘钥对的产生方式，可将证书分为两类：签名证书和加密证书。<br></p><p>证明签名及私钥只用于签名验签，不能用于加密解密。为了保证密钥对的唯一性，该密钥对必须由用户端密码模块产生和保存，在证书签发过程中CA中心并不知道其私钥，只对其公钥进行操作。<br></p><p>仔细查看上面几张证书，我们就可以通过扩展字段密钥使用 ( 2.5.29.15 )来判断该证书的种类及相关用途。<br></p><p>X.509格式本身并不支持这种分类；通常通过存储位置或者应用系统进行区分。为了保持证书内容的同意性，扩展KeyUsage、ExtKeyUsage必须设置合适的值。<br></p><p>KeyUsage中已经定义的类型如下。</p><ul><li>digitalSignature : 表示数字签名；</li><li>nonRequdiation : 表示不可抵赖；</li><li>keyEncipherment : 表示秘钥加密；</li><li>dataEncipherment : 表示数据加密；</li><li>keyAgreement : 表示秘钥协商；</li><li>keyCertSign: 表示证书签名；</li><li>CRLSign : 表示CRL签名；</li><li>encipherOnly : 表示只用于加密；</li><li>decipherOnly : 表示只用于解密。</li></ul><h4 id="2-根据证书用途进行分类"><a href="#2-根据证书用途进行分类" class="headerlink" title="2.根据证书用途进行分类"></a>2.根据证书用途进行分类</h4><p>根据证书的用途，通常将证书分为SSL服务器证书、SSL客户端证书、代码签名证书、Email证书，时间戳服务器证书、OCSP服务器证书等。</p><p>SSL证书只用于SSL/TLS应用，如证书1，是一张服务器证书，用来保证我的网站与用户连接时的数据安全。</p><p>Email证书只用于安全电子邮件，如证书4,我们通过这个可以验证证书是谁的，保证邮件通讯过程中的安全，不被篡改。</p><p>代码签名证书只用于对代码进行签名验签。如证书5，我写的APP程序在打包时就用该证书的进行签名，用户在安装我的APP时就可以通过该证书知道该APP是谁开发的，用户只有信任了我的证书才可安装。</p><p>X.509格式中通过扩展项ExtKeyUsage来区分这几类证书。为了保持证书内容的统一性，扩展项KeyUsage必须设置合适的值。</p><p>在图中证书信息中扩展项扩展的密钥使用 ( 2.5.29.37 ) 我们就可以看出该证书的相关用途。</p><p>ExtKeyUsage中已经定义的类型如下。</p><ul><li>id-kp-serverAuth ：用于SSL/TLS Web服务器身份认证；</li><li>id-kp-clientAuth ：用于SSL/TLS Web客户端身份认证；</li><li>id-kp-codeSigning : 用于对可下载的执行代码进行签名；</li><li>id-kp-emailProtection ：用于保护E-mail;</li><li>id-kp-timeStamping ： 用于将对象摘要与时间绑定；</li><li>id-kp-OCSPSigning ：用于对OCSP响应包进行签名。</li></ul><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><em>[1] 《PKI/CA与数字证书技术大全》 张明德 刘伟 编著</em></p>]]></content>
      <categories>
        <category>PKI/CA与数字证书</category>
        <category>数字证书</category>
      </categories>
      <tags>
        <tag>ssl</tag>
        <tag>cert</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTPS篇之SSL握手过程详解</title>
    <url>//post/ssl-handshake-detail.html</url>
    <content><![CDATA[<p>​接触HTTPS也有一段时间了，对整个SSL握手的过程零零碎碎的了解了一些，趁着这篇文字系统的总结一下整个SSL握手的过程，结合Wireshark工具让自己更深刻的理解SSL通信过程。</p><a id="more"></a><h3 id="什么是握手"><a href="#什么是握手" class="headerlink" title="什么是握手"></a>什么是握手</h3><p>​像两个人沟通一样，握手是表示一个会话的开始。对于SSL/TLS来说，通过握手建立连接，交换客户端与服务器之间的信息从而生成会话秘钥(主秘钥)，用来加密之后的消息。</p><p>​在TLS中有两种主要的握手类型：一种基于<a href="https://en.wikipedia.org/wiki/RSA_(cryptosystem)" target="_blank" rel="noopener">RSA</a>，一种基于<a href="https://en.wikipedia.org/wiki/Diffie%E2%80%93Hellman_key_exchange" target="_blank" rel="noopener">Diffie-Hellman</a>。 这两种握手类型的主要区别在于主秘钥交换和认证上。</p><table><thead><tr><th></th><th>秘钥交换</th><th>身份验证</th></tr></thead><tbody><tr><td>RSA握手</td><td>RSA</td><td>RSA</td></tr><tr><td>DH握手</td><td>DH</td><td>RSA/DSA</td></tr></tbody></table><p>​用RSA握手还是DH握手取决于加密套件，后面我们也会带你简单了解加密套件。现在，我们用openssl查看套件时可看到</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">➜ openssl ciphers -v</span><br><span class="line">ECDHE-RSA-AES256-GCM-SHA384 	TLSv1.2 Kx=ECDH     Au=RSA  Enc=AESGCM(256) Mac=AEAD</span><br><span class="line">ECDHE-ECDSA-AES256-GCM-SHA384 	TLSv1.2 Kx=ECDH     Au=ECDSA Enc=AESGCM(256) Mac=AEAD</span><br><span class="line">AES256-GCM-SHA384               TLSv1.2 Kx=RSA      Au=RSA  Enc=AESGCM(256) Mac=AEAD</span><br><span class="line">AES256-SHA256                   TLSv1.2 Kx=RSA      Au=RSA  Enc=AES(256)  Mac=SHA256</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>其中kx，au就对应了秘钥交换与身份验证。</p><h3 id="RSA握手"><a href="#RSA握手" class="headerlink" title="RSA握手"></a>RSA握手</h3><p>说了这么多终于踏入正题。</p><p>基于RSA的TLS握手整个流程如下如所示。</p><p><img data-src="https://st.razeen.cn/img/202102/https/ssl-handshake-rsa.png" alt></p><p>通过Wireshark抓包，访问<a href="https://www.razeen.me，我们可以看到" target="_blank" rel="noopener">https://www.razeen.me，我们可以看到</a></p><p><img data-src="https://st.razeen.cn/img/202102/https/ssl_handshake_rsa_shake1.png" alt></p><p>结合上面两个流程图，我们可以了解整个流程可以分解为:</p><ol><li><p>客户端向服务器发送Client Hello,告诉服务器，我支持的协议版本，加密套件等信息。</p></li><li><p>服务器收到响应，选择双方都支持的协议，套件，向客户端发送Server Hello。同时服务器也将自己的证书发送到客户端(Certificate)。</p></li><li><p>客户端自己生产预主密钥，通过公钥加密预主秘钥，将加密后的预主秘钥发送给服务器 (Client Exchange)。</p></li><li><p>服务器用自己的私钥解密加密的预主密钥。</p></li></ol><p>之后，客户端与服务器用相同的算法根据客户端随机数，服务器随机数，预主秘钥生产主密钥，之后的通信将都用主密钥加密解密。</p><p>下面分别带你一一了解其中细节。</p><h4 id="Client-Hello"><a href="#Client-Hello" class="headerlink" title="Client  Hello"></a>Client Hello</h4><p>​点开Client Hello，我们可以看到客户端向服务器发送了哪些数据。</p><p><img data-src="https://st.razeen.cn/img/202102/https/ssl_handshake_rsa_shake_client_hello.png" alt></p><p>​在一次新的握手流程中，Client Hello 消息总数第一条消息。这条消息将客户端的功能和首选项告诉服务器。通过抓包数据，通过其字段名我们也很容易理解它的含义。</p><p><strong>Content Type</strong></p><p>​消息的内容类型，告诉服务器，我要握手了。</p><p><strong>Version</strong></p><p>​协议版本（protocol version) 告诉服务器 客户端支持的最佳协议版本。</p><p><strong>Random</strong></p><p>​随机数，也就是流程图中的客户端随机数。包含32字节的数据，其中28字节是随机生成的(Random Bytes)。剩下的4字节包含额外的信息(GMT Unix Time)，受客户端时钟影响（一般浏览器会给他们的时间添加时钟扭曲，或者简单的发送随机4字节）。在握手的时候这随机数都是独一无二的，他们在身份验证中起到举足轻重的作用（可以防止重复攻击，并确认初始数据交换的完整性）。</p><p><strong>Session ID</strong></p><p>​在第一连接时，会话ID(Session ID)字段是空的，这表示客户端告诉服务器 我是新会话，没有其他会话需要恢复。在后续的连接中，这个字段可以保存会话的唯一标识。服务器可以借助会话ID在自己的缓存中找到对应的会话状态。</p><p>​典型的会话ID包含32字节的随机生成的数据，这些数据本身并没有什么价值。</p><p><strong>Cipher Suites</strong></p><p>​密码套件块是由客户端支持的所有密码套件组成的列表，该列表是按优先级顺序排列的。</p><p>​密码套件(cipher suite)是一组选定的加密基元和其他参数，它可以精确定义如何实现安全。套件大致由以下这些属性定义。</p><ul><li>身份验证方法</li><li>密钥交换方法</li><li>加密算法</li><li>加密密钥大小</li><li>密码模式（可应用时）</li><li>MAC算法（可应用时）</li><li>PRF（只有TLS1.2一定使用，其他版本取决于各自协议）</li><li>用于Finished消息的散列函数（TLS1.2）</li><li>verify_data结构的长度（TLS1.2)</li></ul><p>密码套件都倾向于使用较长的描述名称，并且相当一致：它们都是由密钥交换方法、身份验证方法、密码定义以及可选的MAC或PRF算法组合而成，如下图所示：</p><p><img data-src="https://st.razeen.cn/img/202102/https/ssl-handshake-ciphers.png" alt></p><p><strong>Compression</strong></p><p>​客户端可以提交一个或多个支持的压缩方法。默认是null，代表没有压缩。</p><p><strong>Extensions</strong></p><p>​扩展块由任意数量的扩展组成。这些扩展会携带额外的数据。扩展可以在不修改协议本身的条件下为TLS协议增加功能。如果你想了解更多可以参考<a href="https://tools.ietf.org/html/rfc6066" target="_blank" rel="noopener">RFC 6066</a>，这里不多说。</p><h4 id="Server-Hello"><a href="#Server-Hello" class="headerlink" title="Server Hello"></a>Server Hello</h4><p>​当服务器收到客户端的hello消息的时候，服务器会将服务器选择的参数传送回客户端。这个消息的结构与Client Hello类似，只是每个字段只包含一个选项。</p><p>​服务器不需要支持客户端支持的最佳版本。如果服务器不支持与客户端相同的版本，可以提供某个其他版本以期待客户端能够接受。</p><p><img data-src="https://st.razeen.cn/img/202102/https/ssl_handshake_rsa_shake_server_hello.png" alt></p><p>如上图所示，服务端选择使用TLS 1.2 (version)，套件使用TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256。</p><h4 id="Certificate"><a href="#Certificate" class="headerlink" title="Certificate"></a>Certificate</h4><p>​从下图可以看出在服务器发送Server Hello的时候，会同时发送Certificate,Server Hello Done。</p><p><img data-src="https://st.razeen.cn/img/202102/https/ssl_handshake_rsa_cert.png" alt></p><p><strong>Certificate</strong></p><p>​典型的Certificate消息用于携带X.509证书链。证书链是以ASN.1 DER编码的一系列证书，一个接一个组合而成。叶子证书必须是第一个发送，中间证书按照正确的顺序跟在叶子证书之后。根证书可以并且应该省略掉，因为在这个场景中它没有用处。</p><p>​服务器必须保证它发送的证书与选择的算法套件一致。比方说，公钥算法与套件中使用的必须匹配。除此以外，一些密钥交换算法依赖嵌入证书的特定数据，而且要求证书必须以客户端支持的算法签名。所有这些都表明服务器需要配置多个证书(每个证书可能会配备不同的证书链)。</p><p><strong>Server Hello Done</strong></p><p>​Sever Hello Done 消息表明服务器已经将所有预计的握手消息发送完毕。在此之后，服务器会等待客户端发送消息。</p><h4 id="Client-Key-Exchange"><a href="#Client-Key-Exchange" class="headerlink" title="Client Key Exchange"></a>Client Key Exchange</h4><p>​之后客户端向服务器发送Client Key Exchange。最后客户端与服务器互发 Change Cipher Spec，Encrypted Handshake Message。</p><p><img data-src="https://st.razeen.cn/img/202102/https/ssl_handshake_rsa_shake_exchange.png" alt></p><p><strong>Client Key Exchange</strong></p><p>​Client Key Exchange 消息携带客户端为密钥交换提供的所有信息。从抓包的信息中我们可以看到，秘钥交换的主要内容是RSA Encrypted PreMaster Secret, 也就是利用证书公钥加密后的预主密钥。其中预主密钥(PreMaster Secret)是由客户端生成的48字节的随机数，<a href="https://tools.ietf.org/html/rfc5246#page-58" target="_blank" rel="noopener">RFC5426</a>可看到其结构是这样的。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">struct &#123;</span><br><span class="line">	    ProtocolVersion client_version;</span><br><span class="line">        opaque random[46];</span><br><span class="line">&#125; PreMasterSecret;</span><br></pre></td></tr></table></figure><p><strong>Change Cipher Spec</strong></p><p>​Change Cipher Spec 消息表明发送端已取得用以生成连接参数的足够信息，已生成加密密钥(主密钥)，并且将切换到加密模式。客户端和服务器在条件成熟是会发送这个消息。</p><p>​主密钥的是由预主密钥进一步计算而成，这个过程通过一个伪随机函数(pseudorandom function, PRF)来完成，这个函数可以生产任意数量的伪随机数据。其计算过程如下。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">master_secret = PRF(pre_master_secret,&quot;master secret&quot;,ClientHello.random+ServerHello.random)</span><br></pre></td></tr></table></figure><h4 id="Finished（Encrypted-Handshake-Message）"><a href="#Finished（Encrypted-Handshake-Message）" class="headerlink" title="Finished（Encrypted Handshake Message）"></a>Finished（Encrypted Handshake Message）</h4><p>​Encrypted Handshake Message 这是由客户端服务器之间协商的算法和密钥保护的第一个消息。它意味着握手已经完成。消息内容将加密，以便双发可以安全地交换验证整个握手完整性所需要的数据。</p><p><img data-src="https://st.razeen.cn/img/202102/https/ssl_handshake_rsa_shake_data.png" alt></p><p>​这个消息包含verify_data字段，它的值是握手过程中所有消息的散列值。这些消息在连接两端都按照各自所见的顺序排列，并以协商新得到的主密钥计算散列。散列函数与PRF一致，除非协商的套件指定使用其他算法。</p><p>​客户端与服务器的计算方法一致。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">verify_data = PRF(master_secret,finished_label,Hash(handshake_messages))</span><br></pre></td></tr></table></figure><p>​</p><h3 id="DH握手"><a href="#DH握手" class="headerlink" title="DH握手"></a>DH握手</h3><p>​下图为TLS握手采用DH算法的流程图。与RSA最大的区别在于密钥交换与身份认证上。在RSA中是由客户端发送客户端密钥交换信息完成密钥交换，通过客户端公钥加密，服务端私钥解密完成身份认证。而在DH握手过程中则略有不同。</p><p><img data-src="https://st.razeen.cn/img/202102/https/ssl-handshake-dh.png" alt></p><p>​下图是我访问<a href="https://razeen.me" target="_blank" rel="noopener">https://razeen.me</a> 用Wireshake抓取的数据。</p><p><img data-src="https://st.razeen.cn/img/202102/https/ssl_handshake_dh_shake1.png" alt></p><p>我们从两个图中可以看出，在DH握手过程中，多了一步Server Key Exchange。Server Key Exchange消息的目的与Client Key Exchange目的相同，都是携带密钥交换的额外数据。而在这里它带的不再是加密的预主密钥了。</p><p>也就是说它的整个流程如下：</p><ol><li><p>客户端向服务器发送Client Hello,告诉服务器，我支持的协议版本，加密套件等信息。</p></li><li><p>a. 服务端收到响应，选择双方都支持的协议，套件，向客户端发送Server Hello。同时服务器也将自己的证书发送到客户端(Certificate)。</p><p>b. 服务器利用私钥将客户端随机数，服务器随机数，服务器DH参数签名，生成服务器签名。</p></li><li><p>服务端向客户端发送服务器DH参数以及服务器签名(Server Key Exchange)。</p></li><li><p>客户端向服务端发送客户端DH参数(Client Key Exchange)。</p></li></ol><p>之后，客户端利用公钥验证服务器签名，客户端与服务器各自利用服务端DH参数、客户端DH参数生成预主密钥，再通过预主密钥、客户端随机数、服务端随机数生成主密钥(会话密钥)。最后握手完成，所有的消息都通过主密钥加密。</p><p>​由于DH握手过程中大部分消息格式与RSA相同，这里不再一一说明。这里主要说明一下DH的密钥交换。</p><h4 id="DH密钥交换"><a href="#DH密钥交换" class="headerlink" title="DH密钥交换"></a>DH密钥交换</h4><p><img data-src="https://st.razeen.cn/img/202102/https/ssl_handshake_dh_shake_exchange.png" alt></p><p><img data-src="https://st.razeen.cn/img/202102/https/ssl_handshake_dh_shake_exchange2.png" alt></p><p>​在DH密钥交换过程中主要需要的参数有6个，其中两个(dh_p和dh_g)成为域参数，由服务器选取。协商过程中，客户端和服务器各自生成另外两个参数，相互发送其中一个参数（dh_Ys和dh_Yc)到对端，经过计算，获得预主共享密钥(PreMasterSecret)，我们可以先看一下DH算法的数学基础。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+--------------------------------------------------------------------+</span><br><span class="line">|                    Global Pulic Elements                           |</span><br><span class="line">|                                                                    |</span><br><span class="line">|       dh_p                         prime number                    |</span><br><span class="line">|       dh_g                         prime number, dh_g &lt; dh_p       |</span><br><span class="line">+--------------------------------------------------------------------+</span><br><span class="line">+--------------------------------------------------------------------+</span><br><span class="line">|                    User A Key Generation                           |</span><br><span class="line">|                                                                    |</span><br><span class="line">|       Select private dh_Ys_a       sh_Ys_a &lt; dh_p                  |</span><br><span class="line">|       Calculate public dh_Yc_a     dh_Yc_a = dh_g^dh_Ys_a mod dh_p |</span><br><span class="line">+--------------------------------------------------------------------+</span><br><span class="line">+--------------------------------------------------------------------+</span><br><span class="line">|                    User B Key Generation                           |</span><br><span class="line">|                                                                    |</span><br><span class="line">|       Select private dh_Ys_b       sh_Ys_b &lt; dh_p                  |</span><br><span class="line">|       Calculate public dh_Yc_b     dh_Yc_b = dh_g^dh_Ys_b mod dh_p |</span><br><span class="line">+--------------------------------------------------------------------+</span><br><span class="line">+--------------------------------------------------------------------+</span><br><span class="line">|               Calculation of Secret Key by User A                  |</span><br><span class="line">|                                                                    |</span><br><span class="line">|       Secret Key premaster       premaster = dh_Yc_b^dh_Yc_a mod p |</span><br><span class="line">+--------------------------------------------------------------------+</span><br><span class="line">+--------------------------------------------------------------------+</span><br><span class="line">|               Calculation of Secret Key by User B                  |</span><br><span class="line">|                                                                    |</span><br><span class="line">|       Secret Key premaster       premaster = dh_Yc_a^dh_Yc_b mod p |</span><br><span class="line">+--------------------------------------------------------------------+</span><br></pre></td></tr></table></figure><p>上面一共出现了 dh_p, dh_g, dh_Ys_a, dh_Yc_a, dh_Ys_a, dh_Yc_a, premaster 共 7 个数，其中：</p><ul><li>公开的数：dh_p, dh_g, dh_Yc_a, dh_Yc_a</li><li>非公开数：dh_Ys_a, dh_Ys_b, premaster</li></ul><p>通常情况下，dg_g 一般为 2 或 5，而 dh_p, dh_Ys_a 和 dh_Ys_b 的取值也非常大，其复杂度至少为 <code>O(dh_p^0.5)</code>。对于攻击者来说，已知 dh_Yc_a，dh_Ys_a 的求解非常困难，同理 dh_Ys_b 的求解也很困难，所以攻击者难以求出 premaster，所以 DH 能够保证通信双方在透明的信道中安全的交换密钥。</p><p>​在上面的介绍中你也知道，如果其中的域参数太弱，将很容易被攻破，正如2015年披露的Logjam攻击表明，512位的DH参数在使用合适的资源情况下可以被攻击者在很短的时间内成功利用。对于这些问题随后有了椭圆曲线的DH秘钥交换(ECDH),ECDH密钥交换发生在一条服务器定义的特殊椭圆曲线上，这条曲线代替了DH中的域参数，从而一定程度上提高了安全性。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>​到这里你理清整个握手过程了么。其实整个过程无非就是在互相交换信息，而基于RSA算法与DH算法的握手最大的区别就在于密钥交换与身份认证。前者利用客户端利用公钥加密预主密钥发送给服务端完成密钥交换，服务端利用私钥解密完成身份认证。后者利用各自发送DH参数完成密钥交换，服务器私钥签名数据，客户端公钥验签完成身份认证。</p><p>​好了就写到这里，文章中如果有错漏之处还请不吝赐教哦~</p><p>​最后，今天也是2018年的第一天，祝大家新年快乐。</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><em>1.</em> HTTPS 权威指南</p><p><em>2.</em><a href="http://blog.syscallx.com/2017/02/21/ssl-perfect-forward-secrecy.html" target="_blank" rel="noopener">SSL/TLS Perfect Forward Secrecy</a></p><p><em>3.</em><a href="https://blog.cloudflare.com/keyless-ssl-the-nitty-gritty-technical-details/" target="_blank" rel="noopener">Keyless SSL: The Nitty Gritty Technical Details</a></p><p><em>4.</em><a href="https://blog.cloudflare.com/announcing-keyless-ssl-all-the-benefits-of-cloudflare-without-having-to-turn-over-your-private-ssl-keys/" target="_blank" rel="noopener">Announcing Keyless SSL™: All the Benefits of CloudFlare Without Having to Turn Over Your Private SSL Keys</a></p>]]></content>
      <categories>
        <category>PKI/CA与数字证书</category>
        <category>数字证书</category>
      </categories>
      <tags>
        <tag>https</tag>
        <tag>handshake</tag>
      </tags>
  </entry>
  <entry>
    <title>IPFS 初体验，利用 IPFS 托管你的静态网站</title>
    <url>//post/start-ipfs-gateway.html</url>
    <content><![CDATA[<p>首先，我们需要知道IPFS是什么？</p><p>其实IPFS是一种协议，全称为<code>Inter-Planetary File System</code>，是一种点对点超媒体协议，旨在取代旧的HTTP，使网络更快，更安全，更开放。</p><a id="more"></a><p>我们平常都通过HTTP协议去访问一个网站，我们都知道在我们敲出一个网站后，我们实际上通过这个网址找了了服务器的IP，然后通过IP我们和服务器建立通信。而这种通信的稳定性它取决于对方服务是否可靠，万一挂了，我们肯定无法访问。同时还取决于我们的主干网络是不是通畅，如果那个地方主干网的光纤一不小心被挖断了，那可能导致某个服务就得挂一段时间了。</p><p>这也就是我们所说的HTTP趋于超中心化可能存在的隐患。而IPFS就是用来解决这些问题。IPFS让每一个人都可以成为一个服务节点，一旦你上传一个文件到IPFS，你的文件将会被存储在不同的节点，然后你会得到一个由文件内容计算出的加密哈希值。当你通过该哈希值下载你的文件时，IPFS会会使用一个分布式哈希表找到文件所在的节点，取回文件并验证文件数据。这样，就实现了一个分布式的服务节点，既是你自己的节点挂了，你的文件依然可以正常访问。</p><p>这篇文章，我们一起通过IPFS搭建一个<a href="https://ipfs.netcj.com" target="_blank" rel="noopener">简单页面</a>。</p><h3 id="安装IPFS"><a href="#安装IPFS" class="headerlink" title="安装IPFS"></a>安装IPFS</h3><p>首先，我们需要安装IPFS。</p><p>在<a href="https://dist.ipfs.io/#go-ipfs" target="_blank" rel="noopener">这里</a>找到适合你的平台的安装文件，下载。</p><p>然后解压，安装。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ tar -zxvf go-ipfs_v0.4.18_darwin-amd64.tar.gz</span><br><span class="line">$ <span class="built_in">cd</span> go-ipfs</span><br><span class="line">$ ./install.sh</span><br></pre></td></tr></table></figure><p>查看是否安装完成。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ipfs --<span class="built_in">help</span></span><br><span class="line">USAGE:</span><br><span class="line"></span><br><span class="line">    ipfs - Global p2p merkle-dag filesystem.</span><br></pre></td></tr></table></figure><p>这样，们就安装好了<code>ipfs</code>命令。之后，我们初始化一下。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ipfs init</span><br><span class="line">initializing IPFS node at /Users/jin/.ipfs</span><br><span class="line">generating 2048-bit RSA keypair...done</span><br><span class="line">peer identity: QmQfPXYpcKWim9yQRhbZxxrgUve5VzHJD7h4miu2oQ6Ubj</span><br><span class="line">to get started, enter:</span><br><span class="line"></span><br><span class="line">	ipfs cat /ipfs/QmS4ustL54uo8FzR9455qaxZwuMiUhyvMcX9Ba8nUH4uVv/readme</span><br></pre></td></tr></table></figure><p>初始化的过程中，生成了一个公私钥对，正是通过该公钥来标识我们的身份。</p><p>看看readme都写了些啥。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ipfs cat /ipfs/QmS4ustL54uo8FzR9455qaxZwuMiUhyvMcX9Ba8nUH4uVv/readme</span><br><span class="line">Hello and Welcome to IPFS!</span><br><span class="line"></span><br><span class="line">██╗██████╗ ███████╗███████╗</span><br><span class="line">██║██╔══██╗██╔════╝██╔════╝</span><br><span class="line">██║██████╔╝█████╗  ███████╗</span><br><span class="line">██║██╔═══╝ ██╔══╝  ╚════██║</span><br><span class="line">██║██║     ██║     ███████║</span><br><span class="line">╚═╝╚═╝     ╚═╝     ╚══════╝</span><br><span class="line"></span><br><span class="line">If you<span class="string">'re seeing this, you have successfully installed</span></span><br><span class="line"><span class="string">IPFS and are now interfacing with the ipfs merkledag!</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"> -------------------------------------------------------</span></span><br><span class="line"><span class="string">| Warning:                                              |</span></span><br><span class="line"><span class="string">|   This is alpha software. Use at your own discretion! |</span></span><br><span class="line"><span class="string">|   Much is missing or lacking polish. There are bugs.  |</span></span><br><span class="line"><span class="string">|   Not yet secure. Read the security notes for more.   |</span></span><br><span class="line"><span class="string"> -------------------------------------------------------</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Check out some of the other files in this directory:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  ./about</span></span><br><span class="line"><span class="string">  ./help</span></span><br><span class="line"><span class="string">  ./quick-start     &lt;-- usage examples</span></span><br><span class="line"><span class="string">  ./readme          &lt;-- this file</span></span><br><span class="line"><span class="string">  ./security-notes</span></span><br></pre></td></tr></table></figure><p>这里有一些帮助文档，你可以先了解一下。</p><p>如<code>ipfs cat /ipfs/QmS4ustL54uo8FzR9455qaxZwuMiUhyvMcX9Ba8nUH4uVv/quick-start</code>就可以查看<code>quick-start</code>。</p><h3 id="准备一个简单的网页"><a href="#准备一个简单的网页" class="headerlink" title="准备一个简单的网页"></a>准备一个简单的网页</h3><p>接下来，我们准备一个简单的页面。</p><ul><li>文件 <code>ipfs_file/index.html</code></li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">type</span>=<span class="string">"text/css"</span> <span class="attr">href</span>=<span class="string">"styles.css"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello World<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span> 我的IPFS<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"https://razeen.me/post/start-ipfs-gateway.html#toc_0"</span>&gt;</span> Back <span class="tag">&lt;/<span class="name">a</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>文件 <code>ipfs_file/styles.css</code></li></ul><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#ccc</span>;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">    <span class="attribute">margin-top</span>: <span class="number">88px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="启动IPFS服务"><a href="#启动IPFS服务" class="headerlink" title="启动IPFS服务"></a>启动IPFS服务</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ipfs daemon</span><br><span class="line">Initializing daemon...</span><br><span class="line">Successfully raised file descriptor limit to 2048.</span><br><span class="line">Swarm listening on /ip4/127.0.0.1/tcp/4001</span><br><span class="line">Swarm listening on /ip4/192.168.3.16/tcp/4001</span><br><span class="line">Swarm listening on /ip6/::1/tcp/4001</span><br><span class="line">Swarm listening on /p2p-circuit/ipfs/QmQfPXYpcKWim9yQRhbZxxrgUve5VzHJD7h4miu2oQ6Ubj</span><br><span class="line">Swarm announcing /ip4/127.0.0.1/tcp/4001</span><br><span class="line">Swarm announcing /ip4/192.168.3.16/tcp/4001</span><br><span class="line">Swarm announcing /ip6/::1/tcp/4001</span><br><span class="line">API server listening on /ip4/127.0.0.1/tcp/5001</span><br><span class="line">Gateway (readonly) server listening on /ip4/127.0.0.1/tcp/8080</span><br><span class="line">Daemon is ready</span><br></pre></td></tr></table></figure><p>如果你查看了<code>quick-start</code>你应该知道，我们可以通过浏览器来查看一些UI界面，视频等。</p><p>如，通过<code>http://localhost:5001/webui</code>,我们可以查看我们刚刚启动的这个IPFS的一些节点情况。</p><p><img data-src="https://st.razeen.cn/img/201901/jietu20190102-195825.png" alt></p><p>我们还可以看到我们连接了多少节点以及大概分布。</p><p><img data-src="https://st.razeen.cn/img/201901/jietu20190102-195908.png" alt></p><p>当然还可以查找文件等，这里就不一一说了。</p><h3 id="上传文件"><a href="#上传文件" class="headerlink" title="上传文件"></a>上传文件</h3><p>然后我们可以通过<code>add</code>将文件上传。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ipfs add -r ipfs_file</span><br><span class="line">added QmYN1vzHWT4U61R6GnnJ2H3N76DpZ4JU4xa3r8paDfDdEB ipfs_file/index.html</span><br><span class="line">added Qmea1q1nEPxCsB8y5so2ppNVuKy2kMtFCiBnngiK7A4PY3 ipfs_file/styles.css</span><br><span class="line">added QmSwtxZ5NzJ4cLEm9SX1oeAwcBYevfvb6nhYweXYNSXnNC ipfs_file</span><br><span class="line"> 333 B / 333 B [==============================================   ] 100.00</span><br></pre></td></tr></table></figure><p>然后，我们通过IPFS网关访问<a href="https://gateway.ipfs.io/ipfs/QmSwtxZ5NzJ4cLEm9SX1oeAwcBYevfvb6nhYweXYNSXnNC" target="_blank" rel="noopener"><code>https://gateway.ipfs.io/ipfs/QmSwtxZ5NzJ4cLEm9SX1oeAwcBYevfvb6nhYweXYNSXnNC/</code></a> 就可以访问刚刚的文件了。</p><p><img data-src="https://st.razeen.cn/img/201901/jietu20190102-194755.png" alt></p><p><em>由于防火墙的关系，这里需要用梯子才能访问到==</em></p><h3 id="Cloudflare-IPFS-gateway"><a href="#Cloudflare-IPFS-gateway" class="headerlink" title="Cloudflare IPFS gateway"></a>Cloudflare IPFS gateway</h3><p>最近发现Cloudflare也推出了ipfs网关，而且我们可以将自己的域名解析到该地址，通过TXT记录来关联你的IPFS文件。</p><h4 id="访问"><a href="#访问" class="headerlink" title="访问"></a>访问</h4><p>首先，我们可以通过<a href="https://cloudflare-ipfs.com/ipfs/QmSwtxZ5NzJ4cLEm9SX1oeAwcBYevfvb6nhYweXYNSXnNC/" target="_blank" rel="noopener"><code>https://cloudflare-ipfs.com/ipfs/QmSwtxZ5NzJ4cLEm9SX1oeAwcBYevfvb6nhYweXYNSXnNC/</code></a> 访问刚刚上传的文件。</p><h4 id="添加DNS记录"><a href="#添加DNS记录" class="headerlink" title="添加DNS记录"></a>添加DNS记录</h4><p>然后，我么在我们的DNS服务商中添加两条记录，如下。</p><p>我希望将<code>ipfs.razeen.me</code>指向该文件，然后我需要添加如下记录：</p><p><img data-src="https://st.razeen.cn/img/201901/jietu20190102-195610.png" alt></p><p>也就是，将<code>ipfs.razeen.me</code> CNAME到<code>cloudflare-ipfs.com</code>;<br>添加<code>_dnslink.ipfs</code>TXT值<code>your_ipfs_hash_here</code> 如：<code>QmSwtxZ5NzJ4cLEm9SX1oeAwcBYevfvb6nhYweXYNSXnNC</code>。</p><h4 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h4><p>然后，在<a href="https://www.cloudflare.com/distributed-web-gateway/#connectingyourwebsite" target="_blank" rel="noopener">这里</a>填上你的域名，提交即可。</p><p>之后，cloudflare会为你的域名申请一张证书，并完成转发, 整个过程可能需要10分钟左右。</p><p>当你看到<code>Certificate is live.</code>提示，域名配置就完成了。</p><p><a href="https://ipfs.razeen.me" target="_blank" rel="noopener">访问一下</a>，我们可以看到。</p><p><img data-src="https://st.razeen.cn/img/201901/jietu20190102-200404.png" alt></p><p>到这里我们就完成该网页配置了。一个IPFS站点就搭建完成了。</p>]]></content>
      <categories>
        <category>默认</category>
        <category>瞎折腾</category>
      </categories>
      <tags>
        <tag>ipfs</tag>
        <tag>gateway</tag>
      </tags>
  </entry>
  <entry>
    <title>开始使用Ghost</title>
    <url>//post/start-use-ghost.html</url>
    <content><![CDATA[<p>总想有点地方写一些杂碎的东西，今天抽了一会功夫搭了个ghost博客。我会在这里写一些比较零碎的学习笔记之类的东西。我们首先说一下该博客的搭建过程。</p><p>其实ghost搭建起来很简单，一个docker-compose.yaml文件就解决了。也正是由于它的简单，搭建起来不费时间，后台写博客方便等等，我才使用它。 话不多说 ，我们开始。</p><a id="more"></a><h3 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h3><ul><li>ghost + docker</li><li>nginx</li><li>七牛</li><li>disqus</li></ul><h3 id="Ghost"><a href="#Ghost" class="headerlink" title="Ghost"></a>Ghost</h3><p>我是使用<code>docker-compose</code>运行ghost的，所以你首先需要安装<code>docker</code>以及<code>docker-compose</code>. 至于<code>docker</code>以及<code>docker-compose</code>怎么安装，这里就不说了，自行Google。</p><p>我的docker-compose是这么写得：</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'3'</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">    <span class="attr">ghost:</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">ghost:2.0.3-alpine</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">"2368:2368"</span></span><br><span class="line">        <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">        <span class="attr">volumes:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">./content:/var/lib/ghost/content</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">./config.production.json:/var/lib/ghost/config.production.json</span></span><br><span class="line">        <span class="attr">environment:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">url=https://netcj.com</span></span><br><span class="line">        <span class="attr">ulimits:</span></span><br><span class="line">            <span class="attr">nofile:</span> <span class="number">65535</span></span><br></pre></td></tr></table></figure><p>直接<code>docker-compose up -d</code> 即可启动一个ghost服务。</p><p>你一定注意到一点，容器卷中，我将容器的配置<code>config.production.json</code>暴露出来了。该文件基本内容如下：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"url"</span>: <span class="string">"http://netcj.com"</span>,</span><br><span class="line">  <span class="attr">"server"</span>: &#123;</span><br><span class="line">    <span class="attr">"port"</span>: <span class="number">2368</span>,</span><br><span class="line">    <span class="attr">"host"</span>: <span class="string">"0.0.0.0"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"database"</span>: &#123;</span><br><span class="line">    <span class="attr">"client"</span>: <span class="string">"sqlite3"</span>,</span><br><span class="line">    <span class="attr">"connection"</span>: &#123;</span><br><span class="line">      <span class="attr">"filename"</span>: <span class="string">"/var/lib/ghost/content/data/ghost.db"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"mail"</span>: &#123;</span><br><span class="line">    <span class="attr">"transport"</span>: <span class="string">"Direct"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"logging"</span>: &#123;</span><br><span class="line">    <span class="attr">"transports"</span>: [</span><br><span class="line">      <span class="string">"file"</span>,</span><br><span class="line">      <span class="string">"stdout"</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"process"</span>: <span class="string">"systemd"</span>,</span><br><span class="line">  <span class="attr">"paths"</span>: &#123;</span><br><span class="line">    <span class="attr">"contentPath"</span>: <span class="string">"/var/lib/ghost/content"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里配置了服务的域名，端口，数据库等。</p><p>我这里用的数据库是<code>sqlite3</code>,我觉得一个小博客系统够了，<code>mysql</code>太重了。</p><h3 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h3><p>博客系统已经跑起来了，现在我们需要一个nginx服务，关于nginx的安装你可以看<a href="https://wayto.dev/nginx-tls1.3" target="_blank" rel="noopener">这里</a>。</p><p>我的nginx配置如下：</p><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>                       <span class="number">443</span> ssl  http2 default fastopen=<span class="number">3</span> reuseport;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">server_name</span>                  netcj.com www.netcj.com;</span><br><span class="line">    <span class="attribute">server_tokens</span>                <span class="literal">off</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">access_log</span>                   /www/nginx/logdata/netcj.com.log;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">include</span>                      /www/nginx/ip.blacklist;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">ssl_trusted_certificate</span>      /www/nginx/certs/ca_file.pem;</span><br><span class="line">    <span class="attribute">ssl_certificate</span>              /www/nginx/certs/<span class="regexp">*.netcj.com</span>_rsa.cer;</span><br><span class="line">    <span class="attribute">ssl_certificate_key</span>          /www/nginx/certs/<span class="regexp">*.netcj.com</span>_rsa.key;</span><br><span class="line">    <span class="attribute">ssl_certificate</span>              /www/nginx/certs/<span class="regexp">*.netcj.com</span>_ecc.cer;</span><br><span class="line">    <span class="attribute">ssl_certificate_key</span>          /www/nginx/certs/<span class="regexp">*.netcj.com</span>_ecc.key;</span><br><span class="line">    <span class="attribute">ssl_dhparam</span>                  /www/nginx/dhparams.pem;</span><br><span class="line">    <span class="attribute">ssl_ecdh_curve</span>               X25519:P-<span class="number">256</span>:P-<span class="number">384</span>:P-<span class="number">224</span>:P-<span class="number">521</span>;</span><br><span class="line">    <span class="attribute">ssl_ciphers</span>                  TLS13-AES-<span class="number">256</span>-GCM-SHA384:TLS13-CHACHA20-POLY1305-SHA256:TLS13-AES-<span class="number">128</span>-GCM-SHA256:TECDH+CHACHA20:EECDH+CHACHA20-draft:EECDH+AES256:RSA+AES256:EECDH+3DES:RSA+3DES:!MD5;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">ssl_prefer_server_ciphers</span>    <span class="literal">on</span>;</span><br><span class="line">    <span class="attribute">ssl_protocols</span>                TLSV1.<span class="number">1</span> TLSV1.<span class="number">2</span> TLSV1.<span class="number">3</span>;</span><br><span class="line">    <span class="attribute">ssl_session_cache</span>            shared:SSL:<span class="number">50m</span>;</span><br><span class="line">    <span class="attribute">ssl_session_timeout</span>          <span class="number">1d</span>;</span><br><span class="line">    <span class="attribute">ssl_session_tickets</span>          <span class="literal">on</span>;</span><br><span class="line">    <span class="attribute">ssl_stapling</span>                 <span class="literal">on</span>;</span><br><span class="line">    <span class="attribute">ssl_stapling_verify</span>          <span class="literal">on</span>;</span><br><span class="line">    <span class="attribute">resolver</span>                     <span class="number">114.114.114.114</span> <span class="number">8.8.8.8</span> valid=<span class="number">300s</span>;</span><br><span class="line">    <span class="attribute">resolver_timeout</span>             <span class="number">10s</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment"># webmaster 站点验证相关</span></span><br><span class="line">    <span class="attribute">location</span> <span class="regexp">~* (google4c90d18e696bdcf8\.html|BingSiteAuth\.xml)$</span> &#123;</span><br><span class="line">        <span class="attribute">root</span>                     /www/static;</span><br><span class="line">        <span class="attribute">expires</span>                  <span class="number">1d</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="attribute">add_header</span>               Public-Key-Pins <span class="string">'pin-sha256="Vjs8r4z+80wjNcr1YKepWQboSIRi63WsWXhIMN+eWys="; pin-sha256="YLh1dUR9y6Kja30RrAn7JKnbQG/uEtLMkBgFF2Fuihg="; pin-sha256="S4AbJNGvyS57nzJwv8sPMUML8VHSqH1vbiBftdPcErI="; pin-sha256="MunFWpgz45SKZDTvitbhyy0Vu9Axb6CHIdM9R7DXFjs=";pin-sha256="qiYwp7YXsE0KKUureoyqpQFubb5gSDeoOoVxn6tmfrU="; max-age=2592000; report-uri="https://netcj.report-uri.com/r/d/hpkp/enforce"'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">add_header</span>               Strict-Transport-Security <span class="string">"max-age=31536000; includeSubDomains; preload"</span>;</span><br><span class="line">    <span class="attribute">add_header</span>               X-Frame-Options deny;</span><br><span class="line">    <span class="attribute">add_header</span>               X-Content-Type-Options nosniff;</span><br><span class="line">    <span class="attribute">add_header</span>               Expect-Ct <span class="string">'enforce,max-age=30,report-uri="https://netcj.report-uri.com/r/d/ct/enforce"'</span>;</span><br><span class="line">    <span class="attribute">add_header</span>               Referrer-Policy <span class="string">"origin-when-cross-origin"</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="attribute">add_header</span>               Cache-Control <span class="literal">no</span>-cache;</span><br><span class="line">    <span class="attribute">add_header</span>               X-Via AQ;</span><br><span class="line">    <span class="attribute">add_header</span>               X-XSS-Protection <span class="string">"1; mode=block"</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="attribute">location</span> / &#123;</span><br><span class="line">        <span class="attribute">proxy_http_version</span>       <span class="number">1</span>.<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">proxy_ignore_headers</span>     Set-Cookie;</span><br><span class="line">        <span class="attribute">proxy_hide_header</span>        Vary;</span><br><span class="line">        <span class="attribute">proxy_hide_header</span>        X-Powered-By;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">proxy_set_header</span>         Connection       <span class="string">""</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span>         Host             netcj.com;</span><br><span class="line">        <span class="attribute">proxy_set_header</span>         X-Real-IP        <span class="variable">$remote_addr</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span>         X-Forwarded-For  <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span>         X-Forwarded-Proto <span class="variable">$scheme</span>;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">proxy_pass</span>               http://127.0.0.1:2368;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">server_name</span>                  netcj.com www.netcj.com;</span><br><span class="line">    <span class="attribute">server_tokens</span>                <span class="literal">off</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">access_log</span>                   /dev/null;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">if</span> (<span class="variable">$request_method</span> !<span class="regexp">~ ^(GET|HEAD|POST|OPTIONS)$</span> ) &#123;</span><br><span class="line">        <span class="attribute">return</span>                   <span class="number">444</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># letsencrypt file verify</span></span><br><span class="line">    <span class="attribute">location</span><span class="regexp"> ^~</span> /.well-known/acme-challenge/ &#123;</span><br><span class="line">        <span class="attribute">alias</span>                    /www/nginx/challenges/;</span><br><span class="line">        <span class="attribute">try_files</span>                <span class="variable">$uri</span> =<span class="number">404</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">location</span> / &#123;</span><br><span class="line">        <span class="attribute">rewrite</span>                 <span class="regexp"> ^/(.*)$</span> https://netcj.com/<span class="variable">$1</span> <span class="literal">permanent</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="七牛"><a href="#七牛" class="headerlink" title="七牛"></a>七牛</h3><p>ghost默认图片等静态文件都放在服务器上，一方面耗费流量，一方面我的服务器是小水管，加载太慢，考虑将图片放到七牛云。</p><p>ghost官方也有<a href="https://docs.ghost.org/docs/using-a-custom-storage-module" target="_blank" rel="noopener">相关文档</a></p><p>这里我们首先要添加一个插件<a href="https://github.com/minwe/qn-store" target="_blank" rel="noopener"><code>qn-store</code></a>。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> ghost文件夹</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> mkdir -p content/adapters/storage</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> content/adapters/storage</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> https://github.com/Minwe/qn-store.git</span></span><br></pre></td></tr></table></figure><p>然后我们需要修改<code>config.production.json</code>文件，添加以下内容：</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">"storage": &#123;</span><br><span class="line">    "active": "qn-store",</span><br><span class="line">    "qn-store": &#123;</span><br><span class="line">      "accessKey": "xxxx",</span><br><span class="line">      "secretKey": "xxxx",</span><br><span class="line">      "bucket": "xxxx",</span><br><span class="line">      "origin": "https://xxxx",</span><br><span class="line">      "fileKey": &#123;</span><br><span class="line">        "safeString": true,</span><br><span class="line">        "prefix": "/YYYYMM/"</span><br><span class="line">      &#125;,</span><br><span class="line">      "uploadURL": "up-z2.qiniup.com"</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><p>其中需要关注的是：</p><ul><li>accessKey\secretKey 七牛的授权密钥</li><li>bucket 七牛存储空间名</li><li>origin 七牛绑定的空间域名</li><li>prefix 上传文件的前缀</li><li>uploadURL 七牛上传的地址，各个地区不一样，我这里是华南的。</li></ul><p>配置好这些之后，<code>docker-compose restart</code> 即可。</p><h3 id="disqus"><a href="#disqus" class="headerlink" title="disqus"></a>disqus</h3><p>disqus各个主题的支持方式应该有所不同，该<a href="https://github.com/zutrinken/attila" target="_blank" rel="noopener">主题(attila)</a>只要在发博客时，博客头部插入<code>&lt;script&gt;var disqus = &#39;YOUR_DISQUS_SHORTNAME&#39;;&lt;/script&gt;</code> 即可。</p><p><img data-src="https://st.razeen.cn/img/201809/jietu20180905-230612.png" alt="jietu20180905-230612"></p><h3 id="邮箱设置"><a href="#邮箱设置" class="headerlink" title="邮箱设置"></a>邮箱设置</h3><p>我设置的QQ邮箱，QQ 邮箱需要使用 授权码 代替密码才能登陆（邮箱独立密码也无法登陆）。</p><p>授权码生成地址： 设置 &gt; 账户 &gt; POP3/IMAP/SMTP/Exchange/CardDAV/CalDAV服务 。</p><p>修改<code>config.production.json</code>文件，添加以下内容：</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">"mail": &#123;</span><br><span class="line">  "from": "&lt;邮箱，需要与下面的邮箱一致&gt;",</span><br><span class="line">  "transport": "SMTP",</span><br><span class="line">  "options": &#123;</span><br><span class="line">    "service": "QQ",</span><br><span class="line">    "auth": &#123;</span><br><span class="line">      "user": "&lt;邮箱&gt;",</span><br><span class="line">      "pass": "&lt;授权码&gt;" </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>到<a href="https://myssl.com" target="_blank" rel="noopener">myssl.com</a> 检测以下网站配置是否安全。A+ 还不错。</p><p><img data-src="https://st.razeen.cn/img/201809/jietu20180905-230156.png" alt="img"></p><p>如果你没有证书，可以到这里<a href="https://freessl.org" target="_blank" rel="noopener">申请免费证书</a>。</p><p>如果有问题，请留言，我们一起解决。</p>]]></content>
      <categories>
        <category>博客折腾日记</category>
      </categories>
      <tags>
        <tag>ghost</tag>
      </tags>
  </entry>
  <entry>
    <title>Newifi3 实现低成本家庭级科学上网</title>
    <url>//post/start-use-newifi3.html</url>
    <content><![CDATA[<p>为了搭建一个家庭智能科学上网的环境，想找个支持Openwrt的路由刷一刷， 观望了一段时间，入手了款矿渣newifi3 d2，虽说有人吐槽信号不好，然而房间小的我并不担心==。</p><p><img data-src="https://st.razeen.cn/img/blog/newifi3.jpg" alt></p><a id="more"></a><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p><strong>CPU：</strong> MT7621A<br><strong>闪存：</strong> 32MB<br><strong>内存：</strong> 512MB<br><strong>传输频段：</strong> 2.4G；5G<br><strong>网口：</strong> 全千兆 4xLAN + 1xWAN<br><strong>USB：</strong> 3.0x1<br><strong>价格：</strong> 某宝¥85</p><p>我买的是刷了Openwrt的，后来觉得Openwrt折腾起来还是需要点时间的，自己又刷了老毛子。</p><p>我们SSH上去看看。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ cat /proc/cpuinfo</span><br><span class="line">system <span class="built_in">type</span>             : MediaTek MT7621 SoC</span><br><span class="line">processor               : 0</span><br><span class="line">cpu model               : MIPS 1004Kc V2.15</span><br><span class="line">BogoMIPS                : 583.68</span><br><span class="line"><span class="built_in">wait</span> instruction        : yes</span><br><span class="line">microsecond timers      : yes</span><br><span class="line">tlb_entries             : 32</span><br><span class="line">extra interrupt vector  : yes</span><br><span class="line">hardware watchpoint     : yes, count: 4, address/irw mask: [0x0000, 0x0ff8, 0x0000, 0x0003]</span><br><span class="line">ASEs implemented        : mips16 dsp mt</span><br><span class="line">shadow register sets    : 1</span><br><span class="line">kscratch registers      : 0</span><br><span class="line">core                    : 0</span><br><span class="line">VPE                     : 0</span><br><span class="line">VCED exceptions         : not available</span><br><span class="line">VCEI exceptions         : not available</span><br><span class="line"></span><br><span class="line">processor               : 1</span><br><span class="line">cpu model               : MIPS 1004Kc V2.15</span><br><span class="line">BogoMIPS                : 583.68</span><br><span class="line"><span class="built_in">wait</span> instruction        : yes</span><br><span class="line">microsecond timers      : yes</span><br><span class="line">tlb_entries             : 32</span><br><span class="line">extra interrupt vector  : yes</span><br><span class="line">hardware watchpoint     : yes, count: 4, address/irw mask: [0x0000, 0x0004, 0x0000, 0x0000]</span><br><span class="line">ASEs implemented        : mips16 dsp mt</span><br><span class="line">shadow register sets    : 1</span><br><span class="line">kscratch registers      : 0</span><br><span class="line">core                    : 0</span><br><span class="line">VPE                     : 1</span><br><span class="line">VCED exceptions         : not available</span><br><span class="line">VCEI exceptions         : not available</span><br><span class="line"></span><br><span class="line">processor               : 2</span><br><span class="line">cpu model               : MIPS 1004Kc V2.15</span><br><span class="line">BogoMIPS                : 583.68</span><br><span class="line"><span class="built_in">wait</span> instruction        : yes</span><br><span class="line">microsecond timers      : yes</span><br><span class="line">tlb_entries             : 32</span><br><span class="line">extra interrupt vector  : yes</span><br><span class="line">hardware watchpoint     : yes, count: 4, address/irw mask: [0x0000, 0x0000, 0x0000, 0x0000]</span><br><span class="line">ASEs implemented        : mips16 dsp mt</span><br><span class="line">shadow register sets    : 1</span><br><span class="line">kscratch registers      : 0</span><br><span class="line">core                    : 1</span><br><span class="line">VPE                     : 0</span><br><span class="line">VCED exceptions         : not available</span><br><span class="line">VCEI exceptions         : not available</span><br><span class="line"></span><br><span class="line">processor               : 3</span><br><span class="line">cpu model               : MIPS 1004Kc V2.15</span><br><span class="line">BogoMIPS                : 583.68</span><br><span class="line"><span class="built_in">wait</span> instruction        : yes</span><br><span class="line">microsecond timers      : yes</span><br><span class="line">tlb_entries             : 32</span><br><span class="line">extra interrupt vector  : yes</span><br><span class="line">hardware watchpoint     : yes, count: 4, address/irw mask: [0x0000, 0x0004, 0x0003, 0x0000]</span><br><span class="line">ASEs implemented        : mips16 dsp mt</span><br><span class="line">shadow register sets    : 1</span><br><span class="line">kscratch registers      : 0</span><br><span class="line">core                    : 1</span><br><span class="line">VPE                     : 1</span><br><span class="line">VCED exceptions         : not available</span><br><span class="line">VCEI exceptions         : not available</span><br></pre></td></tr></table></figure><p>CPU架构<code>mips</code>, 可以支持跑Go程序哦，一会试试。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ df -h</span><br><span class="line">Filesystem                Size      Used Available Use% Mounted on</span><br><span class="line">rootfs                   13.0M     13.0M         0 100% /</span><br><span class="line">/dev/root                13.0M     13.0M         0 100% /</span><br><span class="line">tmpfs                     8.0K         0      8.0K   0% /dev</span><br><span class="line">tmpfs                    20.0M      1.7M     18.3M   8% /etc</span><br><span class="line">tmpfs                     1.0M         0      1.0M   0% /home</span><br><span class="line">tmpfs                     8.0K         0      8.0K   0% /media</span><br><span class="line">tmpfs                     8.0K         0      8.0K   0% /mnt</span><br><span class="line">tmpfs                    40.0M     17.9M     22.1M  45% /tmp</span><br><span class="line">tmpfs                     4.0M    348.0K      3.7M   8% /var</span><br><span class="line">tmpfs                    40.0M     17.9M     22.1M  45% /opt</span><br><span class="line">/dev/sda2               795.0M    438.8M    356.2M  55% /media/AiDisk_a2</span><br><span class="line">/dev/sda1               118.5G     56.1G     62.4G  47% /media/home</span><br></pre></td></tr></table></figure><p>这是磁盘情况（/dev/sda1-2 是我的外接硬盘）。</p><h3 id="刷不死Breed"><a href="#刷不死Breed" class="headerlink" title="刷不死Breed"></a>刷不死Breed</h3><p>由于我的路由器是已经刷了Openwrt了，我就不用再刷了，看了一下网友步骤，不外乎：</p><ol><li><p>初始化，设密码；</p></li><li><p>连LAN口，登陆后台 “<a href="http://192.168.99.1&quot;" target="_blank" rel="noopener">http://192.168.99.1&quot;</a> ，访问“<a href="http://192.168.99.1/newifi/ifiwen_hss.html”激活SSH" target="_blank" rel="noopener">http://192.168.99.1/newifi/ifiwen_hss.html”激活SSH</a>;</p></li><li><p>下载Breed文件<a href="https://st.razeen.cn/img/blog/newifi-d2-jail-break.ko" target="_blank" rel="noopener">newifi-d2-jail-break.ko</a>，<code>scp newifi-d2-jail-break.ko root@192.168.99.1:/tmp</code>;</p></li><li><p>ssh 登陆， <code>cd /tmp &amp;&amp; insmod newifi-d2-jail-break.ko</code>;</p></li><li><p>系统重启，成功刷入；</p></li><li><p>拔掉电源，按住reset后， 插入电源，等几秒，电源灯闪缩，浏览器输入192.168.1.1进入Breed,如下。</p></li></ol><p><img data-src="https://st.razeen.cn/img/blog/newifi3d2-breed.jpg" alt></p><p>在刷之前，我们备份一下。两个都选一下。</p><p><img data-src="https://st.razeen.cn/img/blog/newfi3d2-backup.jpg" alt></p><p>然后我们在固件更新这里就可以 刷机/恢复 我们的固件了。</p><p>我原来的Openwrt固件在这里-&gt; 【链接：<a href="https://share.weiyun.com/5hDGrBl" target="_blank" rel="noopener">https://share.weiyun.com/5hDGrBl</a> 密码：9u73g3】</p><p><img data-src="https://st.razeen.cn/img/blog/newifi3d2-con.jpg" alt></p><p>这里有newifi3 d2支持的固件帖子<a href="https://www.right.com.cn/forum/forum.php?mod=viewthread&amp;tid=658359&amp;page=1&amp;extra=#pid3990638" target="_blank" rel="noopener"><strong>新路由三 NEWifi D2 固件集合贴</strong></a>。</p><p>​</p><h3 id="刷老毛子"><a href="#刷老毛子" class="headerlink" title="刷老毛子"></a>刷老毛子</h3><p>下载h大的Padavan固件 原下载地址“<a href="http://opt.cn2qq.com/padavan/”" target="_blank" rel="noopener">http://opt.cn2qq.com/padavan/”</a> ，下载<code>RT-N56UB1-newif3D2-512M_3.4.3.9-099.trx</code>。 我在微云备份了一个【链接：<a href="https://share.weiyun.com/5YyHFA2" target="_blank" rel="noopener">https://share.weiyun.com/5YyHFA2</a> 密码：iiuf29】</p><p>进入上面图片中的固件更新，固件选择刚刚下载的估计，上传，进度完成再等几分钟，重启即可。</p><p><img data-src="https://st.razeen.cn/img/blog/Jietu20190830-214029.jpg" alt></p><p>启动后默认开启了无线网 <code>PDCN_5G</code>和<code>PDCN</code>, 密码为<code>1234567890</code>。</p><p>默认网关地址<code>192.168.123.1</code>, 用户名密码都是<code>admin</code>。</p><p>登陆后，大概是这样子。</p><p><img data-src="https://st.razeen.cn/img/blog/image-20190909000804648.png" alt></p><h3 id="配置ShadowSocks"><a href="#配置ShadowSocks" class="headerlink" title="配置ShadowSocks"></a>配置ShadowSocks</h3><p>要配置ShadowSocks，你先要有ShadowSocks服务，可以自己搭建或购买。</p><p>我个人是购买的SS服务，毕竟用自己的服务器有被封的概率。我在<a href="https://order.shadowsocks.website/aff.php?aff=26059" target="_blank" rel="noopener">这里</a>买的，约97RMB一年，基本能满足日常工作生活的需求。</p><p>点击ShadowSocks, 就可以配置了，如图是我的配置。</p><p><img data-src="https://st.razeen.cn/img/blog/Jietu20190909-001602.jpg" alt></p><p>为了达到全局自动代理的效果，我开启了重定向DNS，也就是我所有的DNS都会走<code>dnsmasq</code>, dnsmsq配合chinaDNS自动将国外的站点走翻墙。</p><p>GFW -&gt; <a href="https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt" target="_blank" rel="noopener">https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt</a></p><p><img data-src="https://st.razeen.cn/img/blog/Jietu20190909-001657.jpg" alt></p><p>配置好后，点击应用本页配置，稍等片刻(可以点击右上角log,查看配置进度)，就可以轻松科学上网啦。</p><h3 id="在路由器上跑golang"><a href="#在路由器上跑golang" class="headerlink" title="在路由器上跑golang"></a>在路由器上跑golang</h3><p>这个漏油器有512MB的内存，不跑点什么感觉浪费了。查了一下，go居然可以在上面跑起来。</p><p>通过<code>uname -m</code>我们可以看出来，cpu架构为<code>mpis</code>。 我们查到<a href="https://golang.org/doc/install/source" target="_blank" rel="noopener"><code>golang</code>支持</a>的如下:</p><ul><li>amd64 (also known as x86-64)<ul><li>A mature implementation.</li></ul></li><li>386 (x86 or x86-32)<ul><li>Comparable to the amd64 port.</li></ul></li><li>arm (ARM)<ul><li>Supports Linux, FreeBSD, NetBSD, OpenBSD and Darwin binaries. Less widely used than the other ports.</li></ul></li><li>arm64 (AArch64)<ul><li>Supports Linux and Darwin binaries. New in 1.5 and not as well exercised as other ports.</li></ul></li><li>ppc64, ppc64le (64-bit PowerPC big- and little-endian)<ul><li>Supports Linux binaries. New in 1.5 and not as well exercised as other ports.</li></ul></li><li>mips, mipsle (32-bit MIPS big- and little-endian)<ul><li>Supports Linux binaries. New in 1.8 and not as well exercised as other ports.</li></ul></li><li>mips64, mips64le (64-bit MIPS big- and little-endian)<ul><li>Supports Linux binaries. New in 1.6 and not as well exercised as other ports.</li></ul></li><li>s390x (IBM System z)<ul><li>Supports Linux binaries. New in 1.7 and not as well exercised as other ports.</li></ul></li></ul><p>我们写个<code>hello world</code>试一下。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"># file openwrt.<span class="keyword">go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"net/http"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	http.HandleFunc(<span class="string">"/hello"</span>, <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">		w.Write([]<span class="keyword">byte</span>(<span class="string">"hello world"</span>))</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">"start listen"</span>)</span><br><span class="line">	http.ListenAndServe(<span class="string">":12345"</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ GOOS=linux GOARCH=mipsle go build openwrt.go</span><br></pre></td></tr></table></figure><p>上传：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> scp openwrt razeen@192.168.123.1:/tmp</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 输入路由登陆密码，上传成功</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 注意目录。 其他目录可能没有空间</span></span><br></pre></td></tr></table></figure><p>运行：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$./openwrt </span><br><span class="line">start listen</span><br></pre></td></tr></table></figure><p>访问：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ curl -v http://192.168.123.1:12345/hello </span><br><span class="line">*   Trying 192.168.123.1...</span><br><span class="line">* TCP_NODELAY <span class="built_in">set</span></span><br><span class="line">* Connected to 192.168.123.1 (192.168.123.1) port 12345 (<span class="comment">#0)</span></span><br><span class="line">&gt; GET /hello HTTP/1.1</span><br><span class="line">&gt; Host: 192.168.123.1:12345</span><br><span class="line">&gt; User-Agent: curl/7.54.0</span><br><span class="line">&gt; Accept: */*</span><br><span class="line">&gt; </span><br><span class="line">&lt; HTTP/1.1 200 OK</span><br><span class="line">&lt; Date: Tue, 01 Oct 2019 16:23:43 GMT</span><br><span class="line">&lt; Content-Length: 11</span><br><span class="line">&lt; Content-Type: text/plain; charset=utf-8</span><br><span class="line">&lt; </span><br><span class="line">* Connection <span class="comment">#0 to host 192.168.123.1 left intact</span></span><br><span class="line">hello world%</span><br></pre></td></tr></table></figure><p>完美～</p>]]></content>
      <categories>
        <category>家庭网络折腾</category>
      </categories>
      <tags>
        <tag>newifi3</tag>
      </tags>
  </entry>
  <entry>
    <title>折腾 Ubuntu 20.04 LTS 开发环境</title>
    <url>//post/start-use-ubuntu-and-win.html</url>
    <content><![CDATA[<p><del>前段时间买了个 Inter NUC (NUC10i5FNH6), 主要用来在家里搬砖。体验了一段时间 win10, 虽然配置了 WSL2， 但开发体验实在糟糕，在考虑过 Ubuntu 和黑苹果后，还是选择了 Ubuntu, 毕竟用习惯了白苹果，突然用个黑苹果，不能随意升级，还有接一个 USB WiFi ，还担心驱动问题。。。</del></p><blockquote><p>NUC 用了一段时间，还是有点卡，CPU跟不上。 最后还是组装了一台台式主机，将原来的系统盘查上去直接就可使用，爽到飞起。 至于NUC就当服务器用了。</p></blockquote><p>毕竟头一次想把 Ubuntu 当作生产力，记录一下折腾过程。</p><a id="more"></a><h3 id="配置篇"><a href="#配置篇" class="headerlink" title="配置篇"></a>配置篇</h3><table><thead><tr><th></th><th>配置</th></tr></thead><tbody><tr><td>CPU</td><td><del>i5-10210U (1.6GHz-4.2GHz)</del> Intel(R) Core(TM) i5-10400F CPU @ 2.90GHz</td></tr><tr><td>显卡</td><td><del>Intel UHD</del> GeForce GTX 1050 Ti</td></tr><tr><td>内存</td><td><del>32G x 2 (相当浪费==)</del> 32G</td></tr><tr><td>磁盘</td><td>Intel 760p 512G + 三星 860 EVO 500G</td></tr></tbody></table><h3 id="系统篇"><a href="#系统篇" class="headerlink" title="系统篇"></a>系统篇</h3><h4 id="安装双系统"><a href="#安装双系统" class="headerlink" title="安装双系统"></a>安装双系统</h4><p>双系统安装很简单，网上教程视频很多，这里主要说一下我的 Ubuntu 怎么分区的。</p><p>我分了 200G 磁盘给 Ubuntu, 其中：</p><ul><li><p>根目录 (/) - 120G</p><p>主要是系统和软件，还是比较吃空间的。</p></li><li><p>HOME (/home) - 79G</p><p>桌面，文档等一些东西，差不多够用了。不够再把其他分区挂载进来存东西就行了。</p></li><li><p>BOOT (/boot) - 1G</p><p>其实现在都用了LVM，BOOT直接放根目录一起也可以了，但我还是给了1G。</p></li></ul><p>至于SWAP分区，我看了以下SWAP分区的作用（内存交换，内存不足就把一部分硬盘虚拟成内存使用），emmm… 貌似我……64G的内存我目前还用不完，索性不分了。</p><h4 id="系统设置"><a href="#系统设置" class="headerlink" title="系统设置"></a>系统设置</h4><ul><li><p>软件源设置国内的（<strong>关于-&gt;Software Updates-&gt;Ubuntu软件-&gt;下载自</strong>）；</p><p>我选了一个阿里的，感觉速度还可以。</p></li><li><p>软件更新频率等按自己偏好设置一波；</p></li><li><p>Dock栏放右边；</p></li></ul><h4 id="磁盘挂载"><a href="#磁盘挂载" class="headerlink" title="磁盘挂载"></a>磁盘挂载</h4><p>我想在 <code>Linux</code> 下查看原来 <code>Win</code>的文件，找到磁盘，挂载即可。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 找磁盘</span></span><br><span class="line">sudo fdisk -l</span><br><span class="line">设备                起点       末尾      扇区   大小 类型</span><br><span class="line">/dev/nvme0n1p1      2048    1085439   1083392   529M Windows 恢复环境</span><br><span class="line">/dev/nvme0n1p2   1085440    1290239    204800   100M EFI 系统</span><br><span class="line">/dev/nvme0n1p3   1290240    1323007     32768    16M Microsoft 保留</span><br><span class="line">/dev/nvme0n1p4   1323008  419337986 418014979 199.3G Microsoft 基本数据</span><br><span class="line">/dev/nvme0n1p5 419338240  420745215   1406976   687M Windows 恢复环境</span><br><span class="line">/dev/nvme0n1p6 420747264 1000212479 579465216 276.3G Microsoft 基本数据</span><br></pre></td></tr></table></figure><p>如，按照分区顺序，大小，我这里基本可以确认 <code>/dev/nvme0n1p4</code> 是 C 盘， <code>/dev/nvme0n1p6</code>是 D 盘。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 建一个目录 挂载</span></span><br><span class="line">sudo mkdir /mnt/d</span><br><span class="line">sudo mount /dev/nvme0n1p6 /mnt/d</span><br></pre></td></tr></table></figure><p>这只是临时挂载，重启系统需要再次执行挂载命令。启动时自动挂载需要修改文件<code>/etc/fstab</code>。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/fstab</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加入如以下(我这里是ntfs系统，如果FAT32，把ntfs改成vfat即可)</span></span><br><span class="line">/dev/nvme0n1p6 /mnt/d ntfs defaults 0 0</span><br></pre></td></tr></table></figure><h4 id="CAPS-与-CTRL-键位互换"><a href="#CAPS-与-CTRL-键位互换" class="headerlink" title="CAPS 与 CTRL 键位互换"></a>CAPS 与 CTRL 键位互换</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo vi /usr/share/X11/xkb/keycodes/evdev</span><br></pre></td></tr></table></figure><p>搜索 <code>&lt;CAPS&gt;</code> 和 <code>CTRL</code>, 并互换后面的数字。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">&lt;CAPS&gt; = 37;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">&lt;LCTL&gt; = 66;</span><br></pre></td></tr></table></figure><p>注销，重新登录生效。</p><h4 id="安装L2TP-IPSec-VPN"><a href="#安装L2TP-IPSec-VPN" class="headerlink" title="安装L2TP/IPSec VPN"></a>安装L2TP/IPSec VPN</h4><p>公司办公用的是这个VPN，在家要处理一些事情需要连接。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo add-apt-repository ppa:nm-l2tp/network-manager-l2tp  </span><br><span class="line">sudo apt update  </span><br><span class="line">sudo apt install -y network-manager-l2tp network-manager-l2tp-gnome</span><br></pre></td></tr></table></figure><p>安装后就可以直接在 <strong>设置&gt;网络&gt; VPN &gt; ‘+’ &gt; ‘第2层隧道协议(L2TP)’</strong> 中添加了。</p><p><img data-src="https://st.razeen.cn/img/2020-08-22_01-484.png" alt></p><h4 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h4><p>在home目录下建一个 <code>.bash_profile</code> 放自定义的环境变量，并在启动终端时自动应用。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span></span><br><span class="line">touch .bash_profile</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"source \$HOME/.bash_profile"</span> &gt;&gt; .zshrc</span><br></pre></td></tr></table></figure><h4 id="字体设置"><a href="#字体设置" class="headerlink" title="字体设置"></a>字体设置</h4><p>长时间搬砖，字体一定得看着束缚。 个人偏好<code>CamingoCode</code>字体。<a href="https://github.com/chrissimpkins/codeface/tree/master/fonts" target="_blank" rel="noopener">更多字体</a></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt install -y font-manager</span><br></pre></td></tr></table></figure><p>字体下载好后，打开安在，在IDE/终端内设置该字体即可。</p><h4 id="科学上网"><a href="#科学上网" class="headerlink" title="科学上网"></a>科学上网</h4><p>为了面向 Google , Stackoverflow 编程， 科学上网必不可少。我用的<a href="https://portal.shadowsocks.nz/aff.php?aff=26059" target="_blank" rel="noopener">这家</a>，￥90多一年，速度够用。</p><h4 id="换个Grub2主题"><a href="#换个Grub2主题" class="headerlink" title="换个Grub2主题"></a>换个Grub2主题</h4><p>也就是开机选择系统的界面主题。</p><p>主题 <a href="https://github.com/gustawho/grub2-theme-breeze" target="_blank" rel="noopener">breeze</a>。 更换步骤如下。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 下载</span></span><br><span class="line">git <span class="built_in">clone</span> git@github.com:gustawho/grub2-theme-breeze.git</span><br><span class="line"></span><br><span class="line"><span class="comment"># 主题移到合适位置</span></span><br><span class="line">sudo mkdir /boot/grub/themes</span><br><span class="line">sudo cp -r grub2-theme-breeze/breeze /boot/grub/themes/breeze</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改默认配置</span></span><br><span class="line">sudo vim /etc/default/grub</span><br><span class="line"><span class="comment"># 添加如下</span></span><br><span class="line">GRUB_THEME=<span class="string">"/boot/grub/themes/breeze/theme.txt"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置</span></span><br><span class="line">sudo grub-mkconfig -o /boot/grub/grub.cfg</span><br></pre></td></tr></table></figure><h4 id="修改开机启动顺序"><a href="#修改开机启动顺序" class="headerlink" title="修改开机启动顺序"></a>修改开机启动顺序</h4><p>默认 Win，毕竟有时候家人也要用。但默认配置是</p><ol><li>Ubuntu</li><li>Ubuntu 的高级选项</li><li>Windows</li><li>EFI 设置</li></ol><p>看着难受，必须把 Win 第一， Ubuntu第二。</p><p>很简单，修改 <code>/boot/grub</code> 即可。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 该文件是只读的， 给一个修改权限</span></span><br><span class="line">sudo chmod u+w /boot/grub/grub.cfg</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改文件</span></span><br><span class="line">sudo vim /boot/grub/grub.cfg</span><br></pre></td></tr></table></figure><p><code>menuentry &#39;xxx&#39; {}</code> 就对应显示的一个启动菜单， 把<code>menuentry &#39;Windows Boot Manager xxx {}&#39;</code> 移动到<code>menuentry &#39;Ubuntu&#39; xxx {}</code> 之前 <code>:wq</code>保存即可。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 恢复只读权限</span></span><br><span class="line">sudo chmod u-w /boot/grub/grub.cfg</span><br></pre></td></tr></table></figure><blockquote><p>上面的方式，在系统更新 grub 后，或 <code>sudo update-grub</code>之后会失效（grub.cfg 文件被更新了）。</p><p>推荐使用下面的方式，即 修改配置文件 <code>/etc/default/grub</code> , 设置 <code>GRUB_DEFAULT=2</code>, 这里的<code>2</code>是 win 在启动界面的顺序，从上到下<code>0，1，2</code>。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; <span class="comment"># sudo vim /etc/default/grub</span></span><br><span class="line">&gt; </span><br><span class="line">&gt; GRUB_DEFAULT=2</span><br><span class="line">&gt; GRUB_TIMEOUT_STYLE=hidden</span><br><span class="line">&gt; GRUB_TIMEOUT=10</span><br><span class="line">&gt; GRUB_DISTRIBUTOR=`lsb_release -i -s 2&gt; /dev/null || <span class="built_in">echo</span> Debian`</span><br><span class="line">&gt; GRUB_CMDLINE_LINUX_DEFAULT=<span class="string">"quiet splash"</span></span><br><span class="line">&gt; GRUB_CMDLINE_LINUX=<span class="string">""</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h4 id="顶部状态栏显示CPU等监控信息"><a href="#顶部状态栏显示CPU等监控信息" class="headerlink" title="顶部状态栏显示CPU等监控信息"></a>顶部状态栏显示CPU等监控信息</h4><p>效果如下：</p><p><img data-src="http://st.razeen.cn/img/2020-08-29_16-31.png" alt></p><p>其实这只是桌面系统<code>gnome</code>的一个插件，我们只需要安装一个 Chrome 浏览器插件<code>GNOME Shell integration</code> 和 本地的代理<code>chrome-gnome-shell</code> 就可以在<code>https://extensions.gnome.org/</code> 上安装、管理你的桌面插件。</p><ul><li><p>Chrome 浏览器插件 -&gt; <a href="https://chrome.google.com/webstore/detail/gnome-shell-integration/gphhapmejobijbbhgpjhcjognlahblep" target="_blank" rel="noopener">chrome-gnome-shell</a> ;</p></li><li><p>本地代理安装</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt install chrome-gnome-shell</span><br></pre></td></tr></table></figure></li></ul><p>安装完成后，打开 <a href="https://extensions.gnome.org" target="_blank" rel="noopener">https://extensions.gnome.org</a> ，搜索 <code>system-monitor</code> ，打开开关，状态栏就有了，可以点击设计按钮设置喜欢的样式。</p><p><img data-src="http://st.razeen.cn/img/2020-08-29_16-52.png" alt="2020-08-29_16-52.png"></p><h3 id="软件篇"><a href="#软件篇" class="headerlink" title="软件篇"></a>软件篇</h3><h4 id="Chrome"><a href="#Chrome" class="headerlink" title="Chrome"></a>Chrome</h4><p>最喜欢的浏览器还是Chrome, <a href="https://dl.google.com/linux/direct/google-chrome-stable_current_amd64.deb" target="_blank" rel="noopener">直接下载 .deb 包安装</a>。</p><h4 id="Typora"><a href="#Typora" class="headerlink" title="Typora"></a>Typora</h4><p>没错，Markdown 就用它，简洁而强大。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># or run:</span></span><br><span class="line"><span class="comment"># sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys BA300B7755AFCFAE</span></span><br><span class="line">wget -qO - https://typora.io/linux/public-key.asc | sudo apt-key add -</span><br><span class="line"><span class="comment"># add Typora's repository</span></span><br><span class="line">sudo add-apt-repository <span class="string">'deb https://typora.io/linux ./'</span></span><br><span class="line">sudo apt update</span><br><span class="line"><span class="comment"># install typora</span></span><br><span class="line">sudo apt install -y typora</span><br></pre></td></tr></table></figure><h4 id="Flameshot"><a href="#Flameshot" class="headerlink" title="Flameshot"></a>Flameshot</h4><p>很强大的一款截图软件，写文档需要标注，说明，马赛克等等，很实用。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt install -y flameshot</span><br></pre></td></tr></table></figure><h4 id="Enpass"><a href="#Enpass" class="headerlink" title="Enpass"></a>Enpass</h4><p>一款仅次于 1password 的<a href="https://www.enpass.io/support/kb/general/how-to-install-enpass-on-linux/" target="_blank" rel="noopener">密码管理软件</a>。 由于是早期付费用户（￥80全平台==），还是享受到一定优惠的。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo - i </span><br><span class="line"><span class="built_in">echo</span> <span class="string">"deb https://apt.enpass.io/ stable main"</span> &gt; /etc/apt/sources.list.d/enpass.list</span><br><span class="line">wget -O - https://apt.enpass.io/keys/enpass-linux.key | apt-key add -</span><br><span class="line">apt update</span><br><span class="line">apt install -y enpsudo vi /usr/share/X11/xkb/keycodes/evdevass</span><br><span class="line"><span class="built_in">exit</span></span><br></pre></td></tr></table></figure><h4 id="SwitchHosts"><a href="#SwitchHosts" class="headerlink" title="SwitchHosts"></a>SwitchHosts</h4><p>一款 <code>Electron</code> 写的跨平台 <code>Hosts</code> 管理软件，管理/切换 <code>Hosts</code>很方便。</p><p><a href="https://github.com/oldj/SwitchHosts" target="_blank" rel="noopener">SwitchHosts</a></p><p>images/PNG image.png</p><h4 id="SMB服务"><a href="#SMB服务" class="headerlink" title="SMB服务"></a>SMB服务</h4><p>手机与 <code>Linux</code> 怎么快速传文件，我考虑用了 <code>SMB</code>。 正好苹果手机的<code>文件</code>支持连接<code>SMB</code>服务。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装</span></span><br><span class="line">sudo apt-get install -y samba samba-common</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置一个共享文件夹</span></span><br><span class="line">mkdir /home/razeen/wspace/share</span><br><span class="line"></span><br><span class="line"><span class="comment"># 权限放开</span></span><br><span class="line">sudo chmod 777 /home/razeen/wspace/share -R</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加用户, 需要输入密码</span></span><br><span class="line">sudo smbpasswd -a razeen</span><br><span class="line">New SMB password:</span><br><span class="line">Retype new SMB password:</span><br><span class="line">Added user razeen.</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置</span></span><br><span class="line">sudo vim /etc/samba/smb.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 我简单设置了一下</span></span><br><span class="line">[ubuntu]</span><br><span class="line">   comment = ubuntu share dir</span><br><span class="line">   path = /home/razeen/wspace/share</span><br><span class="line">   public = yes</span><br><span class="line">   writable = yes</span><br><span class="line">   </span><br><span class="line"><span class="comment"># 重启服务</span></span><br><span class="line">sudo systemctl restart smbd.service</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开机自启</span></span><br><span class="line">systemctl <span class="built_in">enable</span> smbd.service</span><br></pre></td></tr></table></figure><p>在手机直接输入 <code>smb://你的ip</code> 浏览器提示打开<code>文件</code>应用， 确认，然后进去输入刚刚设置的账户以及密码即可。然后手机中的文件就可以直接分享到电脑，电脑上的文件拖到共享文件夹可以快速下载。</p><p><img data-src="https://st.razeen.cn/img/smbimage12.png" alt></p><h3 id="搬砖工具篇"><a href="#搬砖工具篇" class="headerlink" title="搬砖工具篇"></a>搬砖工具篇</h3><h4 id="oh-my-zsh"><a href="#oh-my-zsh" class="headerlink" title="oh-my-zsh"></a>oh-my-zsh</h4><p>高效，美观的终端，就靠它了。</p><p>先安装 <code>zsh , git</code>编译</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt install zsh git</span><br></pre></td></tr></table></figure><p>再安装 <code>oh-my-zsh</code></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sh -c &quot;$(curl -fsSL https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh)&quot;</span><br></pre></td></tr></table></figure><p>设置启动时自动进入 zsh</p><p>在 <strong>首选项 -&gt; 配置文件 -&gt; 运行自定义命令而不是shell -&gt; 自定义命令</strong> 输入 <code>zsh</code>。</p><h4 id="tmux"><a href="#tmux" class="headerlink" title="tmux"></a>tmux</h4><p>分屏，Session, 多缓存区，高效管理终端，终端复用 用它没错。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt install -y tmux</span><br></pre></td></tr></table></figure><p>配置还在摸索，<code>Mac</code> 上的不适用了，后面再单独整理一篇文章。</p><h4 id="vim"><a href="#vim" class="headerlink" title="vim"></a>vim</h4><p>效率，极客之选。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt install -y vim</span><br></pre></td></tr></table></figure><p>同上，配置还在摸索，<code>Mac</code> 上的不适用了，后面再单独整理一篇文章。</p><h4 id="docker"><a href="#docker" class="headerlink" title="docker"></a>docker</h4><p>安装。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt-get install -y \</span><br><span class="line">    apt-transport-https \</span><br><span class="line">    ca-certificates \</span><br><span class="line">    curl \</span><br><span class="line">    gnupg-agent \</span><br><span class="line">    software-properties-common</span><br><span class="line">curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -</span><br><span class="line">sudo apt-key fingerprint 0EBFCD88</span><br><span class="line">sudo add-apt-repository \</span><br><span class="line">   <span class="string">"deb [arch=amd64] https://download.docker.com/linux/ubuntu \</span></span><br><span class="line"><span class="string">   <span class="variable">$(lsb_release -cs)</span> \</span></span><br><span class="line"><span class="string">   stable"</span></span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install -y docker-ce docker-ce-cli containerd.io</span><br></pre></td></tr></table></figure><p>把 docker 加入当前用户组，然后重启，用非 root 运行 docker。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo usermod -aG docker <span class="variable">$USER</span></span><br></pre></td></tr></table></figure><p>添加国内的镜像源。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/docker/daemon.json</span><br><span class="line"></span><br><span class="line"><span class="comment"># 163</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"registry-mirrors"</span>: [<span class="string">"http://hub-mirror.c.163.com"</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启 docker服务</span></span><br><span class="line">systemctl restart docker.service</span><br><span class="line"><span class="comment"># 自启动</span></span><br><span class="line">systemctl <span class="built_in">enable</span> docker.service</span><br></pre></td></tr></table></figure><h4 id="VSCode-配置"><a href="#VSCode-配置" class="headerlink" title="VSCode 配置"></a>VSCode 配置</h4><p>好用，没话说。直接<a href="https://code.visualstudio.com/docs/?dv=linux64_deb" target="_blank" rel="noopener">官网下载</a>，点击安装。</p><h3 id="Golang-篇"><a href="#Golang-篇" class="headerlink" title="Golang 篇"></a>Golang 篇</h3><p>作为主力编程语言，不能怠慢。</p><h4 id="从源码安装"><a href="#从源码安装" class="headerlink" title="从源码安装"></a>从源码安装</h4><p>必须从源码安装，掌控每个细节。</p><h5 id="通商准备工作"><a href="#通商准备工作" class="headerlink" title="通商准备工作"></a>通商准备工作</h5><p>给自己建一个工作区， 以及相关目录</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> </span><br><span class="line"></span><br><span class="line"><span class="comment"># go 相关目录</span></span><br><span class="line">mkdir -p wspace/<span class="built_in">source</span>/go \</span><br><span class="line">	wspace/<span class="built_in">source</span>/go14 \</span><br><span class="line">	wspace/go/src \</span><br><span class="line">	wspace/go/bin</span><br><span class="line"></span><br><span class="line"><span class="comment"># 相关环境变量</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">'</span></span><br><span class="line"><span class="string"># 我的工作区</span></span><br><span class="line"><span class="string">export WSPACE=$HOME/wspace</span></span><br><span class="line"><span class="string"># 源码文件</span></span><br><span class="line"><span class="string">export SOURCECODE=$WSPACE/source</span></span><br><span class="line"><span class="string"># go 安装引导</span></span><br><span class="line"><span class="string">export GOROOT_BOOTSTRAP=$SOURCECODE/go14</span></span><br><span class="line"><span class="string"># go root</span></span><br><span class="line"><span class="string">export GOROOT=$SOURCECODE/go</span></span><br><span class="line"><span class="string"># go path</span></span><br><span class="line"><span class="string">export GOPATH=$WSPACE/go</span></span><br><span class="line"><span class="string"># go bin</span></span><br><span class="line"><span class="string">export GOBIN=$GOPATH/bin</span></span><br><span class="line"><span class="string"># go module</span></span><br><span class="line"><span class="string">export GO111MODULE=on</span></span><br><span class="line"><span class="string"># go proxy</span></span><br><span class="line"><span class="string">export GOPROXY=https://goproxy.io,direct</span></span><br><span class="line"><span class="string"># cgo</span></span><br><span class="line"><span class="string">export CGO_ENABLED=0</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># PATH</span></span><br><span class="line"><span class="string">export PATH=$PATH:$GOROOT/bin:$GOBIN</span></span><br><span class="line"><span class="string">'</span> &gt;&gt; .bash_profile</span><br><span class="line"></span><br><span class="line"><span class="built_in">source</span> .bash_profile</span><br></pre></td></tr></table></figure><h5 id="下载Go1-4引导"><a href="#下载Go1-4引导" class="headerlink" title="下载Go1.4引导"></a>下载Go1.4引导</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl https://dl.google.com/go/go1.4-bootstrap-20171003.tar.gz -v -o go1.4.tar.gz</span><br><span class="line">tar -zxvf go1.4.tar.gz</span><br><span class="line">mv go/* <span class="variable">$GOROOT_BOOTSTRAP</span></span><br><span class="line">rm -fr go go1.4.tar.gz</span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$GOROOT_BOOTSTRAP</span>/src</span><br><span class="line">./all.bash</span><br></pre></td></tr></table></figure><h5 id="下载源码并编译"><a href="#下载源码并编译" class="headerlink" title="下载源码并编译"></a>下载源码并编译</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://go.googlesource.com/go <span class="variable">$GOROOT</span></span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$GOROOT</span></span><br><span class="line">git checkout go1.15</span><br><span class="line"><span class="built_in">cd</span> src</span><br><span class="line">./all.bash</span><br><span class="line">go version</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>家庭网络折腾</category>
      </categories>
      <tags>
        <tag>golang</tag>
        <tag>ubuntu</tag>
        <tag>windows</tag>
      </tags>
  </entry>
  <entry>
    <title>一次诡异的数据库删除</title>
    <url>//post/strage-db-delete.html</url>
    <content><![CDATA[<p>事情是这样的。</p><p>我们的项目使用的是<code>sqlite3</code>数据库。在一次常规模拟测试中，我们想了解，如果程序正在运行中，用户将<code>sqlite3</code>数据库文件删除，程序能否进入预设的重置流程。</p><p>结果，我们却让我们有些意外。</p><a id="more"></a><h3 id="try"><a href="#try" class="headerlink" title="try"></a>try</h3><p>于是我写了一段go代码模拟一下该过程。</p><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"database/sql"</span></span><br><span class="line">	<span class="string">"net/http"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line"></span><br><span class="line">	_ <span class="string">"github.com/mattn/go-sqlite3"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 首先，我们打开个数据库</span></span><br><span class="line">	db, err := sql.Open(<span class="string">"sqlite3"</span>, <span class="string">"file:test.sqlite"</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> db.Close()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 建个表</span></span><br><span class="line">	_, err = db.Exec(<span class="string">`CREATE TABLE IF NOT EXISTS test_t(</span></span><br><span class="line"><span class="string">		a TEXT,</span></span><br><span class="line"><span class="string">		create_at TIMESTAMP default CURRENT_TIMESTAMP</span></span><br><span class="line"><span class="string">	);`</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 我们通过API来简单控制一些插入，查询</span></span><br><span class="line">	http.HandleFunc(<span class="string">"/test"</span>, <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> r.FormValue(<span class="string">"query"</span>) != <span class="string">""</span> &#123;</span><br><span class="line">			rows, err := db.Query(<span class="string">"SELECT * FROM test_t"</span>)</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				w.Write([]<span class="keyword">byte</span>(err.Error()))</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">for</span> rows.Next() &#123;</span><br><span class="line">				<span class="keyword">var</span> a <span class="keyword">string</span></span><br><span class="line">				<span class="keyword">var</span> t time.Time</span><br><span class="line">				err := rows.Scan(&amp;a, &amp;t)</span><br><span class="line">				<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">					w.Write([]<span class="keyword">byte</span>(err.Error()))</span><br><span class="line">					<span class="keyword">return</span></span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				w.Write([]<span class="keyword">byte</span>(a + <span class="string">" | "</span> + t.Format(<span class="string">"2006-01-02 15:04:05"</span>+<span class="string">"\r\n"</span>)))</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> v := r.FormValue(<span class="string">"insert"</span>); v != <span class="string">""</span> &#123;</span><br><span class="line">			_, err := db.Exec(<span class="string">"INSERT INTO test_t (a) VALUES (?)"</span>, v)</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				w.Write([]<span class="keyword">byte</span>(err.Error()))</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line">			w.Write([]<span class="keyword">byte</span>(<span class="string">"OK"</span>))</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		w.Write([]<span class="keyword">byte</span>(<span class="string">"NO"</span>))</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	http.ListenAndServe(<span class="string">":10888"</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该段代码是简单的通过API来访问数据库内容。</p><p>我们的重点不是API部分，而是我们开启了一个数据库的连接，然后我们将数据库文件删除后会有什么现象发生呢？</p><p>首先，我们先向插入一些数据。<br></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ curl &quot;http://127.0.0.1:10888/test?insert=ddd&quot;</span><br><span class="line">OK</span><br></pre></td></tr></table></figure><p></p><p>然后我们查询一下。<br></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ curl &quot;http://127.0.0.1:10888/test?query=xxx&quot;</span><br><span class="line"></span><br><span class="line">ddd | 2018-09-10 16:24:32</span><br><span class="line">ddd | 2018-09-10 16:24:33</span><br><span class="line">ddd | 2018-09-10 16:24:34</span><br><span class="line">ddd | 2018-09-10 16:24:34</span><br><span class="line">ddd | 2018-09-10 16:24:35</span><br><span class="line">ddd | 2018-09-10 16:24:35</span><br></pre></td></tr></table></figure><p></p><p>我们看到已经能查到数据。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ls </span><br><span class="line">...</span><br><span class="line">test.sqlite</span><br></pre></td></tr></table></figure><p>我们看到，当前目录已经生成了一个<code>test.sqlite</code>文件。</p><p>我们看看该进程在系统的状态。</p><p><img data-src="https://st.razeen.cn/img/201809/jietu20180911-003048.png" alt="jietu20180911-003048"></p><p>我看看到，该进程打开了<code>.../go/src/test.sqlite</code>数据库文件。</p><p>现在，我们将文件删了。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ rm -rf test.sqlite</span><br><span class="line"></span><br><span class="line">$ ls</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>我们再次调取查询接口。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ curl &quot;http://127.0.0.1:10888/test?query=xxx&quot;</span><br><span class="line"></span><br><span class="line">ddd | 2018-09-10 16:24:32</span><br><span class="line">ddd | 2018-09-10 16:24:33</span><br><span class="line">ddd | 2018-09-10 16:24:34</span><br><span class="line">ddd | 2018-09-10 16:24:34</span><br><span class="line">ddd | 2018-09-10 16:24:35</span><br><span class="line">ddd | 2018-09-10 16:24:35</span><br></pre></td></tr></table></figure><p>我们发现数据还在。</p><p>我们再试试插入数据。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ curl &quot;http://127.0.0.1:10888/test?insert=ddd&quot;</span><br><span class="line">attempt to write a readonly database</span><br></pre></td></tr></table></figure><p>此时，我们发现，没有写入成功，而是显示了一个错误。</p><p>我们在查看一下进程打开的文件。</p><p><img data-src="https://st.razeen.cn/img/201809/jietu20180911-003846.png" alt="jietu20180911-003846"></p><p>我们发现居然是一样的。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ls: .../go/src/test.sqlite: No such file or directory</span><br></pre></td></tr></table></figure><blockquote><p>我们发现并没有该文件。</p></blockquote><h3 id="try-amp-try"><a href="#try-amp-try" class="headerlink" title="try &amp; try"></a>try &amp; try</h3><p>我们先不忙者下结论，我们再看看另外一种写法。</p><p>那就是每次使用完数据库就关闭连接，下次使用再打开。</p><p>代码如下。</p><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"database/sql"</span></span><br><span class="line">	<span class="string">"net/http"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line"></span><br><span class="line">	_ <span class="string">"github.com/mattn/go-sqlite3"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getDB</span><span class="params">()</span> *<span class="title">sql</span>.<span class="title">DB</span></span> &#123;</span><br><span class="line">	db, err := sql.Open(<span class="string">"sqlite3"</span>, <span class="string">"file:test.sqlite"</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> db</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	db := getDB()</span><br><span class="line">	_, err := db.Exec(<span class="string">`CREATE TABLE IF NOT EXISTS test_t(</span></span><br><span class="line"><span class="string">		a TEXT,</span></span><br><span class="line"><span class="string">		create_at TIMESTAMP default CURRENT_TIMESTAMP</span></span><br><span class="line"><span class="string">	);`</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	db.Close()</span><br><span class="line"></span><br><span class="line">	http.HandleFunc(<span class="string">"/test"</span>, <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">		db := getDB()</span><br><span class="line">		<span class="keyword">defer</span> db.Close()</span><br><span class="line">		<span class="keyword">if</span> r.FormValue(<span class="string">"query"</span>) != <span class="string">""</span> &#123;</span><br><span class="line">			rows, err := db.Query(<span class="string">"SELECT * FROM test_t"</span>)</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				w.Write([]<span class="keyword">byte</span>(err.Error()))</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">for</span> rows.Next() &#123;</span><br><span class="line">				<span class="keyword">var</span> a <span class="keyword">string</span></span><br><span class="line">				<span class="keyword">var</span> t time.Time</span><br><span class="line">				err := rows.Scan(&amp;a, &amp;t)</span><br><span class="line">				<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">					w.Write([]<span class="keyword">byte</span>(err.Error()))</span><br><span class="line">					<span class="keyword">return</span></span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				w.Write([]<span class="keyword">byte</span>(a + <span class="string">" | "</span> + t.Format(<span class="string">"2006-01-02 15:04:05"</span>+<span class="string">"\r\n"</span>)))</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> v := r.FormValue(<span class="string">"insert"</span>); v != <span class="string">""</span> &#123;</span><br><span class="line">			_, err := db.Exec(<span class="string">"INSERT INTO test_t (a) VALUES (?)"</span>, v)</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				w.Write([]<span class="keyword">byte</span>(err.Error()))</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line">			w.Write([]<span class="keyword">byte</span>(<span class="string">"OK"</span>))</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		w.Write([]<span class="keyword">byte</span>(<span class="string">"NO"</span>))</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	http.ListenAndServe(<span class="string">":10888"</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们先跑起来。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ go run test-sqlite2.go</span><br></pre></td></tr></table></figure><p>向其中插入一些数据。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ curl &quot;http://127.0.0.1:10888/test?insert=ddd&quot;</span><br><span class="line">OK</span><br></pre></td></tr></table></figure><p>查询一下。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ curl &quot;http://127.0.0.1:10888/test?query=xxx&quot;</span><br><span class="line">ddd | 2018-09-10 23:29:42</span><br><span class="line">ddd | 2018-09-10 23:29:43</span><br><span class="line">ddd | 2018-09-10 23:29:43</span><br><span class="line">ddd | 2018-09-10 23:29:44</span><br></pre></td></tr></table></figure><p>我们将数据库删除。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ rm test.sqlite</span><br></pre></td></tr></table></figure><p>再次查询。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ curl &quot;http://127.0.0.1:10888/test?query=xxx&quot;</span><br><span class="line">no such table: test_t</span><br></pre></td></tr></table></figure><p>此时，给我们表现是，该表已经不存在了。</p><p>我们再查看一下数据库，发现数据库居然还在。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sqlite3 test.sqlite</span><br><span class="line">SQLite version 3.19.3 2017-06-27 16:48:08</span><br><span class="line">Enter &quot;.help&quot; for usage hints.</span><br><span class="line">sqlite &gt; select count(*) from sqlite_master;</span><br><span class="line">0</span><br><span class="line">sqlite &gt;</span><br></pre></td></tr></table></figure><p>虽然库文件依然存在（应该是查询是<code>sql.Open</code>创建的），但其中的数据，表都不存在了。</p><h3 id="so"><a href="#so" class="headerlink" title="so"></a>so</h3><p>通过两种方法的对比，我们比较容易想到, 在第一种操作中，由于我们打开一个数据库连接，始终没有关闭，即使数据库删除后，其引用仍然存在，文件还没留在内存中。后一种，我们每次操作完成后会关闭数据库，导致数据库直接被删除了。</p><p>但，如果数据库很大，内存放不了那么多怎么办？</p><p>所以，这个还有待验证，先记录一下，留个坑给自己。</p>]]></content>
      <categories>
        <category>开发实战总结</category>
      </categories>
      <tags>
        <tag>sqlite3</tag>
      </tags>
  </entry>
  <entry>
    <title>5分钟上手黑群晖 Nas</title>
    <url>//post/synology-hackintosh.html</url>
    <content><![CDATA[<p>今天在家把黑群晖折腾好了，分享一下折腾黑群晖(DS918+)的过程，整个安装过程加起来不到5分钟哦。</p><a id="more"></a><h3 id="硬件准备"><a href="#硬件准备" class="headerlink" title="硬件准备"></a>硬件准备</h3><p>我的<a href="https://razeencheng.com/post/my-first-home-server.html">第一台服务器</a>自从淘汰后，就放在那里吃灰快半年了。这几天得空，在家里折腾折腾，除了换了个小机箱电源（虽然和机箱有点不配），其他都没变。</p><p>整体配置如下：</p><table><thead><tr><th>配件</th><th>备注</th></tr></thead><tbody><tr><td>ASROCK/华擎科技J4105M集成主板</td><td>4核1.5GHz</td></tr><tr><td>海盗船 2400 DDR4 8G x2</td><td></td></tr><tr><td>乔思伯 C2 台式机电脑机箱</td><td></td></tr><tr><td>固态 120G + 西数蓝盘 1T</td><td>祖传的。。。</td></tr><tr><td>华硕 GPS-200PB-189 A 200w 小机箱电源</td><td></td></tr><tr><td>U盘 16G</td></tr></tbody></table><p>16G内存做Nas其实用不上，最后使用率基本是这样子。<br><img data-src="https://st.razeen.cn/img/20210218/16135715109671.jpg" alt></p><p>U盘其实也用不了这么大，有个几百 MB 都够用，只用装一个引导而已，而且安装后需要一直插在上面（当然也有不用一直插在上面的办法，可自行搜索）。</p><h3 id="软件准备"><a href="#软件准备" class="headerlink" title="软件准备"></a>软件准备</h3><p>硬件准备好后，我们就要准备软件了。这里我有一个打包好了，<a href="https://pan.baidu.com/s/1a0sSs1U6v_V-JRqq1_7gsw" target="_blank" rel="noopener">直接下载</a>即可, 密码<code>9cwm</code>。 当然，这几个文件都可以在网上找到，也可以自己去下载。</p><p>下载解压后，目录结构如下：</p><p><img data-src="https://st.razeen.cn/img/20210218/16135728420279.jpg" alt></p><p>其中</p><ul><li>DiskGenius 用来给U盘分区和修改镜像文件的；</li><li>ChipGenius 用来查看VID，PID<sup>[1]</sup>的。据说不正确的VID，PID会导致无法正常安装与休眠；</li><li>ImageWriter 写引导到U盘；</li><li>DS918+_23824.pat DS918+ 6.2.1的安装包；</li><li>Synoboot.img 引导镜像。</li></ul><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>除了上面的软件，硬件外，你还需要一台 windows ==。 然后我们就可以开始安装了。</p><h4 id="U盘分区"><a href="#U盘分区" class="headerlink" title="U盘分区"></a>U盘分区</h4><p>插入准备好的U盘，打开 DiskGenius。</p><p><img data-src="https://st.razeen.cn/img/20210218/16135749647163.jpg" alt></p><p>找到U盘，删除原来U盘上的所有分区（如果你和我一样，这选项是灰的，U盘本来就没分区，就直接看下一步）</p><p><img data-src="https://st.razeen.cn/img/20210218/16135750969995.jpg" alt></p><p>选中这个U盘，点击上面的快速分区。</p><p><img data-src="https://st.razeen.cn/img/20210218/16135751859892.jpg" alt></p><p>选择 MBR 格式分区类型， 且只分一个区。</p><p><img data-src="https://st.razeen.cn/img/20210218/16135752390504.jpg" alt></p><p>确认后，等待一会，分区就完成了。</p><p><img data-src="https://st.razeen.cn/img/20210218/16135752720478.jpg" alt></p><p><img data-src="https://st.razeen.cn/img/20210218/16135752810983.jpg" alt></p><p>分区完成，关闭 DiskGenius.</p><h4 id="查看VID-PID"><a href="#查看VID-PID" class="headerlink" title="查看VID/PID"></a>查看VID/PID</h4><p>打开 ChipGenius 软件，选择U盘设备，查看U盘的完整信息，将 VID/PID 复制保存起来，后面要用。</p><p><img data-src="https://st.razeen.cn/img/20210218/16135754856030.jpg" alt></p><p><img data-src="https://st.razeen.cn/img/20210218/16135754705770.jpg" alt></p><h4 id="写入引导镜像"><a href="#写入引导镜像" class="headerlink" title="写入引导镜像"></a>写入引导镜像</h4><p>打开 ImageWriter 。</p><p><img data-src="https://st.razeen.cn/img/20210218/16135756552205.jpg" alt></p><p>点击文件夹，找到引导镜像 synoboot.img, 设备选中U盘所在的盘符。执行写入，确认继续，稍等片刻。</p><p><img data-src="https://st.razeen.cn/img/20210218/16135757387603.jpg" alt></p><p><img data-src="https://st.razeen.cn/img/20210218/16135757482321.jpg" alt></p><p>很快，镜像就写好了。</p><h4 id="修改镜像"><a href="#修改镜像" class="headerlink" title="修改镜像"></a>修改镜像</h4><p>再次打开 DiskGenius，找到 U盘 &gt; ESP &gt; grub 下面的 grub.cfg 文件， 右击 ‘复制到“桌面”’ 。</p><p><img data-src="https://st.razeen.cn/img/20210218/16135758853878.jpg" alt></p><p>在桌面上找到该文件，用文本编辑器打开。</p><p><img data-src="https://st.razeen.cn/img/20210218/16135760195610.jpg" alt></p><p>如下图，将 VID/PID 改成我们记下来的 VID/PID。</p><p>如果需要 洗白或者半洗白的话 需要修改这里的 sn 和 mac1, 也就是序列号和 Mac地址。</p><p>我咸鱼找了个序列号，半洗白了一下，可以查看 DS Photo 预览图，视频缩略图和转码，不能用QC，已经满足我的需求了。</p><p><img data-src="https://st.razeen.cn/img/20210218/16135765929227.jpg" alt></p><p>下图是我改后的。</p><p><img data-src="https://st.razeen.cn/img/20210218/16135765753215.jpg" alt></p><p>改好之后，保存文件。然后将文件再次拖到 DiskGenius 中覆盖即可。</p><p><img data-src="https://st.razeen.cn/img/20210218/16135766726351.jpg" alt></p><p><img data-src="https://st.razeen.cn/img/20210218/16135766828723.jpg" alt></p><p><img data-src="https://st.razeen.cn/img/20210218/16135766986056.jpg" alt></p><p>到这里我们的U盘引导就制作完成了。</p><h4 id="安装黑群晖"><a href="#安装黑群晖" class="headerlink" title="安装黑群晖"></a>安装黑群晖</h4><p>将U盘插到准备好的机器上（链接好好 鼠标 键盘 显示器 网线），开机后‘狂’按 F2 进bios，将U盘设置为第一启动项，重启后应该可以看到如下选项了。</p><p><img data-src="https://st.razeen.cn/img/20210218/16135771453579.jpg" alt></p><p>选择第一个，然后你应该可以看到下面画面了。</p><p><img data-src="https://st.razeen.cn/img/20210218/16135771818798.jpg" alt></p><p>到这里，我们的引导就安装好了。下面我们需要一台电脑，且和这个Nas在同一个局域网中，去找Nas在局域网中的IP。</p><p>找IP有两种方法，一种就是下载群晖官方的助手 Synology Assistant, 去查找。 还有一种就是直接到路由器上找一下刚刚新增的IP。</p><p>当然，我选择后者。</p><p><img data-src="https://st.razeen.cn/img/20210218/16135775430441.jpg" alt></p><p>找到IP后，就可以输入IP直接连接了。 他会自动跳转到 5000 端口，引导我们安装。</p><p><img data-src="https://st.razeen.cn/img/20210218/16135776318059.jpg" alt></p><p>点击设置。选择手动安装。</p><p><img data-src="https://st.razeen.cn/img/20210218/16135776764307.jpg" alt></p><p>点击浏览，找到我们已经下载好的安装包。</p><p><img data-src="https://st.razeen.cn/img/20210218/16135777496410.jpg" alt></p><p>立即安装，确认。</p><p><img data-src="https://st.razeen.cn/img/20210218/16135777756045.jpg" alt></p><p>然后，就会自动进入安装的环节。</p><p><img data-src="https://st.razeen.cn/img/20210218/16135778114744.jpg" alt></p><p>以及自动重启。</p><p><img data-src="https://st.razeen.cn/img/20210218/16135778383867.jpg" alt></p><p>这个过程，10分钟内应该可以完成。我大概等了5分钟不到。</p><p>完成后就开始创建账户了。按照要求填好，下一步。</p><p><img data-src="https://st.razeen.cn/img/20210218/16135779305789.jpg" alt></p><p>这里更新注意了，不要自动更新！ 选择有更新通知你，但通知你也不要去更新。黑群更新不一定成功哦。</p><p><img data-src="https://st.razeen.cn/img/20210218/16135779841260.jpg" alt></p><p>接下来 QC 直接跳过。</p><p><img data-src="https://st.razeen.cn/img/20210218/16135781100020.jpg" alt></p><p>这样就可以了！</p><p><img data-src="https://st.razeen.cn/img/20210218/16135781267798.jpg" alt></p><p>到这里整个黑群就安装完毕了。浏览器输入 IP 就可以进入群晖的管理节目了。</p><p><img data-src="https://st.razeen.cn/img/20210218/16135782673309.jpg" alt></p><p>基本信息看一下，其中 CPU 有可能识别不准，不过不影响使用。</p><p><img data-src="https://st.razeen.cn/img/20210218/16135784355686.jpg" alt></p><h3 id="设置硬盘"><a href="#设置硬盘" class="headerlink" title="设置硬盘"></a>设置硬盘</h3><p>系统装好了，但要想存东西，我们先得设置好硬盘。</p><p>找到存储空间管理员，安装图片提示操作。</p><p><img data-src="https://st.razeen.cn/img/20210218/16135786157024.jpg" alt></p><p>新增。</p><p><img data-src="https://st.razeen.cn/img/20210218/16135786648046.jpg" alt></p><p>自定义。</p><p><img data-src="https://st.razeen.cn/img/20210218/16135786931984.jpg" alt></p><p>创建存储池。</p><p><img data-src="https://st.razeen.cn/img/20210218/16135787208683.jpg" alt></p><p>性能改善。</p><p><img data-src="https://st.razeen.cn/img/20210218/16135787488011.jpg" alt></p><p>我现在有两个磁盘，型号大小都不一样，就不组 RAID 了。 选 Basic。</p><p><img data-src="https://st.razeen.cn/img/20210218/16135788223636.jpg" alt></p><p>选择 磁盘。</p><p><img data-src="https://st.razeen.cn/img/20210218/16135788362292.jpg" alt></p><p>确认继续。</p><p><img data-src="https://st.razeen.cn/img/20210218/16135788540608.jpg" alt></p><p>磁盘检查一下吧。</p><p><img data-src="https://st.razeen.cn/img/20210218/16135788722276.jpg" alt></p><p>配置存储池。</p><p><img data-src="https://st.razeen.cn/img/20210218/16135789042517.jpg" alt></p><p>就选推荐的文件系统吧。</p><p><img data-src="https://st.razeen.cn/img/20210218/16135789337132.jpg" alt></p><p>应用。</p><p><img data-src="https://st.razeen.cn/img/20210218/16135789459220.jpg" alt></p><p>这样，一个存储空间就新建好了。</p><p><img data-src="https://st.razeen.cn/img/20210218/16135789725264.jpg" alt></p><p>然后，我们就可以新建一个 共享文件夹了。</p><p>在 控制面板 〉 文件共享 〉共享文件夹 〉新增 〉新增，然后选择该文件夹的位置，下一步，后面基本使用默认就可以了，直接下一步，下一步，最后应用。<br><img data-src="https://st.razeen.cn/img/20210218/16135797146962.jpg" alt></p><p>设置好后，在 windows 上输入 Nas 的 IP 就可以打开共享文件夹了（第一次会跳出鉴权的，输入登陆Nas的用户名密码就可以了）。</p><p>如，我的。<br><img data-src="https://st.razeen.cn/img/20210218/16135800156739.jpg" alt></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>黑群晖的安装，还是相对比较简单的。群晖的插件也还不少。我装黑群晖主要就是为了他的文件共享和图片备份功能。结合 DS File App 我可以将手机上的照片自动同步到家里，美滋滋。</p><p>分享几个场景，其中关于如何设置公网访问，下篇博客再总结一下。</p><ul><li><p>iPad 上 File 连接 Nas 分享文件。<br><img data-src="https://st.razeen.cn/img/20210218/16135805119820.jpg" alt></p></li><li><p>外网访问，管理，查看照片。</p></li></ul><p><img data-src="https://st.razeen.cn/img/20210218/16135807903638.jpg" alt></p><p><img data-src="https://st.razeen.cn/img/20210218/16135808152655.jpg" alt></p><ul><li>手机App自动备份照片。<br><img data-src="https://st.razeen.cn/img/20210218/16135810208036.jpg" alt></li></ul><h3 id="拓展知识"><a href="#拓展知识" class="headerlink" title="拓展知识"></a>拓展知识</h3><p><strong>[1]. VID/PID 是什么？</strong></p><p>VID = vendor ID ( 设备的生产厂家ID，正常的话是需要申请的 ）<br>PID = product ID （ 设备的产品ID，厂家自定义的 ）</p><p>这么一看，其实就是用来是识别设备是哪家生产的什么产品，像我们的名字一样。</p>]]></content>
      <categories>
        <category>家庭网络折腾</category>
        <category>NAS</category>
      </categories>
      <tags>
        <tag>nas</tag>
      </tags>
  </entry>
  <entry>
    <title>终极 Bash 脚本指南</title>
    <url>//post/the-ultimate-programmers-guide-to-bash-scripting.html</url>
    <content><![CDATA[<p>在开发的过程中，经常需要处理一些重复的工作，或者逻辑相当简单但耗时的功能，这时我们可能会考虑到用脚本来自动化完成这些工作。而 Bash 脚本是我们最容易接触到和上手的脚本语言。</p><p>这篇博客汇总一些常用的 Bash 语法，方便日后查阅学习。</p><a id="more"></a><h3 id="hello-world"><a href="#hello-world" class="headerlink" title="hello world"></a>hello world</h3><p>不管写啥，上来先输出个<code>hello world</code>。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"hello world"</span></span><br></pre></td></tr></table></figure><p>创建一个文件<code>hello.sh</code> 包含以上内容，同时赋予执行权限，然后执行，一个<code>hello world</code> 就好了。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 添加执行权限</span></span><br><span class="line">$ chmod +x hello.sh</span><br><span class="line"></span><br><span class="line">$ ./hello.sh</span><br><span class="line">hello world</span><br></pre></td></tr></table></figure><h3 id="解释器"><a href="#解释器" class="headerlink" title="解释器"></a>解释器</h3><p>我们看到这个<code>hello.sh</code> 脚本，第一行有个 <code>#!/bin/bash</code> 。 这个是用来指定该脚本在 UNIX/Linux 下执行时用到的解释器。</p><p>执行<code>cat /etc/shells</code> 我们可以看到自己的系统中都有哪些解释器。如我的：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ cat /etc/shells</span><br><span class="line"><span class="comment"># /etc/shells: valid login shells</span></span><br><span class="line">/bin/sh</span><br><span class="line">/bin/bash</span><br><span class="line">/usr/bin/bash</span><br><span class="line">/bin/rbash</span><br><span class="line">/usr/bin/rbash</span><br><span class="line">/bin/dash</span><br><span class="line">/usr/bin/dash</span><br><span class="line">/bin/zsh</span><br><span class="line">/usr/bin/zsh</span><br><span class="line">/usr/bin/tmux</span><br></pre></td></tr></table></figure><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>用 <code>#</code> 来注释。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># 这是注释</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"hello world"</span></span><br></pre></td></tr></table></figure><h3 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h3><p>Bash 中变量命名是大小写敏感的，很多喜欢全大写。当然你也可以使用 小写英文字母，数字和下划线，但不能以数字开头。 给变量赋值的时候 <code>=</code> 号前后不能有空格。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 有效的</span></span><br><span class="line">FIRSTLETTERS=<span class="string">"ABC"</span></span><br><span class="line">FIRST_THREE_LETTERS=<span class="string">"ABC"</span></span><br><span class="line">firstThreeLetters=<span class="string">"ABC"</span></span><br><span class="line">MY_SHELL=<span class="string">"bash"</span></span><br><span class="line">my_another_shell=<span class="string">"my another shell"</span></span><br><span class="line">My_Shell=<span class="string">"My shell"</span></span><br><span class="line">_myshell=<span class="string">"My shell"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 无效的</span></span><br><span class="line">3LETTERS=<span class="string">"ABC"</span></span><br><span class="line">first-three-letters=<span class="string">"ABC"</span></span><br><span class="line">first@Thtree@Letters=<span class="string">"ABC"</span></span><br><span class="line">ABC = <span class="string">"ABC "</span></span><br><span class="line">MY_SHELL = <span class="string">"bash"</span></span><br><span class="line">My-SHELL=<span class="string">"bash"</span></span><br><span class="line">1MY_SHELL=<span class="string">"My shell"</span></span><br></pre></td></tr></table></figure><h3 id="变量引用"><a href="#变量引用" class="headerlink" title="变量引用"></a>变量引用</h3><p>当你要使用变量的时候，用 <code>$</code> 来引用， 如果后面要接一些其他字符，可以用<code>{}</code> 括起来。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">WORLD=<span class="string">"world world"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"hello <span class="variable">$WORLD</span>"</span>  <span class="comment"># hello world world</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"hello <span class="variable">$&#123;WORLD&#125;</span>2"</span> <span class="comment"># hello world world2</span></span><br></pre></td></tr></table></figure><p>在 Bash 中要注意 单引号 <code>&#39;</code> , 双引号 <code>&quot;</code> ,反引号 ` 的区别。</p><p>单引号，双引号都能用来保留引号内的为文字值，其差别在于，双引号在遇到 <code>$(参数替换)</code> , 反引号 `(命令替换) 的时候有例外，单引号则剥夺其中所有字符的特殊含义。</p><p>而反引号的作用 和 <code>$()</code> 是差不多的。 在执行一条命令的时候，会先执行其中的命令，再把结果放到原命令中。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">var=<span class="string">"music"</span></span><br><span class="line">sports=<span class="string">'sports'</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"I like <span class="variable">$var</span>"</span>   <span class="comment"># I like music</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"I like <span class="variable">$&#123;var&#125;</span>"</span> <span class="comment"># I like music</span></span><br><span class="line"><span class="built_in">echo</span> I like <span class="variable">$var</span>     <span class="comment"># I like music</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">'I like $var'</span>   <span class="comment"># I like $var</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"I like \$var"</span>  <span class="comment"># I like $var</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">'I like \$var'</span>  <span class="comment"># I like \$var</span></span><br><span class="line"><span class="built_in">echo</span> `bash -version` <span class="comment"># GNU bash, version 5.0.17(1)-release (x86_64-pc-linux-gnu)...</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">'bash -version'</span> <span class="comment"># bash -version</span></span><br></pre></td></tr></table></figure><h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><p>Linux 的环境变量包含了存储在系统中的信息。我们可以在终端中找到一些环境变量。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ env </span><br><span class="line"><span class="comment"># 或</span></span><br><span class="line">$ printenv</span><br></pre></td></tr></table></figure><p>你可以在脚本中引用这些环境变量。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$SHELL</span>, <span class="variable">$USER</span>, <span class="variable">$HOME</span> </span><br><span class="line"></span><br><span class="line"><span class="comment"># /usr/bin/zsh, razeen, /home/razeen</span></span><br></pre></td></tr></table></figure><p><a href="https://tldp.org/LDP/Bash-Beginners-Guide/html/sect_03_02.html" target="_blank" rel="noopener">这里</a> 还有更多。</p><h3 id="内部变量"><a href="#内部变量" class="headerlink" title="内部变量"></a>内部变量</h3><p>Bash 的内部变量也不少，有时我们可能会用到，如 <code>$BASHPID</code> <code>$IFS</code> <code>$PWD</code> 等，更多看<a href="https://tldp.org/LDP/abs/html/internalvariables.html" target="_blank" rel="noopener">这里</a> 。</p><h3 id="将命令输出分配给变量"><a href="#将命令输出分配给变量" class="headerlink" title="将命令输出分配给变量"></a>将命令输出分配给变量</h3><p>可以使用 <code>$(command)</code> 将命令输出存储在变量中。例如这是一个<code>info.sh</code>脚本内容:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">LIST=$(ls -l)</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"File information: <span class="variable">$LIST</span>"</span></span><br></pre></td></tr></table></figure><p>执行（别忘了给执行权限）</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ./info.sh</span><br><span class="line">File information: total 8</span><br><span class="line">-rwxrwxr-x 1 razeen razeen 85 2月   5 07:35 hello.sh</span><br><span class="line">-rwxrwxr-x 1 razeen razeen 58 2月   5 07:36 info.sh</span><br></pre></td></tr></table></figure><p>下面的脚本会将时间和日期，用户名以及系统正常运行时间保存到日志文件中。</p><p>其中 <code>&gt;</code> 是重定向之一，它将覆盖文件。使用 <code>&gt;&gt;</code> 可以将输出追加到文件。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">DATE=$(date -u) <span class="comment"># UTC 时间#!/bin/bash</span></span><br><span class="line">DATE=$(date -u) <span class="comment"># UTC 时间</span></span><br><span class="line">WHO=$(whoami) <span class="comment"># 用户名</span></span><br><span class="line">UPTIME=$(uptime) <span class="comment"># 系统运行时间</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Today is <span class="variable">$DATE</span>. You are <span class="variable">$WHO</span>. Uptime info: <span class="variable">$UPTIME</span>"</span> &gt; logfile</span><br><span class="line">WHO=$(whoami) <span class="comment"># 用户名</span></span><br><span class="line">UPTIME=$(uptime) <span class="comment"># 系统运行时间</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Today is <span class="variable">$DATE</span>. You are <span class="variable">$WHO</span>. Uptime info: <span class="variable">$UPTIME</span>"</span> &gt; logfile</span><br></pre></td></tr></table></figure><p><img data-src="https://st.razeen.cn/img/20210205074148_image-20210205074148588.png" alt="image-20210205074148588"></p><h3 id="内建命令"><a href="#内建命令" class="headerlink" title="内建命令"></a>内建命令</h3><p><code>Shell</code> 内建命令是可以直接在<code>Shell</code>中运行的命令。可以这么查看内建命令：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ compgen -b | sort</span><br><span class="line">-</span><br><span class="line">.</span><br><span class="line">:</span><br><span class="line">[</span><br><span class="line"><span class="built_in">alias</span></span><br><span class="line"><span class="built_in">autoload</span></span><br><span class="line"><span class="built_in">bg</span></span><br><span class="line"><span class="built_in">bindkey</span></span><br><span class="line"><span class="built_in">break</span></span><br><span class="line"><span class="built_in">builtin</span></span><br><span class="line"><span class="built_in">bye</span></span><br><span class="line"><span class="built_in">cd</span></span><br></pre></td></tr></table></figure><p>也可以用 <code>type</code> 查看命令的类型。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">type</span> <span class="built_in">cd</span></span><br><span class="line"><span class="built_in">cd</span> is a shell <span class="built_in">builtin</span></span><br></pre></td></tr></table></figure><p>可以用 <code>which</code> 命令查看可执行文件的文件路径：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># which sort</span></span><br><span class="line">/usr/bin/sort</span><br></pre></td></tr></table></figure><p>可通过 <code>man builtins</code> 查看内建命令的详细描述。</p><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><h4 id="IF条件表达式"><a href="#IF条件表达式" class="headerlink" title="IF条件表达式"></a>IF条件表达式</h4><p><code>if</code> 后面需要接者<code>then</code>：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> [ condition-for-test ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">  <span class="built_in">command</span></span><br><span class="line">  ...</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p>或者，</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> [ condition-for-test ]; <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">command</span></span><br><span class="line">  ...</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p>如：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"> </span><br><span class="line">VAR=myvar</span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$VAR</span> = myvar ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"1: \$VAR is <span class="variable">$VAR</span>"</span>   <span class="comment"># 1: $VAR is myvar</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">"<span class="variable">$VAR</span>"</span> = myvar ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"2: \$VAR is <span class="variable">$VAR</span>"</span>   <span class="comment"># 2: $VAR is myvar</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$VAR</span> = <span class="string">"myvar"</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"3: \$VAR is <span class="variable">$VAR</span>"</span>   <span class="comment"># 3: $VAR is myvar</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">"<span class="variable">$VAR</span>"</span> = <span class="string">"myvar"</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"4: \$VAR is <span class="variable">$VAR</span>"</span>   <span class="comment"># 4: $VAR is myvar</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p>上面，我们在比较时，可以用双引号把变量引用起来。</p><p>但要注意单引号的使用。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">VAR=myvar</span><br><span class="line"><span class="keyword">if</span> [ <span class="string">'$VAR'</span> = <span class="string">'myvar'</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">'5a: $VAR is $VAR'</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"5b: Not equal."</span></span><br><span class="line">fibas</span><br><span class="line"><span class="comment"># Output:</span></span><br><span class="line"><span class="comment"># 5b: Not equal.</span></span><br></pre></td></tr></table></figure><p>上面这个就把 ‘$VAR’ 当一个字符串了。</p><p>但如果变量是多个单词，我们就必须用到双引号了，如</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 这样写就有问题</span></span><br><span class="line">VAR1=<span class="string">"my var"</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$VAR1</span> = <span class="string">"my var"</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"\$VAR1 is <span class="variable">$VAR1</span>"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="comment"># Output</span></span><br><span class="line"><span class="comment"># error [: too many arguments</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 用双引号</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">"<span class="variable">$VAR1</span>"</span> = <span class="string">"my var"</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"\$VAR1 is <span class="variable">$VAR1</span>"</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p>总的来说，双引号可以一直加上。</p><h4 id="空格问题"><a href="#空格问题" class="headerlink" title="空格问题"></a>空格问题</h4><p>比较表达式中，如果<code>=</code>前后没有空格，那么整个表法式会被认为是一个单词，其判断结果为<code>True</code>.</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"> </span><br><span class="line">VAR2=2</span><br><span class="line"><span class="comment">#  由于被识别成一个单词， [] 里面为 true</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">"<span class="variable">$VAR2</span>"</span>=1 ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"<span class="variable">$VAR2</span> is 1."</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"<span class="variable">$VAR2</span> is not 1."</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="comment"># Output</span></span><br><span class="line"><span class="comment"># 2 is 1.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 前后加上空格就好了</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">"<span class="variable">$VAR2</span>"</span> = 1 ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"<span class="variable">$VAR2</span> is 1."</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"<span class="variable">$VAR2</span> is not 1."</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="comment"># Output</span></span><br><span class="line"><span class="comment"># 2 is not 1.</span></span><br></pre></td></tr></table></figure><p>另外需要注意的是， 在判断中，中括号 <code>[</code> 和变量之间一定要有一个空格，<code>=</code> 或者 <code>==</code>。 如果缺少了空格，你可能会到这类似这样的错误：<code>unary operator expected’ or missing</code>]` 。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 正确， 符号前后有空格</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$VAR2</span> = 1 ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"\$VAR2 is 1."</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"It's not 1."</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="comment"># Output</span></span><br><span class="line"><span class="comment"># 2 is 1.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 错误， 符号前后无空格</span></span><br><span class="line"><span class="keyword">if</span> [<span class="variable">$VAR2</span>=1]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"<span class="variable">$VAR2</span> is 1."</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"It's not 1."</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="comment"># Output</span></span><br><span class="line"><span class="comment"># line 3: =1: command not found</span></span><br><span class="line"><span class="comment"># line 5: [=1]: command not found</span></span><br><span class="line"><span class="comment"># It's not 1.</span></span><br></pre></td></tr></table></figure><h4 id="文件测试表达式"><a href="#文件测试表达式" class="headerlink" title="文件测试表达式"></a>文件测试表达式</h4><p>对文件进行相关测试，判断的表达式如下：</p><table><thead><tr><th style="text-align:left">表达式</th><th style="text-align:left">True</th></tr></thead><tbody><tr><td style="text-align:left"><em>file1</em> -nt <em>file2</em></td><td style="text-align:left"><em>file1</em> 比 <em>file2</em> 新。</td></tr><tr><td style="text-align:left"><em>file1</em> -ot <em>file2</em></td><td style="text-align:left"><em>file1</em> 比 <em>file2</em> 老。</td></tr><tr><td style="text-align:left">-d <em>file</em></td><td style="text-align:left">文件<em>file</em>存在，且是一个文件夹。</td></tr><tr><td style="text-align:left">-e <em>file</em></td><td style="text-align:left">文件 <em>file</em> 存在。</td></tr><tr><td style="text-align:left">-f <em>file</em></td><td style="text-align:left">文件<em>file</em>存在，且为普通文件。</td></tr><tr><td style="text-align:left">-L <em>file</em></td><td style="text-align:left">文件<em>file</em>存在，且为符号连接。</td></tr><tr><td style="text-align:left">-O <em>file</em></td><td style="text-align:left">文件 <em>flle</em> 存在, 且由有效用户ID拥有。</td></tr><tr><td style="text-align:left">-r <em>file</em></td><td style="text-align:left">文件 <em>flle</em> 存在, 且是一个可读文件。</td></tr><tr><td style="text-align:left">-s <em>file</em></td><td style="text-align:left">文件 <em>flle</em> 存在, 且长度大于0。</td></tr><tr><td style="text-align:left">-w file</td><td style="text-align:left">文件 <em>flle</em> 可写入。</td></tr><tr><td style="text-align:left">-x file</td><td style="text-align:left">文件 <em>flle</em> 可写执行。</td></tr></tbody></table><p>可以使用<code>man test</code>查看那详细的说明。</p><p>当表达式为<code>True</code>时，测试命令返回退出状态 0，而表达式为<code>False</code>时返回退出状态1。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">FILE=<span class="string">"/etc/resolv.conf"</span></span><br><span class="line"><span class="keyword">if</span> [ -e <span class="string">"<span class="variable">$FILE</span>"</span> ]; <span class="keyword">then</span></span><br><span class="line">  <span class="keyword">if</span> [ -f <span class="string">"<span class="variable">$FILE</span>"</span> ]; <span class="keyword">then</span></span><br><span class="line">      <span class="built_in">echo</span> <span class="string">"<span class="variable">$FILE</span> is a file."</span></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line">  <span class="keyword">if</span> [ -d <span class="string">"<span class="variable">$FILE</span>"</span> ]; <span class="keyword">then</span></span><br><span class="line">      <span class="built_in">echo</span> <span class="string">"<span class="variable">$FILE</span> is a directory."</span></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line">  <span class="keyword">if</span> [ -r <span class="string">"<span class="variable">$FILE</span>"</span> ]; <span class="keyword">then</span></span><br><span class="line">      <span class="built_in">echo</span> <span class="string">"<span class="variable">$FILE</span> is readable."</span></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><h4 id="字符串比较表达式"><a href="#字符串比较表达式" class="headerlink" title="字符串比较表达式"></a>字符串比较表达式</h4><table><thead><tr><th style="text-align:left">表达式</th><th style="text-align:left">True</th></tr></thead><tbody><tr><td style="text-align:left"><em>string1 = string2</em> 或 <em>string1 == string2</em></td><td style="text-align:left">两字符相等</td></tr><tr><td style="text-align:left"><em>string1</em> != <em>string2</em></td><td style="text-align:left">两个字符串不相等</td></tr><tr><td style="text-align:left"><em>string1</em> &gt; <em>string2</em></td><td style="text-align:left"><em>string1</em> 大于 <em>string2</em>.</td></tr><tr><td style="text-align:left"><em>string1</em> &lt; <em>string2</em></td><td style="text-align:left"><em>string1</em> 小于<em>string2</em>.</td></tr><tr><td style="text-align:left">-n <em>string</em></td><td style="text-align:left">字符串长度大于0</td></tr><tr><td style="text-align:left">-z <em>string</em></td><td style="text-align:left">字符串长度等于0</td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">STRING=<span class="string">""</span></span><br><span class="line"><span class="keyword">if</span> [ -z <span class="string">"<span class="variable">$STRING</span>"</span> ]; <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"There is no string."</span> &gt;&amp;2 </span><br><span class="line">  <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Output</span></span><br><span class="line"><span class="comment"># There is no string.</span></span><br></pre></td></tr></table></figure><p>其中<code>&gt;&amp;2</code>将错误信息定位到标准错误输出。</p><h4 id="数字比较表达式"><a href="#数字比较表达式" class="headerlink" title="数字比较表达式"></a>数字比较表达式</h4><p>下面这些是用来比较数字的一些表达式。</p><table><thead><tr><th style="text-align:left">[…]</th><th style="text-align:left">((…))</th><th style="text-align:left">True</th></tr></thead><tbody><tr><td style="text-align:left">[ “int1” -eq “int2” ]</td><td style="text-align:left">(( “int1” == “int2” ))</td><td style="text-align:left">相等.</td></tr><tr><td style="text-align:left">[ “int1” -nq “int2” ]</td><td style="text-align:left">(( “int1” != “int2” ))</td><td style="text-align:left">不等.</td></tr><tr><td style="text-align:left">[ “int1” -lt “int2” ]</td><td style="text-align:left">(( “int1” &lt; “int2” ))</td><td style="text-align:left">int2 大于 int1.</td></tr><tr><td style="text-align:left">[ “int1” -le “int2” ]</td><td style="text-align:left">(( “int1” &lt;= “int2” ))</td><td style="text-align:left">int2 大于等于 int1.</td></tr><tr><td style="text-align:left">[ “int1” -gt “int2” ]</td><td style="text-align:left">(( “int1 &gt; “int2” ))</td><td style="text-align:left">int1 大于 int2</td></tr><tr><td style="text-align:left">[ “int1” -ge “int2” ]</td><td style="text-align:left">(( “int1 &gt;= “int2” ))</td><td style="text-align:left">int1 大于等于 int2</td></tr></tbody></table><h4 id="双括号"><a href="#双括号" class="headerlink" title="双括号 (())"></a>双括号 <code>(())</code></h4><p>数值的比较或者计算可以用<code>((... ))</code>。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">a=3</span><br><span class="line">b=4</span><br><span class="line">c=3</span><br><span class="line"><span class="keyword">if</span> ((<span class="string">"<span class="variable">$a</span>"</span> &lt; <span class="string">"<span class="variable">$b</span>"</span>)); <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"<span class="variable">$a</span> is less than <span class="variable">$b</span>."</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"<span class="variable">$a</span> is not less than <span class="variable">$b</span>."</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">if</span> ((<span class="string">"<span class="variable">$a</span>"</span> != <span class="string">"<span class="variable">$c</span>"</span>)); <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"<span class="variable">$a</span> is not equal to <span class="variable">$c</span>."</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"<span class="variable">$a</span> is equal to <span class="variable">$c</span>."</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"<span class="variable">$a</span> + <span class="variable">$b</span> = <span class="variable">$(($a + $b)</span>)"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Output</span></span><br><span class="line"><span class="comment"># 3 is less than 4.</span></span><br><span class="line"><span class="comment"># 3 is equal to 3.</span></span><br><span class="line"><span class="comment"># 3 + 4 = 7</span></span><br></pre></td></tr></table></figure><h3 id="怎么使用-if-else-和-if-elif-else"><a href="#怎么使用-if-else-和-if-elif-else" class="headerlink" title="怎么使用 if/else 和 if/elif/else"></a>怎么使用 if/else 和 if/elif/else</h3><p>其实上面已经展示了不少了，这里总结下<code>if...else</code> 和 <code>if...elif...else</code> 语句。</p><p><code>if/else</code> 语句格式如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> [ condition-is-true ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">  <span class="built_in">command</span> A</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="built_in">command</span> B</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 或</span></span><br><span class="line"><span class="keyword">if</span> [ condition-is-true ]; <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">command</span> A</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="built_in">command</span> B</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p>例如:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">MY_SHELL=<span class="string">"csh"</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">"<span class="variable">$MY_SHELL</span>"</span> = <span class="string">"bash"</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"You are using the bash shell."</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"You are not using the bash shell."</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p><code>if/elif/else</code> 语句格式如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> [ condition-is-true ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">  <span class="built_in">command</span> A</span><br><span class="line"><span class="keyword">elif</span> [ condition-is-true ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">  <span class="built_in">command</span> B</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="built_in">command</span> C</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="comment"># or</span></span><br><span class="line"><span class="keyword">if</span> [ condition-is-true ]; <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">command</span> A</span><br><span class="line"><span class="keyword">elif</span> [ condition-is-true ]; <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">command</span> B</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="built_in">command</span> C</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p>如:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">MY_SHELL=<span class="string">"csh"</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">"<span class="variable">$MY_SHELL</span>"</span> = <span class="string">"bash"</span> ]; <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"You are using the bash shell."</span></span><br><span class="line"><span class="keyword">elif</span> [ <span class="string">"<span class="variable">$MY_SHELL</span>"</span> = <span class="string">"csh"</span> ]; <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"You are using csh."</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"You are not using the bash shell."</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><h3 id="双中括号的使用"><a href="#双中括号的使用" class="headerlink" title="双中括号的使用[[]]"></a>双中括号的使用<code>[[]]</code></h3><p>如用用于比较的变量不是单个单词，就需要<code>[[]]</code> , 或者用单中括号(这时需要加双引号)。 在平常的使用中，最好都使用<code>[[]]</code>。</p><p>与单中括号相比，双中括号具有其他功能。 如，可以对其中正则使用逻辑<code>&amp;&amp;</code>和<code>||</code>和<code>=〜</code>。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">VAR1=<span class="string">"variable"</span></span><br><span class="line">VAR2=<span class="string">"variable 2"</span></span><br><span class="line"><span class="keyword">if</span> [[ (VAR1 == <span class="string">"variable"</span>)  ]]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"They are the same."</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"Not the same."</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 &amp;&amp;</span></span><br><span class="line">[[ (<span class="variable">$VAR1</span> == variable) &amp;&amp; (</span><br><span class="line"><span class="variable">$VAR2</span> == <span class="string">"variable 2"</span>) ]] &amp;&amp; <span class="built_in">echo</span> <span class="string">"They are the same again."</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">digit=4</span><br><span class="line"><span class="keyword">if</span> [[ <span class="variable">$digit</span> =~ [0-9] ]]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"<span class="variable">$digit</span> is a digit"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"<span class="variable">$digit</span> isn't a digit"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line">letter=<span class="string">"abc"</span></span><br><span class="line"><span class="keyword">if</span> [[ <span class="variable">$letter</span> =~ [0-9] ]]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"<span class="variable">$letter</span> is a digit"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"<span class="variable">$letter</span> isn't a digit"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Output</span></span><br><span class="line"><span class="comment"># 4 is a digit</span></span><br><span class="line"><span class="comment"># abc isn't a digit</span></span><br></pre></td></tr></table></figure><h3 id="怎么使用-For-循环"><a href="#怎么使用-For-循环" class="headerlink" title="怎么使用 For 循环"></a>怎么使用 For 循环</h3><p><code>for</code>循环的使用如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> VARIABLE_NAME <span class="keyword">in</span> ITEM_1 ITEM_N</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  <span class="built_in">command</span> A</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>例如:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="keyword">for</span> COLOR <span class="keyword">in</span> red green blue</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"COLOR: <span class="variable">$COLOR</span>"</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Output</span></span><br><span class="line"><span class="comment"># COLOR: red</span></span><br><span class="line"><span class="comment"># COLOR: green</span></span><br><span class="line"><span class="comment"># COLOR: blue</span></span><br></pre></td></tr></table></figure><p>可以在其中使用变量，如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">COLORS=<span class="string">"red green blue"</span></span><br><span class="line"><span class="keyword">for</span> COLOR <span class="keyword">in</span> <span class="variable">$COLORS</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"COLOR: <span class="variable">$COLOR</span>"</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><h4 id="用-for-循环重命名文件"><a href="#用-for-循环重命名文件" class="headerlink" title="用 for 循环重命名文件"></a>用 <code>for</code> 循环重命名文件</h4><p>我们举个简单的例子，用<code>for</code>循环重命名当前目录下的jpg图片。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">IMGS=$(ls *jpg)</span><br><span class="line">DATE=$(date +%F)</span><br><span class="line"><span class="keyword">for</span> IMG <span class="keyword">in</span> <span class="variable">$IMGS</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"Renaming <span class="variable">$&#123;IMG&#125;</span> to <span class="variable">$&#123;DATE&#125;</span>-<span class="variable">$&#123;IMG&#125;</span>"</span></span><br><span class="line">  mv <span class="variable">$&#123;IMG&#125;</span> <span class="variable">$&#123;DATE&#125;</span>-<span class="variable">$&#123;IMG&#125;</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p><img data-src="https://st.razeen.cn/img/20210213170152_image-20210213170152011.png" alt="image-20210213170152011"></p><h3 id="怎么传参"><a href="#怎么传参" class="headerlink" title="怎么传参"></a>怎么传参</h3><p>执行脚本的时候，后面可以跟着很多参数，如：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ scriptname param1 param2 param3</span><br></pre></td></tr></table></figure><p><code>param1</code> 到 <code>param3</code> 称为可选参数， 可以在脚本中用 <code>$0</code>, <code>$1</code>, <code>$2</code>等，来引用这些参赛。例如:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"'\$0' is <span class="variable">$0</span>"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"'\$1' is <span class="variable">$1</span>"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"'\$2' is <span class="variable">$2</span>"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"'\$3' is <span class="variable">$3</span>"</span></span><br></pre></td></tr></table></figure><p>输出:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ./param.sh</span><br><span class="line"><span class="string">'$0'</span> is ./param.sh</span><br><span class="line"><span class="string">'$1'</span> is</span><br><span class="line"><span class="string">'$2'</span> is</span><br><span class="line"><span class="string">'$3'</span> is</span><br></pre></td></tr></table></figure><p><code>$0</code> 参数0返回的是当前执行文件的名字，包括路径。</p><p>可以用 <code>$@</code> 接受所以的参数。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="keyword">for</span> PARAM <span class="keyword">in</span> <span class="variable">$@</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"Param is: <span class="variable">$PARAM</span>"</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>Using this script:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ./params.sh a b c d e f</span><br><span class="line">Param is: a</span><br><span class="line">Param is: b</span><br><span class="line">Param is: c</span><br><span class="line">Param is: d</span><br><span class="line">Param is: e</span><br><span class="line">Param is: f</span><br></pre></td></tr></table></figure><h3 id="怎么接收用户输入"><a href="#怎么接收用户输入" class="headerlink" title="怎么接收用户输入"></a>怎么接收用户输入</h3><p>用户输入称为<code>STDIN</code>。可以将<code>read</code>命令与<code>-p</code>（提示）选项一起使用来读取用户输入，它将输出提示字符串。 <code>-r</code> 选项不允许反斜杠转义任何字符。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">read</span> -rp <span class="string">"PROMPT"</span> VARIABLE</span><br></pre></td></tr></table></figure><p>例如:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">read</span> -rp <span class="string">"Enter your programming languages: "</span> PROGRAMMES</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Your programming languages are: "</span></span><br><span class="line"><span class="keyword">for</span> PROGRAMME <span class="keyword">in</span> <span class="variable">$PROGRAMMES</span>; <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"<span class="variable">$PROGRAMME</span> "</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>运行:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ./read.sh</span><br><span class="line">Enter your programming languages: go py</span><br><span class="line">Your programming languages are:</span><br><span class="line">go</span><br><span class="line">py</span><br></pre></td></tr></table></figure><h3 id="用大括号来表示范围"><a href="#用大括号来表示范围" class="headerlink" title="用大括号来表示范围 {}"></a>用大括号来表示范围 <code>{}</code></h3><p>如下所示，我们可以用大括号来表所一个数字或字母的范围。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> &#123;0..3&#125;</span><br><span class="line">$ <span class="built_in">echo</span> &#123;a..d&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># output: </span></span><br><span class="line"><span class="comment"># 0 1 2 3</span></span><br><span class="line"><span class="comment"># a b c d</span></span><br></pre></td></tr></table></figure><p>你也可以在 <code>for</code> 循环中这么使用:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> &#123;0..9&#125;; </span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">  touch file_<span class="string">"<span class="variable">$i</span>"</span>.txt; </span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>This will create different file names with different modification times.</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ls -al file_*</span><br><span class="line">-rw-rw-r-- 1 razeen razeen 0 2月  14 09:54 file_0.txt</span><br><span class="line">-rw-rw-r-- 1 razeen razeen 0 2月  14 09:54 file_1.txt</span><br><span class="line">-rw-rw-r-- 1 razeen razeen 0 2月  14 09:54 file_2.txt</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="怎么使用While"><a href="#怎么使用While" class="headerlink" title="怎么使用While"></a>怎么使用While</h3><p>当 While 后的表达式结果为 <code>true</code>时，执行循环内语句。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">i=1</span><br><span class="line"><span class="keyword">while</span> [ <span class="variable">$i</span> -le 5 ]; <span class="keyword">do</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$i</span></span><br><span class="line">  ((i++))</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>Output:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td></tr></table></figure><h3 id="退出码-返回码-是什么？"><a href="#退出码-返回码-是什么？" class="headerlink" title="退出码/返回码 是什么？"></a>退出码/返回码 是什么？</h3><p>每个命令都返回退出状态，范围为0-255。 0代表成功，非0代表错误。 可以用来进行错误检查。</p><table><thead><tr><th style="text-align:left">数值</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td style="text-align:left">0</td><td style="text-align:left">成功</td></tr><tr><td style="text-align:left">2</td><td style="text-align:left">返回内置命令，从而提示错误</td></tr><tr><td style="text-align:left">126</td><td style="text-align:left">命令找到了，但不是可执行的</td></tr><tr><td style="text-align:left">127</td><td style="text-align:left">没有找到命令</td></tr><tr><td style="text-align:left">128+N</td><td style="text-align:left">由于接收到信号N，命令退出</td></tr></tbody></table><h4 id="怎么检查退出码"><a href="#怎么检查退出码" class="headerlink" title="怎么检查退出码"></a>怎么检查退出码</h4><p><code>$?</code> 包含了上一条命令执行的返回码。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ls ./no/exist</span><br><span class="line">ls: cannot access <span class="string">'./no/exist'</span>: No such file or directory</span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">"$?"</span></span><br><span class="line">2</span><br></pre></td></tr></table></figure><p>如，在<code>if</code>表达式中检查返回码:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">HOST=<span class="string">"razeen.cn"</span></span><br><span class="line">ping -c 1 <span class="variable">$HOST</span></span><br><span class="line">RETURN_CODE=$?</span><br><span class="line"><span class="keyword">if</span> [ <span class="string">"<span class="variable">$RETURN_CODE</span>"</span> -eq <span class="string">"0"</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"<span class="variable">$HOST</span> reachable."</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"<span class="variable">$HOST</span> unreachable."</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p><code>-c 1</code> 参数表示发送一个可达包就停止发送。 然后我们检查一下<code>ping</code>执行的返回码。</p><p>输出:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ./ex.sh</span><br><span class="line">PING razeen.cn (47.108.161.7) 56(84) bytes of data.</span><br><span class="line">64 bytes from 47.108.161.7 (47.108.161.7): icmp_seq=1 ttl=50 time=38.5 ms</span><br><span class="line"></span><br><span class="line">--- razeen.cn ping statistics ---</span><br><span class="line">1 packets transmitted, 1 received, 0% packet loss, time 0ms</span><br><span class="line">rtt min/avg/max/mdev = 38.541/38.541/38.541/0.000 ms</span><br><span class="line">razeen.cn reachable.</span><br></pre></td></tr></table></figure><h3 id="怎么连接多个命令"><a href="#怎么连接多个命令" class="headerlink" title="怎么连接多个命令"></a>怎么连接多个命令</h3><h4 id="逻辑运算符和命令退出状态"><a href="#逻辑运算符和命令退出状态" class="headerlink" title="逻辑运算符和命令退出状态"></a>逻辑运算符和命令退出状态</h4><p>执行命令后都有退出状态，我们可以使用 <code>&amp;&amp;</code> 和 <code>||</code>去决定下一步。</p><h4 id="退出命令"><a href="#退出命令" class="headerlink" title="退出命令"></a>退出命令</h4><p>你可以使用 <code>exit</code> 来决定退出码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">exit 0</span><br><span class="line">exit 1</span><br><span class="line">exit 2</span><br><span class="line">etc.</span><br></pre></td></tr></table></figure><p>例如:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">HOST=<span class="string">"razeen.cn"</span></span><br><span class="line">ping -c 1 <span class="variable">$HOST</span>  </span><br><span class="line"><span class="keyword">if</span> [ <span class="string">"$?"</span> -ne <span class="string">"0"</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"<span class="variable">$HOST</span> unreachable."</span></span><br><span class="line">  <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="built_in">exit</span> 0</span><br></pre></td></tr></table></figure><p>我们可以将该脚本通过<code>&amp;&amp;</code>与其他脚本/命令连接。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ./ex2.sh &amp;&amp; ls</span><br><span class="line">....</span><br><span class="line">2021-02-13-132m93.jpg   ex2.sh      file_1.txt  file_4.txt</span><br></pre></td></tr></table></figure><p>如果<code>./ex2.sh</code>返回状态码非0，后面的就不会执行。</p><h4 id="逻辑与-amp-amp"><a href="#逻辑与-amp-amp" class="headerlink" title="逻辑与 (&amp;&amp;)"></a>逻辑与 (&amp;&amp;)</h4><p>当<code>&amp;&amp;</code>前面的语句返回的状态码为<code>0</code>时，执行后面的语句。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir /tmp/bak &amp;&amp; cp test.txt /tmp/bak</span><br></pre></td></tr></table></figure><h4 id="逻辑或"><a href="#逻辑或" class="headerlink" title="逻辑或 (||)"></a>逻辑或 (||)</h4><p>当<code>||</code>前面的语句返回的状态码非<code>0</code>时（也就是执行失败），执行后面的语句。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cp test.txt /tmp/bak/ || cp test.test.txt /tmp</span><br></pre></td></tr></table></figure><p>例如：</p><p>如果<code>ping</code>通了，就执行后面的输出。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">host=<span class="string">"razeen.cn"</span></span><br><span class="line">ping -c 1 <span class="variable">$host</span> &amp;&amp; <span class="built_in">echo</span> <span class="string">"You can reach <span class="variable">$&#123;host&#125;</span>."</span></span><br></pre></td></tr></table></figure><p>如果<code>ping</code>失败了，就执行后面的输出。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">host=<span class="string">"google.com"</span></span><br><span class="line">ping -c 1 <span class="variable">$host</span> || <span class="built_in">echo</span> <span class="string">"You can't reach <span class="variable">$&#123;host&#125;</span>."</span></span><br></pre></td></tr></table></figure><h4 id="分号"><a href="#分号" class="headerlink" title="分号 (;)"></a>分号 (;)</h4><p>分号不是一个逻辑运算符，但你可以用它来分割语句。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cp text.txt /tmp/bak/ ; cp test.txt /tmp</span><br><span class="line"><span class="comment"># 等同于</span></span><br><span class="line">cp text.txt /tmp/bak/  </span><br><span class="line">cp test.txt /tmp</span><br></pre></td></tr></table></figure><h3 id="管道"><a href="#管道" class="headerlink" title="管道 |"></a>管道 |</h3><p>管道<code>|</code>两侧的命令在各自的子shell中运行，并且两者同时启动。</p><p>如下：</p><p>第一个命令将目录更改为主目录，并列出文件和目录。</p><p>第二个命令仅显示执行该命令的文件和目录。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">"<span class="variable">$(cd ~ &amp;&amp; ls)</span>"</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">"<span class="variable">$(cd ~ | ls)</span>"</span></span><br></pre></td></tr></table></figure><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>在<code>Bash</code>中，你可以使用<code>function</code>或者直接定义一个函数。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="keyword">function</span>-<span class="function"><span class="title">name</span></span>()&#123;&#125;</span><br><span class="line"><span class="comment"># 或</span></span><br><span class="line"><span class="keyword">function</span>-<span class="function"><span class="title">name</span></span>()&#123;&#125;</span><br></pre></td></tr></table></figure><p>当你调用函数的时候，只需要函数名，不用带<code>()</code>。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">hello</span></span>()&#123;</span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"Hello!"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 正确</span></span><br><span class="line">hello</span><br><span class="line"></span><br><span class="line"><span class="comment"># 错误</span></span><br><span class="line"><span class="comment"># hello()</span></span><br></pre></td></tr></table></figure><p>在函数中，可以调用其他函数。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">hello</span></span>()&#123;</span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"Hello!"</span></span><br><span class="line">  now</span><br><span class="line">  <span class="built_in">bye</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">now</span></span>()&#123;</span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"It's <span class="variable">$(date +%r)</span>"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">bye</span></span>()&#123;</span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"Bye bye."</span></span><br><span class="line">&#125;</span><br><span class="line">hello</span><br><span class="line"></span><br><span class="line"><span class="comment"># Output</span></span><br><span class="line"><span class="comment"># Hello!</span></span><br><span class="line"><span class="comment"># It's 09:29:44 PM</span></span><br><span class="line"><span class="comment"># Bye bye.</span></span><br></pre></td></tr></table></figure><p>但，需要注意函数的定义顺序。如果你在函数声明的前就去调用函数，函数就不会执行。如下， 在<code>hello</code>中执行<code>now</code>函数，但<code>now</code>是定义<code>hello</code>执行下面的，结果就会出错。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># this won't work</span></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">hello</span></span>()&#123;</span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"Hello!"</span></span><br><span class="line">  now</span><br><span class="line">&#125;</span><br><span class="line">hello</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">now</span></span>()&#123;</span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"It's <span class="variable">$(date +%r)</span>"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ./hello2.sh</span><br><span class="line">Hello!</span><br><span class="line">./hello2.sh: line 5: now: <span class="built_in">command</span> not found</span><br></pre></td></tr></table></figure><h4 id="函数传参"><a href="#函数传参" class="headerlink" title="函数传参"></a>函数传参</h4><p>和脚本执行的时候传参一样，函数的参数也用<code>$1</code>…,<code>$@</code> 来输出。</p><p>注意<code>$0</code>这里并不是函数的名字，而是当前脚本的名字。</p><p><code>$N</code>是第N个参数，<code>$@</code>表示所有的参数。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">fullname</span></span>()&#123;</span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"<span class="variable">$0</span>"</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"My name is <span class="variable">$1</span> <span class="variable">$2</span>"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fullname Razeen Cheng</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Output</span></span><br><span class="line"><span class="comment"># ./func.sh</span></span><br><span class="line"><span class="comment"># My name is Razeen Cheng</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">greeting</span></span>()&#123;</span><br><span class="line">  <span class="keyword">for</span> NAME <span class="keyword">in</span> <span class="variable">$@</span></span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"Hi <span class="variable">$NAME</span>."</span></span><br><span class="line">  <span class="keyword">done</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">greeting Tom Jerry</span><br></pre></td></tr></table></figure><h3 id="变量的作用域"><a href="#变量的作用域" class="headerlink" title="变量的作用域"></a>变量的作用域</h3><p>默认变量的作用域是全局的，必须先声明，后使用。 当然，最好在最上面就把需要的变量声明好。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="function"><span class="title">my_func</span></span>() &#123;</span><br><span class="line">  GLOBAL_VAR=1</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 这时，变量还是空的</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Calling GLONAL_VAR before calling function my_func"</span></span><br><span class="line"><span class="comment"># echo $GLOBAL_VAR</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 声明后，就可以输出了</span></span><br><span class="line">my_func</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Calling GLONAL_VAR after calling function my_func"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$GLOBAL_VAR</span></span><br></pre></td></tr></table></figure><h4 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h4><p>可以用<code>local</code>来定义局部变量，且只能在函数中使用。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash </span></span><br><span class="line">MY_VAR=1</span><br><span class="line"><span class="function"><span class="title">my_func</span></span> () &#123;</span><br><span class="line">  <span class="built_in">local</span> MY_VAR=2</span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"my_func: MY_VAR=<span class="variable">$MY_VAR</span>"</span> </span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"global: MY_VAR=<span class="variable">$MY_VAR</span>"</span></span><br><span class="line">my_func</span><br></pre></td></tr></table></figure><h3 id="函数返回码"><a href="#函数返回码" class="headerlink" title="函数返回码"></a>函数返回码</h3><p>你可以在函数中，指定返回码:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">return 0</span><br></pre></td></tr></table></figure><p>函数中最后执行的命令的退出状态将隐式返回。 有效代码范围为0-255。<code>0</code>代表成功，<code>$?</code>可以显示退出码。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ my_function</span><br><span class="line">$ echo $?</span><br><span class="line">0</span><br></pre></td></tr></table></figure><p>可以在<code>if</code> 判断中用<code>$?</code> ：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 该函数用来创建一个备份文件</span></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">backup_file</span></span> () &#123;</span><br><span class="line">    <span class="built_in">local</span> BACK <span class="comment"># 声明局部变量</span></span><br><span class="line">    <span class="keyword">if</span> [[ -f <span class="variable">$1</span> ]];<span class="keyword">then</span> <span class="comment"># 检查参数（是否是文件）</span></span><br><span class="line">        BACK=<span class="string">"/tmp/<span class="variable">$(basename "$1")</span>.<span class="variable">$(date +%F)</span>.$$"</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"Backing up <span class="variable">$1</span> to <span class="variable">$BACK</span>"</span></span><br><span class="line">        cp <span class="string">"<span class="variable">$1</span>"</span> <span class="string">"<span class="variable">$BACK</span>"</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment"># 文件不存在.</span></span><br><span class="line">        <span class="built_in">return</span> 1</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用函数</span></span><br><span class="line"><span class="keyword">if</span> [[ <span class="string">"<span class="variable">$1</span>"</span> ]]; <span class="keyword">then</span></span><br><span class="line">    backup_file <span class="string">"<span class="variable">$1</span>"</span></span><br><span class="line">    <span class="comment"># if [[ $? -eq 0 ]]; then</span></span><br><span class="line">    <span class="keyword">if</span> [[ $(backup_file <span class="string">"<span class="variable">$1</span>"</span>) -eq 0 ]]; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"Backup succeeded."</span></span><br><span class="line">        <span class="built_in">exit</span> 0</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"Backup failed."</span></span><br><span class="line">        <span class="comment"># 备份失败，中断，并返回非0状态.</span></span><br><span class="line">        <span class="built_in">exit</span> 1</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    backup_file /etc/hosts</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"/etc/hosts Backup succeeded."</span></span><br><span class="line">    <span class="built_in">exit</span> 0</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p>上面这个脚本默认备份<code>/etc/hosts</code>文件，除非你制定一个文件外。如果你指定一个文件参数，他会先检查文件，然后备份到<code>/tmp</code>目录。</p><p><code>$$</code> 返回 <a href="https://tldp.org/LDP/abs/html/internalvariables.html" target="_blank" rel="noopener">当前脚本执行的PID</a>. 每次运行PID都会发生变化。当你需要多次运行脚本时，或许对你有帮助。</p><p><code>basename ${1}</code> 可以从你输入的路径中提取文件的名字. 如 <code>basename /etc/hosts</code> 是 <code>hosts</code>.</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ls /tmp</span><br><span class="line">$ ex1           </span><br><span class="line">Backing up /etc/hosts to /tmp/hosts.2020-10-04.77124</span><br><span class="line">Backup succeeded.</span><br><span class="line">$ ls /tmp</span><br><span class="line">hosts.2020-10-04.77124</span><br></pre></td></tr></table></figure><h4 id="关键字-exit-和-return"><a href="#关键字-exit-和-return" class="headerlink" title="关键字 exit 和 return"></a>关键字 exit 和 return</h4><p><code>return</code> 会跳出当前函数, <code>exit</code>会结束当前脚本。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这篇博客总结了常用的，我们需要了解的一些脚本语法与知识。如果向更好的使用<code>bash</code>, 我们还需要进一步学习更多的命令等。希望这篇博客能对你有所帮助。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ol><li><a href="https://tldp.org/LDP/Bash-Beginners-Guide/html/sect_03_02.html" target="_blank" rel="noopener">Variables</a>, <a href="https://tldp.org/LDP/abs/html/internalvariables.html" target="_blank" rel="noopener">Internal variables</a></li><li><a href="https://marketplace.visualstudio.com/items?itemName=timonwong.shellcheck" target="_blank" rel="noopener">shellcheck</a></li><li><a href="https://github.com/koalaman/shellcheck/wiki" target="_blank" rel="noopener">shellcheck wiki</a></li><li><a href="https://marketplace.visualstudio.com/items?itemName=foxundermoon.shell-format" target="_blank" rel="noopener">shell-format</a></li><li><a href="https://wiki.bash-hackers.org/start" target="_blank" rel="noopener">The Bash Hackers Wiki</a></li><li><a href="https://tldp.org/LDP/abs/html/index.html" target="_blank" rel="noopener">Advanced Bash-Scripting Guide</a></li></ol>]]></content>
      <categories>
        <category>Linux 点滴</category>
      </categories>
      <tags>
        <tag>shell</tag>
        <tag>bash</tag>
      </tags>
  </entry>
  <entry>
    <title>AWS 命令行界面(aws-cli)从安装到快速上手</title>
    <url>//post/tool-awscli-overview-1.html</url>
    <content><![CDATA[<p>AWS 命令行界面 (CLI) 是用于管理 AWS 服务的统一工具。只通过一个工具进行下载和配置，您可以使用命令行控制多个 AWS 服务并利用脚本来自动执行这些服务。 —- aws官方是这么描叙aws-cli的。在实际使用的时候通过脚本完成全自动化部署，一键管理许多云服务，aws-cli确实是你管理aws服务的一个提高生产力的好工具。</p><a id="more"></a><h3 id="安装aws-cli"><a href="#安装aws-cli" class="headerlink" title="安装aws-cli"></a>安装aws-cli</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ curl <span class="string">"https://s3.amazonaws.com/aws-cli/awscli-bundle.zip"</span> -o <span class="string">"awscli-bundle.zip"</span></span><br><span class="line">$ unzip awscli-bundle.zip</span><br><span class="line">$ ./awscli-bundle/install -b ~/bin/aws</span><br><span class="line">$ sudo ln -s  ~/.<span class="built_in">local</span>/lib/aws/bin/aws  /usr/<span class="built_in">local</span>/bin/aws</span><br><span class="line">$ aws --version</span><br></pre></td></tr></table></figure><h3 id="配置aws-cli"><a href="#配置aws-cli" class="headerlink" title="配置aws-cli"></a>配置aws-cli</h3><h4 id="1-创建访问密钥"><a href="#1-创建访问密钥" class="headerlink" title="1. 创建访问密钥"></a>1. 创建访问密钥</h4><p>话不多说，看图操作。</p><p><img data-src="https://st.razeen.cn/img/202102/tools/awscli/aws-cli-001.png" alt></p><p><img data-src="https://st.razeen.cn/img/202102/tools/awscli/aws-cli-002.png" alt></p><p><img data-src="https://st.razeen.cn/img/202102/tools/awscli/aws-cli-003.png" alt></p><p>最后的访问密钥ID和私有访问密钥复制一下，准备工作👌。</p><h4 id="2-设置本地配置"><a href="#2-设置本地配置" class="headerlink" title="2. 设置本地配置"></a>2. 设置本地配置</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ aws configure</span><br><span class="line">AWS Access Key ID [None]: <span class="comment"># 刚刚获得的访问密钥ID</span></span><br><span class="line">AWS Secret Access Key [None]: <span class="comment"># 刚刚获得的私有访问密钥 </span></span><br><span class="line">Default region name [None]: us-west-2  <span class="comment"># 你的服务地区</span></span><br><span class="line">Default output format [None]: json <span class="comment"># 你需要返回的数据格式</span></span><br></pre></td></tr></table></figure><blockquote><p>如果你不知道你的地区名字 你可以点<a href="http://docs.amazonaws.cn/general/latest/gr/rande.html" target="_blank" rel="noopener">这里</a>查找。</p></blockquote><h3 id="上手使用"><a href="#上手使用" class="headerlink" title="上手使用"></a>上手使用</h3><p>这里有几个日常管理常用的命令使用方法，更多的请看<a href="http://docs.aws.amazon.com/cli/latest/reference/index.html#cli-aws" target="_blank" rel="noopener">这里</a>。</p><h4 id="实例管理"><a href="#实例管理" class="headerlink" title="实例管理"></a>实例管理</h4><h5 id="创建实例"><a href="#创建实例" class="headerlink" title="创建实例"></a>创建实例</h5><p>1.在创建实例前你的选择一个镜像，也是就一个模板，可以是自己的或社区的。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看所有AMI，包括你的所有公用AMI</span></span><br><span class="line">aws ec2 describe-images --executable-users all</span><br><span class="line"><span class="comment"># 查看亚马逊的</span></span><br><span class="line">aws ec2 describe-images --owners amazon</span><br><span class="line"><span class="comment"># 查看指定账户公用的</span></span><br><span class="line">aws ec2 describe-images --owners 123456789012</span><br></pre></td></tr></table></figure><p>可以通过<code>--filters</code> 筛选出你感兴趣的 AMI 类型。如只显示 EBS 支持的 AMI</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">--filters <span class="string">"Name=root-device-type,Values=ebs"</span></span><br></pre></td></tr></table></figure><p>2.创建实例</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 我选的是 Amazon Linux AMI 2017.09.1 (HVM), SSD Volume Type - ami-ec499a81</span></span><br><span class="line">aws ec2 run-instances \</span><br><span class="line">	--image-id ami-ec499a81 \ <span class="comment"># 从哪个镜像起</span></span><br><span class="line">	--count 1 \ <span class="comment"># 起多少台</span></span><br><span class="line">	--instance-type t2.microE \ <span class="comment"># 什么型号的实例</span></span><br><span class="line">	--key-name mykey \ <span class="comment"># 用那组秘钥对</span></span><br><span class="line">	--security-group-ids sg-2236db46 <span class="comment"># 实例安全组</span></span><br></pre></td></tr></table></figure><blockquote><p>更多实例型号看<a href="http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html" target="_blank" rel="noopener">这里</a></p></blockquote><h5 id="添加标签"><a href="#添加标签" class="headerlink" title="添加标签"></a>添加标签</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">aws ec2 create-tags --resources <span class="string">"i-031380f079902c9bd"</span> --tags <span class="string">'Key=Name,Value=MyAuto'</span></span><br></pre></td></tr></table></figure><blockquote><p><code>aws ec2 create-tags</code>命令能给所有的资源添加标签，所以这里你指定你的<code>--resources</code> 为你的实例 ID，并且指定你需要添加的标签名以及内容。</p></blockquote><h5 id="获取实例状态信息"><a href="#获取实例状态信息" class="headerlink" title="获取实例状态信息"></a>获取实例状态信息</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">aws ec2 describe-instance-status --instance-id <span class="string">"i-031380f079902c9bd"</span></span><br></pre></td></tr></table></figure><blockquote><p>这个返回的是实例的所有状态信息，如果你只需要部分可以利用<code>--query</code>参数</p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看实例是不是在运行</span></span><br><span class="line">aws ec2 describe-instance-status --instance-id <span class="string">"i-031380f079902c9bd"</span> --query <span class="string">"InstanceStatuses[0].InstanceState.Name"</span></span><br><span class="line">&gt;&gt; <span class="string">"running"</span></span><br></pre></td></tr></table></figure><h5 id="获取实例详细信息"><a href="#获取实例详细信息" class="headerlink" title="获取实例详细信息"></a>获取实例详细信息</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">aws ec2 describe-instances --instance-ids <span class="string">"i-031380f079902c9bd"</span></span><br></pre></td></tr></table></figure><blockquote><p>当然，如果你只看IP</p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"> aws ec2 describe-instances --instance-ids <span class="string">"i-031380f079902c9bd"</span> --query <span class="string">"Reservations[0].Instances[0].PublicIpAddress"</span></span><br><span class="line">&gt;&gt; <span class="string">"55.222.111.22"</span></span><br></pre></td></tr></table></figure><p>到这里你就可以在控制台看到该实例了。</p><p><img data-src="https://st.razeen.cn/img/202102/tools/awscli/aws-cli-005.png" alt></p><h5 id="删除实例"><a href="#删除实例" class="headerlink" title="删除实例"></a>删除实例</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">aws ec2 terminate-instances --instance-ids <span class="string">"i-031380f079902c9bd"</span></span><br></pre></td></tr></table></figure><h4 id="AMI管理"><a href="#AMI管理" class="headerlink" title="AMI管理"></a>AMI管理</h4><h5 id="创建AMI"><a href="#创建AMI" class="headerlink" title="创建AMI"></a>创建AMI</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 从实例 i-031380f079902c9bd 创建镜像</span></span><br><span class="line">aws ec2 create-image \</span><br><span class="line">	--description <span class="string">"TEST_AMI"</span> \ <span class="comment"># AMI描叙 </span></span><br><span class="line">	--instance-id <span class="string">"i-031380f079902c9bd"</span> \ <span class="comment"># 实例ID</span></span><br><span class="line">	--name <span class="string">"testami20171030"</span> <span class="comment"># 创建的AMI名字</span></span><br></pre></td></tr></table></figure><blockquote><p>在创建该镜像时会自动创建一个快照，当然如果你要指定快照信息可以使用<code>--block-device-mappings</code>参数。</p></blockquote><h5 id="为AMI添加标签"><a href="#为AMI添加标签" class="headerlink" title="为AMI添加标签"></a>为AMI添加标签</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">aws ec2 create-tags --resources <span class="string">"ami-d4975eb9"</span> --tags <span class="string">'Key=Name,Value=MyAutoAMI'</span></span><br></pre></td></tr></table></figure><h5 id="查看AMI信息"><a href="#查看AMI信息" class="headerlink" title="查看AMI信息"></a>查看AMI信息</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">aws ec2 describe-images --image-ids <span class="string">"ami-d4975eb9"</span></span><br></pre></td></tr></table></figure><blockquote><p>这个可以返回镜像的所有信息，如果你只看其中某一项，你可以利用<code>--query</code>参数.</p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"> <span class="comment"># 只查看状态</span></span><br><span class="line">aws ec2 describe-images --image-ids <span class="string">"ami-d4975eb9"</span> --query <span class="string">"Images[0].State"</span> </span><br><span class="line">&gt;&gt; pendding</span><br></pre></td></tr></table></figure><p>上面一顿操作结束，你就可以在你的AMI控制台看到。</p><p><img data-src="https://st.razeen.cn/img/202102/tools/awscli/aws-cli-004.png" alt></p><h5 id="删除AMI"><a href="#删除AMI" class="headerlink" title="删除AMI"></a>删除AMI</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">aws ec2 deregister-image --image-id <span class="string">"ami-d4975eb9"</span></span><br></pre></td></tr></table></figure><blockquote><p>如果你和我一样在创建AMI没有指定快照，那么它会自动为你创建快照。</p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查询该镜像快照ID</span></span><br><span class="line">aws ec2 describe-images --image-ids <span class="string">"ami-d4975eb9"</span> --query <span class="string">"Images[0].BlockDeviceMappings[0].Ebs.SnapshotId"</span></span><br><span class="line">&gt;&gt; <span class="string">"snap-f269e2fa"</span></span><br><span class="line"><span class="comment"># 删除快照</span></span><br><span class="line">aws ec2 delete-snapshot --snapshot-id <span class="string">"snap-f269e2fa"</span></span><br></pre></td></tr></table></figure><h4 id="自动缩放组管理"><a href="#自动缩放组管理" class="headerlink" title="自动缩放组管理"></a>自动缩放组管理</h4><h5 id="创建缩放组启动配置"><a href="#创建缩放组启动配置" class="headerlink" title="创建缩放组启动配置"></a>创建缩放组启动配置</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">aws autoscaling create-launch-configuration \</span><br><span class="line">	--launch-configuration-name <span class="string">"oldlanchconf"</span> \ <span class="comment"># 启动配置名字</span></span><br><span class="line">	--image-id <span class="string">"ami-d4975eb9"</span> \ <span class="comment"># 启动的模板镜像</span></span><br><span class="line">	--instance-type <span class="string">"t2.microE"</span> \ <span class="comment"># 启动的实例类型</span></span><br><span class="line">	--security-groups <span class="string">"sg-2236db46"</span> \ <span class="comment"># 启动的实例安全组</span></span><br><span class="line">	--key-name <span class="string">"mykey"</span> \ <span class="comment"># 秘钥</span></span><br><span class="line">	--associate-public-ip-address  <span class="comment"># 为该实例分配一个公有IP</span></span><br></pre></td></tr></table></figure><h5 id="创建自动缩放组"><a href="#创建自动缩放组" class="headerlink" title="创建自动缩放组"></a>创建自动缩放组</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在指定的子网内创建一个缩放组</span></span><br><span class="line">aws autoscaling create-auto-scaling-group \</span><br><span class="line">	--auto-scaling-group-name <span class="string">"mygroup"</span> \  <span class="comment"># 缩放组名字</span></span><br><span class="line">	--launch-configuration-name <span class="string">"oldlanchconf"</span> \  <span class="comment"># 缩放组启动配置</span></span><br><span class="line">	--min-size 1 \  <span class="comment"># 缩放组最小实例数</span></span><br><span class="line">	--max-size 3 \  <span class="comment"># 最大</span></span><br><span class="line">	--vpc-zone-identifier <span class="string">"subnet-41767929c"</span> <span class="comment"># "缩放组子网id"</span></span><br><span class="line"><span class="comment"># 创建一个配置负载均衡的缩放组</span></span><br><span class="line">aws autoscaling create-auto-scaling-group \</span><br><span class="line">	--auto-scaling-group-name <span class="string">"mygroup"</span> \</span><br><span class="line">	--launch-configuration-name <span class="string">"oldlanchconf"</span> \</span><br><span class="line">	--load-balancer-names <span class="string">"my-load-balancer"</span> \  <span class="comment"># 负载平衡器</span></span><br><span class="line">	--health-check-type <span class="string">"ELB"</span> \  <span class="comment"># 健康状态检查类型 使用ELB提供的健康检查</span></span><br><span class="line">	--health-check-grace-period 120  <span class="comment"># 实例自动伸缩前120秒的任何健康检查失败将被忽略</span></span><br></pre></td></tr></table></figure><h5 id="修改已有缩放组启动配置"><a href="#修改已有缩放组启动配置" class="headerlink" title="修改已有缩放组启动配置"></a>修改已有缩放组启动配置</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">aws autoscaling update-auto-scaling-group --auto-scaling-group-name <span class="string">"oldlanchconf"</span> --launch-configuration-name <span class="string">"newlaunchconf"</span></span><br></pre></td></tr></table></figure><h5 id="将实例加入缩放组"><a href="#将实例加入缩放组" class="headerlink" title="将实例加入缩放组"></a>将实例加入缩放组</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">aws autoscaling attach-instances --instance-ids <span class="string">"i-031380f079902c9bd"</span> --auto-scaling-group-name <span class="string">"mygroup"</span></span><br></pre></td></tr></table></figure><p>主要的操作大概也就这些，更多请看<a href="http://docs.aws.amazon.com/cli/latest/reference/" target="_blank" rel="noopener">官方文档</a>，如有错误，请指出哦。</p>]]></content>
      <categories>
        <category>开发实战总结</category>
      </categories>
      <tags>
        <tag>aws</tag>
        <tag>工具</tag>
        <tag>aws-cli</tag>
      </tags>
  </entry>
  <entry>
    <title>Typora 自动上传图片到七牛云</title>
    <url>//post/typora-upload-image-qiniu.html</url>
    <content><![CDATA[<p>用 Markdown 写博客配图片一直是个烦恼我的为问题， 每次上传图片都比较麻烦，或是中断思路，或是最后集中处理耗费时间。今天无意中，发现了 Typora 的图片自动上传功能，配合一段脚本，将插入的图片自动上传七牛，让写文章更爽了。</p><a id="more"></a><h3 id="偏好设置"><a href="#偏好设置" class="headerlink" title="偏好设置"></a>偏好设置</h3><p>我们看到在 Typora 的偏好设置中，有将图片插入时执行的动作。 在上传的设置中可以选择几种上传方式，由于前面几种要下其他软件，我就直接选了其他命令的方式。</p><p><img data-src="https://st.razeen.cn/img/20210130225707_image-20210130225707678.png" alt="image-20210130225707678"></p><h3 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h3><p>看了一下规则，很简单。 当你插入图片的时候会执行你的命令。 假如你的命令叫 <code>upload-image.sh</code> , 则会执行：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">upload-image.sh <span class="string">"imagepath1"</span> <span class="string">"imagepath2"</span> ...</span><br></pre></td></tr></table></figure><p>而你的命令只需要如下格式返回上传后的链接：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Upload Success:</span><br><span class="line">http://remote-image-1.png</span><br><span class="line">http://remote-image-2.png</span><br></pre></td></tr></table></figure><h3 id="qshell"><a href="#qshell" class="headerlink" title="qshell"></a>qshell</h3><p>知道了脚本怎么写，我首先想到了，平常用来上传文件到七牛的命令行工具 <code>qshell</code> 。</p><p><a href="https://github.com/qiniu/qshell" target="_blank" rel="noopener">GitHub🔗</a>上有详细的说明，你可以下下来自己编译，也可以直接下载编译好的。</p><p>关于命令使用，上面也有详细的介绍。 其实，我们这里主要只用到两个命令。</p><ul><li><p>设置账户。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">qshell account [AccessKey] [SecretKey] [Name]</span><br></pre></td></tr></table></figure><p>其中，两个 Key 七牛账户中可以添加。 后面的 Name 随便写。</p></li><li><p>上传</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">qshell rput &lt;Bucket&gt; &lt;Key&gt; &lt;LocalFile&gt;</span><br></pre></td></tr></table></figure><p>其中，Bucket 就是对象存储空间的名字， key 上传后的路径， LocalFile 本地文件路径。</p></li></ul><h3 id="写脚本"><a href="#写脚本" class="headerlink" title="写脚本"></a>写脚本</h3><p>最新的脚本可以看<a href="https://github.com/razeencheng/typora-upload-img-qiniu" target="_blank" rel="noopener">这里</a>。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> -e</span><br><span class="line">IFS=$<span class="string">';'</span></span><br><span class="line"></span><br><span class="line">BUCKET=<span class="string">"blog"</span>  <span class="comment"># 这里换成 你在七牛的空间名称</span></span><br><span class="line">QSHELL=<span class="string">"D:\Users\Razeen\wspace\bin\qshell.exe"</span> <span class="comment"># 这里换成 你qshell可执行文件的路径</span></span><br><span class="line">DOMAIN=<span class="string">"https://st.razeen.cn"</span> <span class="comment"># 这里换成 你在七牛对应的自定义域名</span></span><br><span class="line">PATH_PREFIX=<span class="string">"img"</span> <span class="comment"># 这里换成 你想设置的图片路径前缀</span></span><br><span class="line">ACCESSKEY=xxxxxxxx <span class="comment"># 这里设置 你的七牛密钥</span></span><br><span class="line">SECUREKEY=xxxxxxx </span><br><span class="line">ACTNAME=self <span class="comment"># 可以给这个账号一个别名</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$QSHELL</span> account <span class="variable">$ACCESSKEY</span> <span class="variable">$SECUREKEY</span> <span class="variable">$ACTNAME</span> -w</span><br><span class="line"></span><br><span class="line">sys=$(uname -s)</span><br><span class="line"></span><br><span class="line">i=0</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> filepath <span class="keyword">in</span> <span class="variable">$@</span>; <span class="keyword">do</span></span><br><span class="line"></span><br><span class="line">    i=$((<span class="variable">$&#123;i&#125;</span>+1))</span><br><span class="line"></span><br><span class="line">    date_prefix=$(date +<span class="string">'%Y%m%d%H%M%S'</span>)</span><br><span class="line"></span><br><span class="line">    filename=<span class="string">"<span class="variable">$&#123;date_prefix&#125;</span>-<span class="variable">$&#123;filepath##*/&#125;</span>"</span> </span><br><span class="line"></span><br><span class="line">    <span class="comment"># windows 路径匹配不一样</span></span><br><span class="line">    <span class="keyword">if</span> [[ <span class="variable">$&#123;sys&#125;</span> == <span class="string">"MINGW64"</span>* ]]; <span class="keyword">then</span></span><br><span class="line">        filename=<span class="string">"<span class="variable">$&#123;date_prefix&#125;</span>-<span class="variable">$&#123;filepath##*\\&#125;</span>"</span></span><br><span class="line">    <span class="keyword">fi</span>                                                                   </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> [ -f <span class="string">"<span class="variable">$&#123;filepath&#125;</span>"</span> ]; <span class="keyword">then</span></span><br><span class="line"></span><br><span class="line">         <span class="variable">$&#123;QSHELL&#125;</span> rput <span class="variable">$&#123;BUCKET&#125;</span> <span class="string">"<span class="variable">$&#123;PATH_PREFIX&#125;</span>/<span class="variable">$&#123;filename&#125;</span>"</span> <span class="string">"<span class="variable">$&#123;filepath&#125;</span>"</span> &gt; /dev/null</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> [ $? -eq 0 ]; <span class="keyword">then</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> [ <span class="variable">$&#123;i&#125;</span> -eq 1 ]; <span class="keyword">then</span> </span><br><span class="line">                <span class="built_in">echo</span> <span class="string">"Upload Success:"</span></span><br><span class="line">            <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">            <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;DOMAIN&#125;</span>/<span class="variable">$&#123;PATH_PREFIX&#125;</span>/<span class="variable">$&#123;filename&#125;</span>"</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">echo</span> <span class="string">"upload <span class="variable">$&#123;filepath&#125;</span> failed!"</span></span><br><span class="line">            <span class="built_in">exit</span> 1;</span><br><span class="line">        <span class="keyword">fi</span></span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;filepath&#125;</span> does not exist"</span></span><br><span class="line">        <span class="built_in">exit</span> 1;</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><h3 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h3><ol><li><p>保存上面脚本，修改当中需要的信息，并添加执行权限。</p></li><li><p>在 <code>Typora</code> 中设置 这个命令（绝对路径），如</p><p><img data-src="https://st.razeen.cn/img/20210131000315_image-20210131000315109.png" alt="image-20210131000315109"></p><p>Mac/Ubutun上这么设置没问题， 但Windows上可能会出现如下错误。</p><p><img data-src="https://st.razeen.cn/img/20210701002430_image-20210701002428848.png" alt="image-20210701002428848"></p><p>这时我们需要换一个脚本解释器，如换成 <code>Git Bash</code>，如下图，直接在脚本前面加上<code>Git Bash</code>路径。</p><p><img data-src="https://st.razeen.cn/img/20210701002926-image-20210701002924703.png" alt="image-20210701002924703"></p></li></ol><ol start="4"><li><p>最后使用效果如下：</p><p><img data-src="https://st.razeen.cn/img/20210131000625_image-20210131000625463.png" alt="image-20210131000625463"></p></li></ol><h3 id="相关知识点"><a href="#相关知识点" class="headerlink" title="相关知识点"></a>相关知识点</h3><ul><li><p>shell 脚本读取用户输入参数：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$# 是传给脚本的参数个数</span><br><span class="line">$0 是脚本本身的名字</span><br><span class="line">$1是传递给该shell脚本的第一个参数</span><br><span class="line">$2是传递给该shell脚本的第二个参数</span><br><span class="line">$@ 是传给脚本的所有参数的列表</span><br></pre></td></tr></table></figure></li><li><p>shell脚本中判断上一个命令是否执行成功</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">shell中使用符号 $? 来显示上一条命令执行的返回值，如果为0则代表执行成功，其他表示失败。</span><br></pre></td></tr></table></figure></li><li><p>shell 从路径中提取文件名和目录名</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">提取文件名 $&#123;filepath##*/&#125;</span><br><span class="line">提取文件后缀 $&#123;filepath##*.&#125; 或 $&#123;filepath#*.&#125;</span><br><span class="line">提取目录 $&#123;filepath%/*&#125;</span><br><span class="line">主要原理：</span><br><span class="line">#：表示从左边算起第一个</span><br><span class="line">%：表示从右边算起第一个</span><br><span class="line">##：表示从左边算起最后一个</span><br><span class="line">%%：表示从右边算起最后一个</span><br><span class="line"></span><br><span class="line">除此之外，basename 和 filename 命令也可以做到。</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      <categories>
        <category>博客折腾日记</category>
      </categories>
      <tags>
        <tag>shell</tag>
        <tag>linux</tag>
        <tag>typora</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu 20.04 LTS 有线网卡驱动安装</title>
    <url>//post/ubutun-realtek-r8125-driver-install.html</url>
    <content><![CDATA[<p>Ubuntu 20.04 LTS 安装好后，发现 WIFI 可以正常连接，有线网络连图标都没有显示。经过诊断发现是有线网卡驱动未正确问题。最后通过手动安装网卡驱动得以解决。这里记录一下。</p><p>我的主板是 <code>微星B460M MORTAR WIFI</code>，驱动 <code>R8125</code>。类似型号安装应也差不多。</p><a id="more"></a><h3 id="怎么看网卡驱动是否安装？"><a href="#怎么看网卡驱动是否安装？" class="headerlink" title="怎么看网卡驱动是否安装？"></a>怎么看网卡驱动是否安装？</h3><p>用 <code>ifconfig</code>查看网络设备情况。</p><blockquote><p><code>ifconfig</code> 没有，可以用 <code>sudo apt install net-tools</code> 安装。</p></blockquote><p>如果一切正常，你或许看到的是类似这样的。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; ifconfig</span><br><span class="line">lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt;  mtu 65536</span><br><span class="line">        inet 127.0.0.1  netmask 255.0.0.0</span><br><span class="line">        inet6 ::1  prefixlen 128  scopeid 0x10&lt;host&gt;</span><br><span class="line">        ....</span><br><span class="line"></span><br><span class="line">wlp3s0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 192.168.123.57  netmask 255.255.255.0  broadcast 192.168.123.255</span><br><span class="line">        ....</span><br><span class="line"></span><br><span class="line">enp4s0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 192.168.123.64  netmask 255.255.255.0  broadcast 192.168.123.255</span><br><span class="line">        ....</span><br></pre></td></tr></table></figure><p>其中，</p><ul><li><code>lo</code> 开头的，表示本地连接</li><li><code>wl</code> 开头的，表示无线局域网 (wlan Wireless Local Area Network)<ul><li><code>p3s0</code>描述了无线局域网的 PCI 接口位置： bus=3, slot=0</li></ul></li><li><code>en</code> 开头的，表示以太网(ethernet)<ul><li><code>p2s0</code> 描述了以太网的 PCI 接口位置： bus=2, slot=0</li></ul></li></ul><blockquote><p><code>PCI</code> 全称(Peripheral Component Interconnect)，即外设部件互连标准</p></blockquote><p>如果没有<code>en</code>开头的这个，说明网卡驱动存在问题。 我们可以利用<code>lspci -v | grep Ethernet</code> 具体的查看一下网卡的型号，如：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; lspci -v | grep Ethernet</span><br><span class="line">04:00.0 Ethernet controller: Realtek Semiconductor Co., Ltd. RTL8125 2.5GbE Controller (rev 04)</span><br></pre></td></tr></table></figure><h3 id="驱动安装"><a href="#驱动安装" class="headerlink" title="驱动安装"></a>驱动安装</h3><p>到 <a href="https://www.realtek.com/en/component/zoo/category/network-interface-controllers-10-100-1000m-gigabit-ethernet-pci-express-software" target="_blank" rel="noopener">Realtek官网</a> 下载好驱动，如对应上面的输出<code>RTL8125 2.5GbE Controller</code>，我找到了该驱动。</p><p><img data-src="https://st.razeen.cn/img/2021-01-30_00-43.png" alt></p><p>下载好后，经入下载后的文件夹，开始准备安装了。</p><ol><li><p>准备环境。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install --reinstall linux-headers-$(uname -r) linux-headers-generic build-essential dkms</span><br></pre></td></tr></table></figure></li><li><p>解压源码到 <code>/usr/src</code></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo tar xvf r8125-9.004.01.tar.bz2 -C /usr/src</span><br></pre></td></tr></table></figure><p><em>按照其中README.md的方法安装后也可使用，但重启后需要重新安装。</em></p></li><li><p>添加一个 <code>dkms.conf</code> 到 <code>/usr/src/r8125-9.004.01/</code> 目录下，内容如下:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">PACKAGE_NAME=Realtek_r8125</span><br><span class="line">PACKAGE_VERSION=9.003.02</span><br><span class="line"></span><br><span class="line">DEST_MODULE_LOCATION=/updates/dkms</span><br><span class="line">BUILT_MODULE_NAME=r8125</span><br><span class="line">BUILT_MODULE_LOCATION=src/</span><br><span class="line"></span><br><span class="line">MAKE=<span class="string">"'make' -C src/ all"</span></span><br><span class="line">CLEAN=<span class="string">"'make' -C src/ clean"</span></span><br><span class="line">AUTOINSTALL=<span class="string">"yes"</span></span><br></pre></td></tr></table></figure></li><li><p>编译 dkms</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo dkms add -m r8125 -v 9.004.01</span><br><span class="line">sudo dkms build -m r8125 -v 9.004.01</span><br><span class="line">sudo dkms install -m r8125 -v 9.004.01</span><br><span class="line">sudo depmod -a</span><br><span class="line">sudo modprobe r8125</span><br></pre></td></tr></table></figure></li><li><p>操作完成后，你就可以通过<code>ifconfig</code> 看到<code>en</code>开头的有线网连接了。</p></li><li><p>如果后续有升级，需要先删除，再安装新的。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo dkms remove r8125/9.004.01 --all</span><br></pre></td></tr></table></figure></li></ol><p>另外，我遇到过一次升级内核，把这个驱动弄没了，这时再编译安装一次就好了。</p><p><strong>相关链接</strong></p><ul><li><a href="https://www.realtek.com/en/component/zoo/category/network-interface-controllers-10-100-1000m-gigabit-ethernet-pci-express-software" target="_blank" rel="noopener">Realtek 驱动</a></li></ul>]]></content>
      <categories>
        <category>家庭网络折腾</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>Github Actions 初体验之自动化部署 Hexo 博客</title>
    <url>//post/use-github-action-to-deploy-your-hexo-blog.html</url>
    <content><![CDATA[<p>觊觎了 Github Actions 很久了，昨天尝试将自己的博客用它来部署，总体下来感觉不错。</p><p>Github Actions 是 Github 推出的自动化工作流， 就像 Gitlab 的 CI/CD, Travis CI 一样，能帮我们完成一些 CI/CD 的工作流，实现自动化构建、测试、打包、部署等等。</p><p>这篇文章主要实现 只需要将文章推送到 Github ，Github Actions 自动完成构建静态文件，以及更新 Github Pages 仓库的流程。</p><a id="more"></a><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>先创建一个私有仓库，存放我们的 Hexo 主题以及配置；</li><li>在上面仓库中创建一个工作流，每次推送可以触发执行 打包、生成静态文件；</li><li>自动将静态文件推送到 yourname.github.io Github Pages 仓库；</li></ol><p>有了思路我们就开始准备工作。</p><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><ol><li><p>创建好了你的 yourname.github.io Github Pages 仓库;</p></li><li><p>在 Hexo 配置文件<code>config.yaml</code> 中配置好部署配置，如：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">    <span class="attr">repo:</span> <span class="string">git@github.com:yourname/yourname.github.io.git</span></span><br><span class="line">    <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure></li></ol><ol start="3"><li><p>创建一个私有仓库，将 Hexo 配置以及主题 文件推送上来;</p></li><li><p>然后，我们需要创建一个 SSH 部署密钥（在部署的时候，Github Actions 需要推送文件到 yourname.github.io, 为了安全，我们单独添加一个部署密钥）</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-keygen -f github-page-deploy-key</span><br></pre></td></tr></table></figure><p>执行以上命令可以生成 SSH 密钥对，公钥<code>github-page-deploy-key.pub</code> 与 私钥 <code>github-page-deploy-key</code>。</p></li><li><p>我们将私钥配置到 Hexo 仓库的 <code>Secrets</code> 中。 打开 <code>Settings -&gt; Secrets -&gt; New repository secret</code>, 如下图所示：</p><p><img data-src="https://st.razeen.cn/img/blog/Snipaste_2021-06-24_23-42-01.png" alt></p><p>通过记事本等打开 <code>github-page-deploy-key</code> 内容，填入 <code>Value</code> 中；</p><p>在 <code>Name</code> 中为该 <code>Secrets</code> 设置一个名字，如 <code>MY_BLOG_DEPLOY_KEY</code>, 后面写 Action 配置文件会用到。</p></li><li><p>在 GitHub Pages 仓库中添加公钥<code>github-page-deploy-key.pub</code>， 打开 <code>Settings -&gt; Deploy Keys -&gt; Add deploy key</code> , 如下图所示：</p><p><img data-src="https://st.razeen.cn/img/blog/Snipaste_2021-06-24_23-50-42.png" alt></p><p>在 <code>Key</code> 中粘贴 公钥<code>github-page-deploy-key.pub</code> 内容；</p><p><code>Title</code> 可以随便取一个名字， <strong>勾选上 <code>Allow write access</code> </strong>。</p></li></ol><p>到这里，我们的准备工作就完成了，开始创建并编排工作流。</p><h3 id="创建并编排-Github-Actions"><a href="#创建并编排-Github-Actions" class="headerlink" title="创建并编排 Github Actions"></a>创建并编排 Github Actions</h3><p>在 Hexo 仓库中创建 <code>.github/workflows/deploy.yml</code> 文件，如下图所示：</p><p><img data-src="https://st.razeen.cn/img/blog/Snipaste_2021-06-24_23-58-26.png" alt></p><p>在 <code>deploy.yml</code> 中添加编排配置，如：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">deploy_my_blog</span></span><br><span class="line"><span class="attr">on:</span> <span class="string">[push]</span></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">build_and_deploy:</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">uses:</span> <span class="string">actions/checkout@v2</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">uses:</span> <span class="string">actions/setup-node@v2</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">node-version:</span> <span class="string">'12'</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Prepare</span> <span class="string">ssh</span> <span class="string">env</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line">          <span class="string">mkdir</span> <span class="string">-p</span> <span class="string">~/.ssh</span></span><br><span class="line">          <span class="string">echo</span> <span class="string">"$SSH_DEPLOY_KEY"</span> <span class="string">|</span> <span class="string">tr</span> <span class="string">-d</span> <span class="string">'\r'</span> <span class="string">&gt;</span> <span class="string">~/.ssh/id_rsa</span></span><br><span class="line">          <span class="string">chmod</span> <span class="number">600</span> <span class="string">~/.ssh/id_rsa</span></span><br><span class="line">          <span class="string">ssh-keyscan</span> <span class="string">-H</span> <span class="string">'github.com'</span> <span class="string">&gt;&gt;</span> <span class="string">~/.ssh/known_hosts</span></span><br><span class="line">        <span class="attr">env:</span></span><br><span class="line">          <span class="attr">SSH_DEPLOY_KEY:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.MY_BLOG_DEPLOY_KEY</span> <span class="string">&#125;&#125;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Prepare</span> <span class="string">hexo</span> <span class="string">and</span> <span class="string">npm</span> <span class="string">env</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line">          <span class="string">npm</span> <span class="string">install</span> <span class="string">-g</span> <span class="string">hexo-cli</span></span><br><span class="line">          <span class="string">npm</span> <span class="string">install</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Prepare</span> <span class="string">git</span> <span class="string">env</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line">          <span class="string">git</span> <span class="string">config</span> <span class="string">--global</span> <span class="string">user.email</span> <span class="string">me@razeen.me</span></span><br><span class="line">          <span class="string">git</span> <span class="string">config</span> <span class="string">--global</span> <span class="string">user.name</span> <span class="string">razeencheng</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Deploy</span> <span class="string">Blog</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">|</span> </span><br><span class="line">          <span class="string">hexo</span> <span class="string">clean</span></span><br><span class="line">          <span class="string">hexo</span> <span class="string">g</span></span><br><span class="line">          <span class="string">hexo</span> <span class="string">d</span></span><br></pre></td></tr></table></figure><p>我们来简单看一下这个配置：</p><ul><li><p><code>name: deploy_my_blog</code>: <code>name</code> 定义该工作流的名称为<code>deploy_my_blog</code>。</p></li><li><p><code>on: [push]</code>: <code>on</code> 定义触发条件，<code>push</code> 指我们每次推送的时候触发这个工作流。</p></li><li><p><code>jobs</code>: 在 <code>jobs</code> 中定义这个工作流执行的所有任务。</p><ul><li><p><code>build_and_deploy</code> : 我给这个任务取的<code>ID</code>。</p><ul><li><p><code>runs-on: ubuntu-latest</code>: <code>runs-on</code> 用来指定我们当前这个任务执行的机器。官方给我们几个共享的机器可以使用：</p><p><img data-src="https://st.razeen.cn/img/Snipaste_2021-06-26_17-33-16.png" alt></p><p>我们这里用的 Ubuntu 的机器。</p></li><li><p><code>steps</code>： 在任务中，我们执行的一系列的任务就叫<code>steps</code>。</p><ul><li><p><code>- uses: actions/checkout@v2</code> <code>- uses: actions/setup-node@v2</code> : 用<code>uses</code> 来指定我们需要调用的 Action。</p><p>我们这里用 <code>actions/checkout@v2</code> Checkout 到当前的仓库,</p><p>用<code>actions/setup-node@v2</code> 来安装 Node.js 到当前的环境中，用<code>with: node-version</code> 来指定 Node.js 的版本。由于我使用了一些较老的插件，和新版本<code>Node.js</code>有兼容问题， 所以Node.js 版本使用的是<code>12</code>， 你可以根据你实际情况来。</p></li><li><p>经过上面两个步骤，我们就进入了我们 Hexo 主题和配置仓库中，并且准备好了 <code>Node.js</code> 环境。 接下来，写入部署 SSH 密钥。</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Prepare</span> <span class="string">ssh</span> <span class="string">env</span>  <span class="comment"># 给我们这部取一个名字，可以省略</span></span><br><span class="line">  <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line">    <span class="string">mkdir</span> <span class="string">-p</span> <span class="string">~/.ssh</span></span><br><span class="line">    <span class="string">echo</span> <span class="string">"$SSH_DEPLOY_KEY"</span> <span class="string">|</span> <span class="string">tr</span> <span class="string">-d</span> <span class="string">'\r'</span> <span class="string">&gt;</span> <span class="string">~/.ssh/id_rsa</span></span><br><span class="line">    <span class="string">chmod</span> <span class="number">600</span> <span class="string">~/.ssh/id_rsa</span></span><br><span class="line">    <span class="string">ssh-keyscan</span> <span class="string">-H</span> <span class="string">'github.com'</span> <span class="string">&gt;&gt;</span> <span class="string">~/.ssh/known_hosts</span></span><br><span class="line">  <span class="attr">env:</span></span><br><span class="line">    <span class="attr">SSH_DEPLOY_KEY:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.MY_BLOG_DEPLOY_KEY</span> <span class="string">&#125;&#125;</span></span><br></pre></td></tr></table></figure><p><code>env</code>中读取我们设置的<code>Secrets</code>私钥，并写入环境变量<code>SSH_DEPLOY_KEY</code>.</p><p><code>run</code> 中，定义了我们该步骤运行的脚本。创建<code>.ssh</code>目录，写入私钥文件，并添加<code>known_hosts</code>.</p></li><li><p>接下来就是安装 <code>hexo</code> 和 博客需要的插件了。</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Prepare</span> <span class="string">hexo</span> <span class="string">and</span> <span class="string">npm</span> <span class="string">env</span></span><br><span class="line">  <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line">    <span class="string">npm</span> <span class="string">install</span> <span class="string">-g</span> <span class="string">hexo-cli</span></span><br><span class="line">    <span class="string">npm</span> <span class="string">install</span></span><br></pre></td></tr></table></figure></li><li><p>接下来把 Git 配置好，配置用于推送到 Github Pages 的邮箱和用户，如下，你可以修改成自己的邮箱和用户。</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Prepare</span> <span class="string">git</span> <span class="string">env</span></span><br><span class="line">  <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line">    <span class="string">git</span> <span class="string">config</span> <span class="string">--global</span> <span class="string">user.email</span> <span class="string">me@razeen.me</span></span><br><span class="line">    <span class="string">git</span> <span class="string">config</span> <span class="string">--global</span> <span class="string">user.name</span> <span class="string">razeencheng</span></span><br></pre></td></tr></table></figure></li><li><p>万事具备，开始部署，这一步就是我们原来手动部署时执行命令，即生成静态文件，并部署。</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Deploy</span> <span class="string">Blog</span></span><br><span class="line">  <span class="attr">run:</span> <span class="string">|</span> </span><br><span class="line">    <span class="string">hexo</span> <span class="string">clean</span></span><br><span class="line">    <span class="string">hexo</span> <span class="string">g</span></span><br><span class="line">    <span class="string">hexo</span> <span class="string">d</span></span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul></li></ul><p>这样，我们就编排好了，接下来只需要推送代码就可以触发执行了。</p><p>关于更多的 Github Actions 语法可以看<a href="https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions#about-yaml-syntax-for-workflows" target="_blank" rel="noopener">官方文档</a>.</p><h3 id="触发执行"><a href="#触发执行" class="headerlink" title="触发执行"></a>触发执行</h3><p>我们本地将代码推送上去后，可以在 Actions 看到正在执行和历史执行的 Action.</p><p><img data-src="https://st.razeen.cn/img/Snipaste_2021-06-26_18-15-43.png" alt></p><p>点击每一条 Action，可查看详细日志。</p><p><img data-src="https://st.razeen.cn/img/Snipaste_2021-06-26_18-17-39.png" alt></p><p>整个流程执行下来一分钟不到，很快。</p><p>之后，你可以看下你的 Github Pages, 应该是已经更新了~。</p><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>Github Action 整体使用下来，感觉很简单，高效。共享的 2核7G的 Runner 也够我们折腾不少东西了。更爽的是，利用这些自动化的工具，不仅让我节省了几分钟打包的时间，更帮我省去了换个机器写博客需要折腾环境的问题。</p><p>同时也希望能够帮到你。</p><p><strong>参考</strong></p><p><a href="https://docs.github.com/en/actions" target="_blank" rel="noopener">GitHub Actions</a></p><p><a href="https://sanonz.github.io/2020/deploy-a-hexo-blog-from-github-actions/#%E4%BB%8B%E7%BB%8D" target="_blank" rel="noopener">利用 Github Actions 自动部署 Hexo 博客</a></p>]]></content>
      <categories>
        <category>博客折腾日记</category>
      </categories>
      <tags>
        <tag>自动化</tag>
        <tag>Github Actions</tag>
        <tag>CI/CD</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>证书透明度是什么？它是怎么工作的？</title>
    <url>//post/what-ct-is-and-how-it-works.html</url>
    <content><![CDATA[<p>证书透明度致力于通过可审计的HTTPS提高互联网安全.</p><p>用一句话来说，证书透明度就是为HTTPS提供一个可审计，可追究责任的一种提高互联网安全的机制。</p><a id="more"></a><p>早在2016年谷歌就宣布从2017年10月起签发的证书都需要遵守其证书透明政策才能被浏览器信任，但2017年谷歌将强制性合规时间延迟到2018年4月。也就是说，在最新的Chrome中，你访问签发日期在2018年4月后的证书，凡是不在CT中的，Chrome将会标记器为不可信。</p><blockquote><p>20180509更新：<br>据最新了解，谷歌将强制证书透明度期限挪至Chrome68。</p></blockquote><p>在了解CT之前，我们先了解一下我们现在所处的互联网信任机制。</p><h3 id="信任和责任"><a href="#信任和责任" class="headerlink" title="信任和责任"></a>信任和责任</h3><p>我们在互联网上的每一动作都需要一个基本的信任体系。当你通过浏览器去访问你的银行账户或你喜爱的社交媒体时，你肯定希望你访问的那个网站就是你在浏览器输入的那个网站。这种期望就基于一个基本的信任体系，这就是我们常听见的web PKI(Public Key Infrastructure)系统。</p><p>从一个较高的层次来看，PKI系统就像一个公证人，它通过签发数字证书来赋予服务器为网站提供服务的能力。这个数字证书就是我们常说的证书了，它包括了网站的域名，组织名称，有效期和一个公钥。对于每一个公钥来说，都有一个对应的私钥。如果服务器需要使用指定证书去为网站提供HTTPS服务，那么这个服务器就需要证明对该私钥的所有权。</p><p><img data-src="https://st.razeen.cn/img/image/ct/image01.png" alt></p><p>网站获取数字证书的第三方机构就是CAs(Certificate Authorities). CAs在颁发证书前会验证操作者的域名所有权。如果一个数字证书是由一个浏览器信任的CA颁发的，那么该证书就可以用于HTTPS站点了。所有的这些验证都是浏览器内部实现的，给用户的唯一感知的只是浏览器上一个小绿锁🔐，或是出错时的一个错误。</p><p>PKI系统本身是很好的，但是作为一个信任系统，依然存在很多风险。一个最基本的风险就是，CA机构可以为任何网站颁发证书。这就意味着，<a href="https://bugzilla.mozilla.org/show_bug.cgi?id=408949" target="_blank" rel="noopener">Hong Kong Post Office</a>可以为gmail.com或facebook.com签发证书，而且被大部分浏览器信任。更糟糕的是，如果CA被黑客攻击了，那么黑客可以在CA毫无知觉的情况下颁发任何证书，从而导致用户处于一个高风险的处境中。</p><p><img data-src="https://st.razeen.cn/img/image/ct/image02.png" alt></p><p>如果某人控制了一个不属于他自己站点的证书，那么他可以模拟这个站点，从而窃取用户的信息。就目前来说，像火狐，苹果，谷歌都有他们自己的信任CA库。如果这些CA出现些问题，用户将承担很大的风险。</p><p>从中可看出，PKI少的就是责任追究机制。如果一个误颁发的证书只影响到个人，这中间没有任何反馈机制让其他人知道CA的失误行为。</p><p>这不是一个假想的状态。就在2011年，DigiNotar，一个荷兰的CA机构，被黑客攻陷。黑客利用该CA签发了一张<code>*.google.com</code>的证书，他们试图模拟Gmail，窃取伊朗用户的个人信息。</p><p>但这次攻击被Google探测到了，通过公钥固定技术(public key pinning)。公钥固定是一个有风险的技术，只有一些技术过硬的公司在使用。公钥固定所带来的风险往往超过其价值，它通常被认为是蹩脚机制的典型例子，被浏览器弃用。</p><p>如果公钥固定机制也不起作用了，那么我们怎么去探测CA的一些错误？这时CT就应运而生。CT的目标就是让所有的证书透明，这样误颁发的证书也能被发现，从而可以采取相应的应对措施。</p><h3 id="CT的组成"><a href="#CT的组成" class="headerlink" title="CT的组成"></a>CT的组成</h3><p>如果所有的证明都透明化，那么误颁发的证书将暴露在公众视野中。CT通过区块链技术给PKI带来了一个责任追究机制。CT将可信的证书加入一个列表供每一个人审计。这听起来很简单，但考虑到互联网的分散性，建立一个可靠地责任追究机制还是有相当的挑战的。</p><p>CT系统是MPKI的一个延伸，它向MPKI中加入了新的参与者和角色。除浏览器和CA外，还引入了新的参与方，从而保证整个系统的健康状态。这几个方面是：</p><ul><li>日志操作员（Log operators)</li><li>审计员 （Auditors)</li><li>监控 （Monitors)</li></ul><p>从某种意义上说，日志操作员是管理证书列表的人员，只有它才能往列表中添加证书。如果有人CT日志提交了一个浏览器信任的证书，日志操作员需要在最大合并延迟（MMD),一般24小时内将该证书合并到列表中。CT日志给提交者返回一张收据，也就是证书签名时间戳(SCT)。SCT证明了在宽限的期限内将证书包含在CT日志中。你可以通过CT API与CT日志交互（<a href="https://tools.ietf.org/html/rfc6962" target="_blank" rel="noopener">RFC 6962</a>)。</p><p>审计员是一个保证日志操作员诚实的第三方机构。他们从互联网上的各个可用位置查询日志，并相互比对有关证书的内容。它们就像PKI的狗仔队一样。他们还通过测量SCT的时间戳和日志中显示的相应证书之间的时间来跟踪SCT是否准确。</p><p>监控是一种帮助提醒网站提示错误的服务。它会抓取日志以获取新证书，并在网站所有者发现新证书时提醒网站所有者。流行的监控包括SSLMate的<a href="https://sslmate.com/certspotter/" target="_blank" rel="noopener">CertSpotter</a>和Facebook的<a href="https://developers.facebook.com/tools/ct/" target="_blank" rel="noopener">证书透明度监控</a>。 Cloudflare计划在年底前为客户提供集成到Cloudflare仪表板中的免费日志监控服务。</p><h3 id="让浏览器感知证书已加入日志"><a href="#让浏览器感知证书已加入日志" class="headerlink" title="让浏览器感知证书已加入日志"></a>让浏览器感知证书已加入日志</h3><p>推动网站采用CT的一种方式是浏览器开始要求网站的证书被CT日子记录。通过在建立连接时直接查询CT日志来验证证书是否存已经加入日志的方式在潜在的隐私问题（将浏览器历史暴露给第三方），而且增加了延迟。相反，确保证书已加入日志的更好方法是要求服务器提供SCT，即上一节中介绍的日志返回的收据。</p><p>SCT可以通过多种方式呈现给客户端。最常用的方法是在签发证书时将SCT嵌入到证书中。这涉及CA在证书最终确定之前向各种CT日志提交预证书（证书的前体）以获取SCT。</p><p><img data-src="https://st.razeen.cn/img/image/ct/image03.png" alt></p><p>对于没有嵌入SCT的证书，服务器有其他机制可将SCT传输到客户端。 SCT可以作为TLS扩展或作为OCSP响应包含在连接中。这些机制更难以可靠地执行，但它们允许任何证书被包含在CT中。</p><p><img data-src="https://st.razeen.cn/img/image/ct/image04.png" alt></p><p>A certificate with embedded SCTs</p><h3 id="CT的浏览器支持"><a href="#CT的浏览器支持" class="headerlink" title="CT的浏览器支持"></a>CT的浏览器支持</h3><p>并非所有日志都是平等创建的。恶意CA可能会与一组日志共同创建一个证书和一组SCT，而不会将证书合并到日志中。这个证书可以被用来攻击用户。为了保护生态系统免遭这种串通风险，支持CT的浏览器只选择主动接受审核的日志列表中的SCT。除此之外，还有多样性要求：日志应由不同基础设施上的不同实体进行管理，以避免串通或日志服务中断。如果连接从审查日志向客户端提供了足够多的SCT以符合证书的风险特征，则连接被认为是“CT合格”。</p><p>为了使连接在Chrome中符合CT条件，那就必须遵循Chrome的CT政策。对于大多数证书而言，这意味着至少需要为Chrome提供一个Google或一个非Google但被Chrome信任的日志才能显示SCT。有效期较长的证书必须有超过两个SCT。</p><p>为了成为受Chrome的信任的CT日志服务，CT日志服务需要向Chrome提交，并通过长达90天的监控期。在此期间，必须通过一些严格的要求。其中包括：</p><ul><li>没有超过超过24小时的MMD（最大合并延迟）的中断</li><li>有99％的正常运行时间，没有停机时间超过最大合并延迟时间（由Google测量）</li><li>在最大合并延迟的时间内将日志中已签发SCT加入日志列表</li><li>通过始终提供Merkle树的一致视图保持Log的只添加属性</li></ul><p>完整的政策在<a href="https://github.com/chromium/ct-policy/blob/master/log_policy.md" target="_blank" rel="noopener">这里</a>。<a href="https://www.gstatic.com/ct/log_list/log_list.json" target="_blank" rel="noopener">这里</a>有完整的审查日志列表。</p><h3 id="All-or-nothing"><a href="#All-or-nothing" class="headerlink" title="All or nothing"></a>All or nothing</h3><p>CT只有在所有证书都记录在可信的日志中时才真正的确保用户的安全。如果CA颁发的证书被浏览器信任，但未提交到CT日志中，则用户仍然可能受到有针对性的攻击。</p><p>在过去的几年中，Chrome已经要求<a href="https://www.certificate-transparency.org/ev-ct-plan" target="_blank" rel="noopener">所有的EV证书都符合CT标准</a>。这还不够。只要存在浏览器信任但未提交到CT的证书，用户就会面临风险。这就是为什么Chrome团队宣布他们将在<a href="https://groups.google.com/a/chromium.org/forum/#!topic/ct-policy/sz_3W_xKBNY" target="_blank" rel="noopener">2018年4月</a>开始要求所有新颁发的，公开信任的证书支持证书透明。</p><h3 id="CA的改变"><a href="#CA的改变" class="headerlink" title="CA的改变"></a>CA的改变</h3><p>在浏览器中展示时，确保证书始终是符合CT政策的最安全方法是向足够的CT日志提交而获得足够的SCT从而保证符合浏览器的策略。但这对于一些CA来说，在操作上，这是一个很大改变，因为</p><ul><li>它增加了必须了解不同浏览器的CT策略需要哪些SCT并跟上策略变化的额外步骤</li><li>它在颁发过程中添加了一个步骤，在该过程中将证书颁发前的预证书(pre-certificates)提交到不同的日志</li><li>一些CT日志可能有中断或响应速度缓慢，因此可能需要回退策略才能避免延迟发布</li></ul><h3 id="建立一个可验证的全球一致的日志"><a href="#建立一个可验证的全球一致的日志" class="headerlink" title="建立一个可验证的全球一致的日志"></a>建立一个可验证的全球一致的日志</h3><p>PKI体系是巨大的。<a href="https://blog.cloudflare.com/https-or-bust-chromes-plan-to-label-sites-as-not-secure/" target="_blank" rel="noopener">业界对HTTPS的推动</a>已经向Web PKI引入了数百万个新证书。 CT中记录了超过25亿个证书！这个数字每天增长将近一百万。随着接Chrome的四月份期限到来，这个数字肯定还会增长。管理一个如此大的只添加、高可用的数据库是一项重大的工程挑战。</p><p>用于只增数据库的天然数据结构是哈希链。在哈希链中，元素按顺序对齐并使用SHA-256等单向哈希函数进行组合。下图描述了如何从值列表d1到d8创建哈希链。从第一个元素d1开始，d1的哈希值为a，然后变成链的头部。每当元素被添加到链中时，从当前链头和新元素计算出新的散列值。这个散列值成为新的链头。因为单向哈希函数不能被逆转，所以不可能在不改变整个链的情况下改变一个值。这使得哈希链的历史记录非常难以篡改。</p><p><img data-src="https://st.razeen.cn/img/image/ct/image05.gif" alt></p><p>哈希链是插入新元素的最佳数据结构：每个新增的元素只需计算一个哈希值。 然而，在验证元素是否正确的加入给定的了链头中，它的效率不是很理想。 在下面的例子中，你需要六个额外的元素（b，d4-d8）才能验证d3在8个值的链上是正确的。 你平均需要大约n / 2个元素才能验证长度为n的链中的元素。 在计算机科学方面，这被称为“线性缩放”。</p><p><img data-src="https://st.razeen.cn/img/image/ct/image06.gif" alt></p><p>在构建系统时，最好尽量降低参与者的复杂度。对于CT，我们主要关心的参与者是日志操作员和审核员。如果我们选择一个散列链作为我们的数据结构，日志操作员的工作将很容易，但审核员的工作将非常困难。我们可以做得更好。</p><p>当你问一位科学家如何优化算法时，十次有九次，他们建议的解决方案是使用一棵树（另外1/10次，他们会建议<a href="https://en.wikipedia.org/wiki/Bloom_filter" target="_blank" rel="noopener">布隆过滤器</a>）。这正是我们在这里所能做的。具体来说，我们可以使用一个名为Merkle树的数据结构。它就像一个哈希链，但不是在一行中散列元素，而是成对哈希。</p><p>对于每个新元素，不是将其散列加入总树中，而是将元素排列到<a href="https://en.wikipedia.org/wiki/Binary_tree" target="_blank" rel="noopener">平衡二叉树</a>中，并计算该元素与其兄弟的散列。这里给你一半的值，将这些值得散列成对排列创建数的下一层，然后继续，直到你得到一个元素，树的顶部也就是树头。向Merkle树添加一个新值需要修改树中每层最多一个散列，也就是从这个元素到树头路径上的散列。</p><p><img data-src="https://st.razeen.cn/img/image/ct/image07.gif" alt></p><p>二叉树的深度相对于元素的数量是<a href="https://en.wikipedia.org/wiki/Logarithmic_scale" target="_blank" rel="noopener">对数</a>的。 粗略地说，如果树大小为8 = 2 ^ 3，则深度为4（= 3 + 1），如果是1024 = 2 ^ 10，则树深度为11（= 10 + 1），对于1048576 = 2 ^ 20树的大小是21（= 20 + 1）。 插入的代价至多是log_2（size），这比散列链中的差，但通常不会太糟糕。</p><p>使Merkle树如此有用的主要原因是它的验证效率。 不需要像在散列链中那样计算n / 2散列，只需要树中将元素引导到根的元素值即可， 这被称为共路径。 下图为d3计算共同路径。</p><p><img data-src="https://st.razeen.cn/img/image/ct/image08.gif" alt></p><p>copath包含树的每个级别的一个值。 因此，证明一个元素是正确的（包含证明）所需的计算是对数的，而不是像散列树那样的线性。 相对而言树的插入和验证都很高效，这使得Merkle树成为CT的理想数据结构。</p><p><img data-src="https://st.razeen.cn/img/image/ct/image09.png" alt></p><p>证书透明日志也就是图中叶子元素是证书的Merkle树。 每个日志都有一个私钥，用于定期为当前树头签名。 一些CT日志非常庞大，有超过一亿的条目，但由于Merkle树的效率，包含证明只需要大约30次哈希。 这种结构在日志操作员向日志中添加证书时的成本与审计员验证其一致性的成本之间提供了良好的平衡。</p><ul><li>原文在<a href="https://blog.cloudflare.com/introducing-certificate-transparency-and-nimbus/" target="_blank" rel="noopener">这里</a></li></ul>]]></content>
      <categories>
        <category>PKI/CA与数字证书</category>
      </categories>
      <tags>
        <tag>https</tag>
        <tag>ct</tag>
        <tag>certificate-transparency</tag>
        <tag>pki</tag>
        <tag>merkle树</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows10 VPN L2TP/IPSec 找不到共享密钥入口？</title>
    <url>//post/win10-vpn-lztp-ipsec-sharekey.html</url>
    <content><![CDATA[<p>在win10上使用vpn，L2TP/IPSec 有些是需要设置一个共享密钥的，结果如下图所示，没有输入的入口。</p><p><img data-src="https://st.razeen.cn/img/201811/jietu20181116-142843.png" alt></p><a id="more"></a><p>少了共享密钥肯定是无法连接的，经过一番google，了解到需要如下设置。</p><p>打开设置-&gt;网络与Internet。 然后如下操作。</p><p><img data-src="https://st.razeen.cn/img/201811/jietu20181116-143203.png" alt></p><p>然后就可以愉快的连接。</p><p>记录一下。</p>]]></content>
      <categories>
        <category>家庭网络折腾</category>
      </categories>
      <tags>
        <tag>vpn</tag>
      </tags>
  </entry>
  <entry>
    <title>电信悦me网关修改桥接模式，路由器拨号</title>
    <url>//post/yue-me-bridge.html</url>
    <content><![CDATA[<p>由于要做端口转发，每次要到悦me的网关上操作，但电信这网关操作起来体验不是很好，比较卡。于是昨天改成了桥接模式，然后利用路由器拨号。这样每次只要在路由器上操作，方便多了，故分享一下。</p><a id="more"></a><h3 id="获取超密"><a href="#获取超密" class="headerlink" title="获取超密"></a>获取超密</h3><p>我的超密是当初安装的时候让安装的师傅告诉我的。听说打10000号有可能能问到。实在不是貌似可以问马云==。</p><h3 id="获取拨号账号与密码"><a href="#获取拨号账号与密码" class="headerlink" title="获取拨号账号与密码"></a>获取拨号账号与密码</h3><p>用超密登陆后，在 <code>网络&gt;宽带设置&gt;Internet连接</code> 中我们可以通过<code>连接名称</code>找到一个类似<code>3_INTERNET_R_VID_</code>的通道。不同的光猫可能有点不一样。</p><p>我们看到的图上三个其实指的就是三个不同的通道。其中</p><ul><li><code>1_TR069_VOICE_R_VID_46</code> 为语音通道，为语言业务服务的；</li><li><code>2_OTHER_B_VID_85</code> 为 <code>IPTV</code>通道，<code>IPTV</code>业务会用到；</li><li><code>3_INTERNET_R_VID_</code> 即使我们的上网通道了（下图是改桥接后，又改回来截图的，有点不一致）；</li></ul><p><img data-src="https://st.razeen.cn/img/20210303235242_image-20210303235242806.png" alt="image-20210303235242806"></p><p>选中<code>3_INTERNET_R_VID_</code>后，我们就可以看到下面应该有一个 用户名，密码，这就是拨号用的用户名密码。但密码是不显示的，这就需要我们做点额外工作去获取了。</p><p>通过访问 <a href="http://192.168.1.1/backupsettings.conf" target="_blank" rel="noopener">http://192.168.1.1/backupsettings.conf</a> 可以获取到配置文件，用文本编辑器打开，如下图所示，通过搜索 用户名 可以快速定位到密码。</p><p><img data-src="https://st.razeen.cn/img/20210304003115_2021-03-04_00-30.png" alt></p><p>但这个密码是<code>base64</code>后的，我们需要解析一下。</p><p>可以和我这样直接用 base64 命令去解析，也可以找个 <a href="https://tool.oschina.net/encrypt?type=3" target="_blank" rel="noopener">base64 解码网站 </a>解析一下就可以拿到拨号密码。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> MTIzNDU2NzgK | base64 -d</span><br><span class="line">12345678</span><br></pre></td></tr></table></figure><h3 id="修改桥接模式"><a href="#修改桥接模式" class="headerlink" title="修改桥接模式"></a>修改桥接模式</h3><p>有了账号密码就可以开始桥接了。光猫这边把原来的<code></code>3_INTERNET_R_VID_<code>删除了，然后新建WAN连接，选择</code>Brdige`模式，保存应用。如下：</p><p><img data-src="https://st.razeen.cn/img/20210303230658_image-20210303000936851.png" alt="image-20210303000936851"></p><h3 id="路由器拨号"><a href="#路由器拨号" class="headerlink" title="路由器拨号"></a>路由器拨号</h3><p>登陆路由器，我的路由器是<a href="https://razeen.cn/post/start-use-newifi3.html" target="_blank" rel="noopener">刷的老毛子</a>。在外网设置中，选择<code>PPPoE: 拨号</code>, 填上用户名，密码，应用即可。</p><p><img data-src="https://st.razeen.cn/img/20210304001955_image-20210304001955049.png" alt="image-20210304001955049"></p><p>大概等几分钟，在网络状态中就可以看到<code>已连接</code>。 然后成功获取到了<code>IPv4, IPv6</code>地址（IPv6获取时间会长一点）。</p><p><img data-src="https://st.razeen.cn/img/20210303003227_image-20210303003227119.png" alt="image-20210303003227119"></p><p>到这里我们就成功用路由器拨号上网啦。买一个还不错的路由器，然后又有公网IP，可以好好再折腾一番了。</p>]]></content>
      <categories>
        <category>家庭网络折腾</category>
      </categories>
      <tags>
        <tag>router</tag>
      </tags>
  </entry>
</search>
